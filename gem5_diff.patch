diff --git a/configs/common/MemConfig.py b/configs/common/MemConfig.py
index 522cfe064..8221f85f0 100644
--- a/configs/common/MemConfig.py
+++ b/configs/common/MemConfig.py
@@ -41,8 +41,7 @@ from common import ObjectList
 from common import HMC
 
 def create_mem_intf(intf, r, i, nbr_mem_ctrls, intlv_bits, intlv_size,
-                    xor_low_bit, options):
-
+                    xor_low_bit):
     """
     Helper function for creating a single memoy controller from the given
     options.  This function is invoked multiple times in config_mem function
@@ -67,16 +66,7 @@ def create_mem_intf(intf, r, i, nbr_mem_ctrls, intlv_bits, intlv_size,
     interface = intf()
 
     # Only do this for DRAMs
-     # gagan : ramulator integration
-    if issubclass(intf, m5.objects.Ramulator):
-        if not options.ramulator_config:
-            fatal("--mem-type=ramulator require --ramulator-config option")
-#        interface.real_warm_up = options.real_warm_up
-        interface.config_file = options.ramulator_config
-        interface.output_dir = m5.options.outdir + "/"
-        print("Ramulator system configuration file = ", options.ramulator_config)
-        interface.num_cpus = options.num_cpus
-    elif issubclass(intf, m5.objects.DRAMInterface):
+    if issubclass(intf, m5.objects.DRAMInterface):
         # If the channel bits are appearing after the column
         # bits, we need to add the appropriate number of bits
         # for the row buffer size
@@ -213,8 +203,7 @@ def config_mem(options, system):
             if opt_mem_type and (not opt_nvm_type or range_iter % 2 != 0):
                 # Create the DRAM interface
                 dram_intf = create_mem_intf(intf, r, i, nbr_mem_ctrls,
-                                    intlv_bits, intlv_size, opt_xor_low_bit, options)
-
+                                    intlv_bits, intlv_size, opt_xor_low_bit)
 
                 # Set the number of ranks based on the command-line
                 # options if it was explicitly set
@@ -232,11 +221,7 @@ def config_mem(options, system):
                         "latency to 1ns.")
 
                 # Create the controller that will drive the interface
-                if opt_mem_type == "Ramulator":
-                    print("MEMORY TYPE::",opt_mem_type)
-                    print(type(dram_intf))
-                    mem_ctrl = dram_intf
-                elif opt_mem_type == "HMC_2500_1x32":
+                if opt_mem_type == "HMC_2500_1x32":
                     # The static latency of the vault controllers is estimated
                     # to be smaller than a full DRAM channel controller
                     mem_ctrl = m5.objects.MemCtrl(min_writes_per_switch = 8,
@@ -249,10 +234,7 @@ def config_mem(options, system):
 
                 # Hookup the controller to the interface and add to the list
                 if opt_mem_type != "SimpleMemory":
-                    if opt_mem_type != "Ramulator":
-                       mem_ctrl.dram = dram_intf
-
-
+                    mem_ctrl.dram = dram_intf
 
                 mem_ctrls.append(mem_ctrl)
 
diff --git a/configs/common/Options.py b/configs/common/Options.py
index 547297e8c..32f8dd94b 100644
--- a/configs/common/Options.py
+++ b/configs/common/Options.py
@@ -112,8 +112,6 @@ def addNoISAOptions(parser):
                        help="Enable low-power states in DRAMInterface")
     parser.add_option("--mem-channels-intlv", type="int", default=0,
                       help="Memory channels interleave")
-    parser.add_option("--ramulator-config", type="string", dest="ramulator_config",
-                      help="Specify Ramulator configuration file, overrides other --mem-XXX options")
 
 
     parser.add_option("--memchecker", action="store_true")
diff --git a/configs/ramulator/ALDRAM-config.cfg b/configs/ramulator/ALDRAM-config.cfg
deleted file mode 100644
index 91cef49c6..000000000
--- a/configs/ramulator/ALDRAM-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = ALDRAM
- channels = 1
- ranks = 1
- speed = ALDRAM_1600K
- org = ALDRAM_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/DDR3-config.cfg b/configs/ramulator/DDR3-config.cfg
deleted file mode 100644
index 777f6b586..000000000
--- a/configs/ramulator/DDR3-config.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR3
- channels = 1
- ranks = 1
- speed = DDR3_1600K
- org = DDR3_2Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
-# warmup_insts = 100000000
- warmup_insts = 0
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/DDR4-config.cfg b/configs/ramulator/DDR4-config.cfg
deleted file mode 100644
index bbbd24561..000000000
--- a/configs/ramulator/DDR4-config.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 1
- speed = DDR4_2400R
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
-#  warmup_insts = 100000000
- warmup_insts = 0
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/DSARP-config.cfg b/configs/ramulator/DSARP-config.cfg
deleted file mode 100644
index b67c067ce..000000000
--- a/configs/ramulator/DSARP-config.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DSARP
- subarrays = 8
- channels = 1
- ranks = 1
- speed = DSARP_1333
- org = DSARP_8Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/GDDR5-config.cfg b/configs/ramulator/GDDR5-config.cfg
deleted file mode 100644
index 96006841c..000000000
--- a/configs/ramulator/GDDR5-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = GDDR5
- channels = 1
- ranks = 1
- speed = GDDR5_6000
- org = GDDR5_8Gb_x16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 2
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/HBM-config.cfg b/configs/ramulator/HBM-config.cfg
deleted file mode 100644
index 45ae57da4..000000000
--- a/configs/ramulator/HBM-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = HBM
- channels = 8
- ranks = 1
- speed = HBM_1Gbps
- org = HBM_4Gb
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 32
- mem_tick = 5
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/LPDDR3-config.cfg b/configs/ramulator/LPDDR3-config.cfg
deleted file mode 100644
index b5618bc36..000000000
--- a/configs/ramulator/LPDDR3-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = LPDDR3
- channels = 1
- ranks = 1
- speed = LPDDR3_1600
- org = LPDDR3_8Gb_x16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/LPDDR4-config.cfg b/configs/ramulator/LPDDR4-config.cfg
deleted file mode 100644
index b74512c98..000000000
--- a/configs/ramulator/LPDDR4-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = LPDDR4
- channels = 2
- ranks = 1
- speed = LPDDR4_2400
- org = LPDDR4_8Gb_x16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/PCM-config.cfg b/configs/ramulator/PCM-config.cfg
deleted file mode 100644
index 1bd7fcceb..000000000
--- a/configs/ramulator/PCM-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = PCM
- channels = 1
- ranks = 1
- speed = PCM_800D
- org = PCM_2Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/SALP-config.cfg b/configs/ramulator/SALP-config.cfg
deleted file mode 100644
index 0e5a809ad..000000000
--- a/configs/ramulator/SALP-config.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = SALP-MASA
- subarrays = 8
- channels = 1
- ranks = 1
- speed = SALP_1600K
- org = SALP_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/STTMRAM-config.cfg b/configs/ramulator/STTMRAM-config.cfg
deleted file mode 100644
index b689e5145..000000000
--- a/configs/ramulator/STTMRAM-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = STTMRAM
- channels = 4
- ranks = 1
- speed = STT_1600_1_2
- org = STTMRAM_2Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/TLDRAM-config.cfg b/configs/ramulator/TLDRAM-config.cfg
deleted file mode 100644
index 0f7e06e90..000000000
--- a/configs/ramulator/TLDRAM-config.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = TLDRAM
- subarrays = 16
- channels = 1
- ranks = 1
- speed = TLDRAM_1600K
- org = TLDRAM_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/WideIO-config.cfg b/configs/ramulator/WideIO-config.cfg
deleted file mode 100644
index 5270d3cb6..000000000
--- a/configs/ramulator/WideIO-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = WideIO
- channels = 4
- ranks = 1
- speed = WideIO_266
- org = WideIO_8Gb
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 4
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/configs/ramulator/WideIO2-config.cfg b/configs/ramulator/WideIO2-config.cfg
deleted file mode 100644
index 324b78fea..000000000
--- a/configs/ramulator/WideIO2-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = WideIO2
- channels = 8
- ranks = 1
- speed = WideIO2_1066
- org = WideIO2_8Gb
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 6
- mem_tick = 1
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translatino = None, Random (default value is None)
-#
-########################
diff --git a/ext/ramulator/README b/ext/ramulator/README
deleted file mode 100644
index e1850e929..000000000
--- a/ext/ramulator/README
+++ /dev/null
@@ -1,11 +0,0 @@
-To use Ramulator in gem5 simulations
-
-1. Download Ramulator
-    1.1 Go to ext/ramulator (this directory)
-    1.2 Clone Ramulator: git clone git://github.com/CMU-SAFARI/ramulator.git
-
-2. Compile gem5
-
-3. Run gem5 with Ramulator
-    3.1 Use --mem-type=ramulator and --ramulator-config=XXX
-
diff --git a/ext/ramulator/Ramulator/src/ALDRAM.cpp b/ext/ramulator/Ramulator/src/ALDRAM.cpp
deleted file mode 100644
index 453300baa..000000000
--- a/ext/ramulator/Ramulator/src/ALDRAM.cpp
+++ /dev/null
@@ -1,362 +0,0 @@
-#include <iostream>
-
-#include "ALDRAM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string ALDRAM::standard_name = "ALDRAM";
-string ALDRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum ALDRAM::Org> ALDRAM::org_map = {
-    {"ALDRAM_512Mb_x4", ALDRAM::Org::ALDRAM_512Mb_x4}, {"ALDRAM_512Mb_x8", ALDRAM::Org::ALDRAM_512Mb_x8}, {"ALDRAM_512Mb_x16", ALDRAM::Org::ALDRAM_512Mb_x16},
-    {"ALDRAM_1Gb_x4", ALDRAM::Org::ALDRAM_1Gb_x4}, {"ALDRAM_1Gb_x8", ALDRAM::Org::ALDRAM_1Gb_x8}, {"ALDRAM_1Gb_x16", ALDRAM::Org::ALDRAM_1Gb_x16},
-    {"ALDRAM_2Gb_x4", ALDRAM::Org::ALDRAM_2Gb_x4}, {"ALDRAM_2Gb_x8", ALDRAM::Org::ALDRAM_2Gb_x8}, {"ALDRAM_2Gb_x16", ALDRAM::Org::ALDRAM_2Gb_x16},
-    {"ALDRAM_4Gb_x4", ALDRAM::Org::ALDRAM_4Gb_x4}, {"ALDRAM_4Gb_x8", ALDRAM::Org::ALDRAM_4Gb_x8}, {"ALDRAM_4Gb_x16", ALDRAM::Org::ALDRAM_4Gb_x16},
-    {"ALDRAM_8Gb_x4", ALDRAM::Org::ALDRAM_8Gb_x4}, {"ALDRAM_8Gb_x8", ALDRAM::Org::ALDRAM_8Gb_x8}, {"ALDRAM_8Gb_x16", ALDRAM::Org::ALDRAM_8Gb_x16},
-};
-
-map<string, enum ALDRAM::Speed> ALDRAM::speed_map = {
-    {"ALDRAM_800D", ALDRAM::Speed::ALDRAM_800D}, {"ALDRAM_800E", ALDRAM::Speed::ALDRAM_800E},
-    {"ALDRAM_1066E", ALDRAM::Speed::ALDRAM_1066E}, {"ALDRAM_1066F", ALDRAM::Speed::ALDRAM_1066F}, {"ALDRAM_1066G", ALDRAM::Speed::ALDRAM_1066G},
-    {"ALDRAM_1333G", ALDRAM::Speed::ALDRAM_1333G}, {"ALDRAM_1333H", ALDRAM::Speed::ALDRAM_1333H},
-    {"ALDRAM_1600H", ALDRAM::Speed::ALDRAM_1600H}, {"ALDRAM_1600J", ALDRAM::Speed::ALDRAM_1600J}, {"ALDRAM_1600K", ALDRAM::Speed::ALDRAM_1600K},
-    {"ALDRAM_1866K", ALDRAM::Speed::ALDRAM_1866K}, {"ALDRAM_1866L", ALDRAM::Speed::ALDRAM_1866L},
-    {"ALDRAM_2133L", ALDRAM::Speed::ALDRAM_2133L}, {"ALDRAM_2133M", ALDRAM::Speed::ALDRAM_2133M},
-};
-
-
-ALDRAM::ALDRAM(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(Temp::COLD)][int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    current_speed = speed;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_lambda();
-    init_timing(speed_table[int(Temp::HOT)][int(speed)]);
-    temperature = Temp::COLD;
-}
-
-ALDRAM::ALDRAM(const string& org_str, const string& speed_str) :
-    ALDRAM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void ALDRAM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void ALDRAM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void ALDRAM::aldram_timing(Temp current_temperature)
-{
-    for (int i = 0; i < int(Level::MAX); i++) {
-        for (int j = 0; j < int(Command::MAX); j++) {
-            timing[i][j].clear();
-        }
-    }
-    temperature = current_temperature;
-    read_latency = speed_entry.nCL + speed_entry.nBL;
-    init_timing(speed_table[int(temperature)][int(current_speed)]);
-
-    //std::cout << "vector size: " << timing[int(Temp::HOT)][int(current_speed)].size() << endl;
-    //std::cout << "after cold nRCD : ";
-    //std::cout << int(timing[int(Level::Bank)][int(Command::ACT)][0].val) << endl << endl;
-}
-
-void ALDRAM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void ALDRAM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void ALDRAM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-
-void ALDRAM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<ALDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<ALDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<ALDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<ALDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void ALDRAM::init_timing(SpeedEntry speed_entry)
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/ALDRAM.h b/ext/ramulator/Ramulator/src/ALDRAM.h
deleted file mode 100644
index dad6228ac..000000000
--- a/ext/ramulator/Ramulator/src/ALDRAM.h
+++ /dev/null
@@ -1,249 +0,0 @@
-#ifndef __ALDRAM_H
-#define __ALDRAM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class ALDRAM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    enum class Temp;
-
-    ALDRAM(Org org, Speed speed);
-    ALDRAM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<ALDRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<ALDRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<ALDRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<ALDRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        ALDRAM_512Mb_x4, ALDRAM_512Mb_x8, ALDRAM_512Mb_x16,
-        ALDRAM_1Gb_x4,   ALDRAM_1Gb_x8,   ALDRAM_1Gb_x16,
-        ALDRAM_2Gb_x4,   ALDRAM_2Gb_x8,   ALDRAM_2Gb_x16,
-        ALDRAM_4Gb_x4,   ALDRAM_4Gb_x8,   ALDRAM_4Gb_x16,
-        ALDRAM_8Gb_x4,   ALDRAM_8Gb_x8,   ALDRAM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        ALDRAM_800D,  ALDRAM_800E,
-        ALDRAM_1066E, ALDRAM_1066F, ALDRAM_1066G,
-        ALDRAM_1333G, ALDRAM_1333H,
-        ALDRAM_1600H, ALDRAM_1600J, ALDRAM_1600K,
-        ALDRAM_1866K, ALDRAM_1866L,
-        ALDRAM_2133L, ALDRAM_2133M,
-        MAX
-    };
-
-    Speed current_speed;
-
-    enum class Temp : int
-    {
-        COLD, HOT, MAX
-    };
-
-    Temp temperature = Temp::HOT;  // DHL
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Temp::MAX)][int(Speed::MAX)] = {
-        {
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5-1,  5-1,  5, 15-5, 20-6, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6-1,  6-1,  5, 15-5, 21-6, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6-1,  6-1,  6, 20-5, 26-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7-1,  7-1,  6, 20-5, 27-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8-1,  8-1,  6, 20-5, 28-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8-1,  8-1,  7, 24-5, 32-6, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9-1,  9-1,  7, 24-5, 33-6, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9-2,  9-2,  8, 28-10, 37-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10-2, 10-2,  8, 28-10, 38-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11-2, 11-2,  8, 28-10, 39-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11-2, 11-2,  9, 32-10, 43-12, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12-2, 12-3,  9, 32-10, 44-13, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12-2, 12-3, 10, 36-10, 48-13, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13-2, 13-3, 10, 36-10, 49-13, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-        },
-        {
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-        }
-    }, speed_entry;
-
-    int read_latency;
-    void aldram_timing(Temp current_temperature);
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing(SpeedEntry speed_entry);
-};
-
-} /*namespace ramulator*/
-
-#endif /*__ALDRAM_H*/
diff --git a/ext/ramulator/Ramulator/src/Cache.cpp b/ext/ramulator/Ramulator/src/Cache.cpp
deleted file mode 100644
index 6a383ed41..000000000
--- a/ext/ramulator/Ramulator/src/Cache.cpp
+++ /dev/null
@@ -1,432 +0,0 @@
-#include "Cache.h"
-
-#ifndef DEBUG_CACHE
-#define debug(...)
-#else
-#define debug(...) do { \
-          printf("\033[36m[DEBUG] %s ", __FUNCTION__); \
-          printf(__VA_ARGS__); \
-          printf("\033[0m\n"); \
-      } while (0)
-#endif
-
-namespace ramulator
-{
-
-Cache::Cache(int size, int assoc, int block_size,
-    int mshr_entry_num, Level level,
-    std::shared_ptr<CacheSystem> cachesys):
-    level(level), cachesys(cachesys), higher_cache(0),
-    lower_cache(nullptr), size(size), assoc(assoc),
-    block_size(block_size), mshr_entry_num(mshr_entry_num) {
-
-  debug("level %d size %d assoc %d block_size %d\n",
-      int(level), size, assoc, block_size);
-
-  if (level == Level::L1) {
-    level_string = "L1";
-  } else if (level == Level::L2) {
-    level_string = "L2";
-  } else if (level == Level::L3) {
-    level_string = "L3";
-  }
-
-  is_first_level = (level == cachesys->first_level);
-  is_last_level = (level == cachesys->last_level);
-
-  // Check size, block size and assoc are 2^N
-  assert((size & (size - 1)) == 0);
-  assert((block_size & (block_size - 1)) == 0);
-  assert((assoc & (assoc - 1)) == 0);
-  assert(size >= block_size);
-
-  // Initialize cache configuration
-  block_num = size / (block_size * assoc);
-  index_mask = block_num - 1;
-  index_offset = calc_log2(block_size);
-  tag_offset = calc_log2(block_num) + index_offset;
-
-  debug("index_offset %d", index_offset);
-  debug("index_mask 0x%x", index_mask);
-  debug("tag_offset %d", tag_offset);
-
-  // regStats
-  cache_read_miss.name(level_string + string("_cache_read_miss"))
-                 .desc("cache read miss count")
-                 .precision(0)
-                 ;
-
-  cache_write_miss.name(level_string + string("_cache_write_miss"))
-                  .desc("cache write miss count")
-                  .precision(0)
-                  ;
-
-  cache_total_miss.name(level_string + string("_cache_total_miss"))
-                  .desc("cache total miss count")
-                  .precision(0)
-                  ;
-
-  cache_eviction.name(level_string + string("_cache_eviction"))
-                .desc("number of evict from this level to lower level")
-                .precision(0)
-                ;
-
-  cache_read_access.name(level_string + string("_cache_read_access"))
-                  .desc("cache read access count")
-                  .precision(0)
-                  ;
-
-  cache_write_access.name(level_string + string("_cache_write_access"))
-                    .desc("cache write access count")
-                    .precision(0)
-                    ;
-
-  cache_total_access.name(level_string + string("_cache_total_access"))
-                    .desc("cache total access count")
-                    .precision(0)
-                    ;
-
-  cache_mshr_hit.name(level_string + string("_cache_mshr_hit"))
-                .desc("cache mshr hit count")
-                .precision(0)
-                ;
-  cache_mshr_unavailable.name(level_string + string("_cache_mshr_unavailable"))
-                         .desc("cache mshr not available count")
-                         .precision(0)
-                         ;
-  cache_set_unavailable.name(level_string + string("_cache_set_unavailable"))
-                         .desc("cache set not available")
-                         .precision(0)
-                         ;
-}
-
-bool Cache::send(Request req) {
-  debug("level %d req.addr %lx req.type %d, index %d, tag %ld",
-      int(level), req.addr, int(req.type), get_index(req.addr),
-      get_tag(req.addr));
-
-  cache_total_access++;
-  if (req.type == Request::Type::WRITE) {
-    cache_write_access++;
-  } else {
-    assert(req.type == Request::Type::READ);
-    cache_read_access++;
-  }
-  // If there isn't a set, create it.
-  auto& lines = get_lines(req.addr);
-  std::list<Line>::iterator line;
-
-  if (is_hit(lines, req.addr, &line)) {
-    lines.push_back(Line(req.addr, get_tag(req.addr), false,
-        line->dirty || (req.type == Request::Type::WRITE)));
-    lines.erase(line);
-    cachesys->hit_list.push_back(
-        make_pair(cachesys->clk + latency[int(level)], req));
-
-    debug("hit, update timestamp %ld", cachesys->clk);
-    debug("hit finish time %ld",
-        cachesys->clk + latency[int(level)]);
-
-    return true;
-
-  } else {
-    debug("miss @level %d", int(level));
-    cache_total_miss++;
-    if (req.type == Request::Type::WRITE) {
-      cache_write_miss++;
-    } else {
-      assert(req.type == Request::Type::READ);
-      cache_read_miss++;
-    }
-
-    // The dirty bit will be set if this is a write request and @L1
-    bool dirty = (req.type == Request::Type::WRITE);
-
-    // Modify the type of the request to lower level
-    if (req.type == Request::Type::WRITE) {
-      req.type = Request::Type::READ;
-    }
-
-    // Look it up in MSHR entries
-    assert(req.type == Request::Type::READ);
-    auto mshr = hit_mshr(req.addr);
-    if (mshr != mshr_entries.end()) {
-      debug("hit mshr");
-      cache_mshr_hit++;
-      mshr->second->dirty = dirty || mshr->second->dirty;
-      return true;
-    }
-
-    // All requests come to this stage will be READ, so they
-    // should be recorded in MSHR entries.
-    if (mshr_entries.size() == mshr_entry_num) {
-      // When no MSHR entries available, the miss request
-      // is stalling.
-      cache_mshr_unavailable++;
-      debug("no mshr entry available");
-      return false;
-    }
-
-    // Check whether there is a line available
-    if (all_sets_locked(lines)) {
-      cache_set_unavailable++;
-      return false;
-    }
-
-    auto newline = allocate_line(lines, req.addr);
-    if (newline == lines.end()) {
-      return false;
-    }
-
-    newline->dirty = dirty;
-
-    // Add to MSHR entries
-    mshr_entries.push_back(make_pair(req.addr, newline));
-
-    // Send the request to next level;
-    if (!is_last_level) {
-      if(!lower_cache->send(req)) {
-        retry_list.push_back(req);
-      }
-    } else {
-      cachesys->wait_list.push_back(
-          make_pair(cachesys->clk + latency[int(level)], req));
-    }
-    return true;
-  }
-}
-
-void Cache::evictline(long addr, bool dirty) {
-
-  auto it = cache_lines.find(get_index(addr));
-  assert(it != cache_lines.end()); // check inclusive cache
-  auto& lines = it->second;
-  auto line = find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){return (l.tag == get_tag(addr));});
-
-  assert(line != lines.end());
-  // Update LRU queue. The dirty bit will be set if the dirty
-  // bit inherited from higher level(s) is set.
-  lines.push_back(Line(addr, get_tag(addr), false,
-      dirty || line->dirty));
-  lines.erase(line);
-}
-
-std::pair<long, bool> Cache::invalidate(long addr) {
-  long delay = latency_each[int(level)];
-  bool dirty = false;
-
-  auto& lines = get_lines(addr);
-  if (lines.size() == 0) {
-    // The line of this address doesn't exist.
-    return make_pair(0, false);
-  }
-  auto line = find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){return (l.tag == get_tag(addr));});
-
-  // If the line is in this level cache, then erase it from
-  // the buffer.
-  if (line != lines.end()) {
-    assert(!line->lock);
-    debug("invalidate %lx @ level %d", addr, int(level));
-    lines.erase(line);
-  } else {
-    // If it's not in current level, then no need to go up.
-    return make_pair(delay, false);
-  }
-
-  if (higher_cache.size()) {
-    long max_delay = delay;
-    for (auto hc : higher_cache) {
-      auto result = hc->invalidate(addr);
-      if (result.second) {
-        max_delay = max(max_delay, delay + result.first * 2);
-      } else {
-        max_delay = max(max_delay, delay + result.first);
-      }
-      dirty = dirty || line->dirty || result.second;
-    }
-    delay = max_delay;
-  } else {
-    dirty = line->dirty;
-  }
-  return make_pair(delay, dirty);
-}
-
-
-void Cache::evict(std::list<Line>* lines,
-    std::list<Line>::iterator victim) {
-  debug("level %d miss evict victim %lx", int(level), victim->addr);
-  cache_eviction++;
-
-  long addr = victim->addr;
-  long invalidate_time = 0;
-  bool dirty = victim->dirty;
-
-  // First invalidate the victim line in higher level.
-  if (higher_cache.size()) {
-    for (auto hc : higher_cache) {
-      auto result = hc->invalidate(addr);
-      invalidate_time = max(invalidate_time,
-          result.first + (result.second ? latency_each[int(level)] : 0));
-      dirty = dirty || result.second || victim->dirty;
-    }
-  }
-
-  debug("invalidate delay: %ld, dirty: %s", invalidate_time,
-      dirty ? "true" : "false");
-
-  if (!is_last_level) {
-    // not LLC eviction
-    assert(lower_cache != nullptr);
-    lower_cache->evictline(addr, dirty);
-  } else {
-    // LLC eviction
-    if (dirty) {
-      Request write_req(addr, Request::Type::WRITE);
-      cachesys->wait_list.push_back(make_pair(
-          cachesys->clk + invalidate_time + latency[int(level)],
-          write_req));
-
-      debug("inject one write request to memory system "
-          "addr %lx, invalidate time %ld, issue time %ld",
-          write_req.addr, invalidate_time,
-          cachesys->clk + invalidate_time + latency[int(level)]);
-    }
-  }
-
-  lines->erase(victim);
-}
-
-std::list<Cache::Line>::iterator Cache::allocate_line(
-    std::list<Line>& lines, long addr) {
-  // See if an eviction is needed
-  if (need_eviction(lines, addr)) {
-    // Get victim.
-    // The first one might still be locked due to reorder in MC
-    auto victim = find_if(lines.begin(), lines.end(),
-        [this](Line line) {
-          bool check = !line.lock;
-          if (!is_first_level) {
-            for (auto hc : higher_cache) {
-              if(!check) {
-                return check;
-              }
-              check = check && hc->check_unlock(line.addr);
-            }
-          }
-          return check;
-        });
-    if (victim == lines.end()) {
-      return victim;  // doesn't exist a line that's already unlocked in each level
-    }
-    assert(victim != lines.end());
-    evict(&lines, victim);
-  }
-
-  // Allocate newline, with lock bit on and dirty bit off
-  lines.push_back(Line(addr, get_tag(addr)));
-  auto last_element = lines.end();
-  --last_element;
-  return last_element;
-}
-
-bool Cache::is_hit(std::list<Line>& lines, long addr,
-    std::list<Line>::iterator* pos_ptr) {
-  auto pos = find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){return (l.tag == get_tag(addr));});
-  *pos_ptr = pos;
-  if (pos == lines.end()) {
-    return false;
-  }
-  return !pos->lock;
-}
-
-void Cache::concatlower(Cache* lower) {
-  lower_cache = lower;
-  assert(lower != nullptr);
-  lower->higher_cache.push_back(this);
-};
-
-bool Cache::need_eviction(const std::list<Line>& lines, long addr) {
-  if (find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){
-        return (get_tag(addr) == l.tag);})
-      != lines.end()) {
-    // Due to MSHR, the program can't reach here. Just for checking
-    assert(false);
-  } else {
-    if (lines.size() < assoc) {
-      return false;
-    } else {
-      return true;
-    }
-  }
-}
-
-void Cache::callback(Request& req) {
-  debug("level %d", int(level));
-
-  auto it = find_if(mshr_entries.begin(), mshr_entries.end(),
-      [&req, this](std::pair<long, std::list<Line>::iterator> mshr_entry) {
-        return (align(mshr_entry.first) == align(req.addr));
-      });
-
-  if (it != mshr_entries.end()) {
-    it->second->lock = false;
-    mshr_entries.erase(it);
-  }
-
-  if (higher_cache.size()) {
-    for (auto hc : higher_cache) {
-      hc->callback(req);
-    }
-  }
-}
-
-void Cache::tick() {
-
-    if(!lower_cache->is_last_level)
-        lower_cache->tick();
-
-    for (auto it = retry_list.begin(); it != retry_list.end(); it++) {
-        if(lower_cache->send(*it))
-            it = retry_list.erase(it);
-    }
-
-}
-
-void CacheSystem::tick() {
-  debug("clk %ld", clk);
-
-  ++clk;
-
-  // Sends ready waiting request to memory
-  auto it = wait_list.begin();
-  while (it != wait_list.end() && clk >= it->first) {
-    if (!send_memory(it->second)) {
-      ++it;
-    } else {
-
-      debug("complete req: addr %lx", (it->second).addr);
-
-      it = wait_list.erase(it);
-    }
-  }
-
-  // hit request callback
-  it = hit_list.begin();
-  while (it != hit_list.end()) {
-    if (clk >= it->first) {
-      it->second.callback(it->second);
-
-      debug("finish hit: addr %lx", (it->second).addr);
-
-      it = hit_list.erase(it);
-    } else {
-      ++it;
-    }
-  }
-}
-
-} // namespace ramulator
diff --git a/ext/ramulator/Ramulator/src/Cache.h b/ext/ramulator/Ramulator/src/Cache.h
deleted file mode 100644
index b9869c7e4..000000000
--- a/ext/ramulator/Ramulator/src/Cache.h
+++ /dev/null
@@ -1,242 +0,0 @@
-#ifndef __CACHE_H
-#define __CACHE_H
-
-#include "Config.h"
-#include "Request.h"
-#include "Statistics.h"
-#include <algorithm>
-#include <cstdio>
-#include <cassert>
-#include <functional>
-#include <list>
-#include <map>
-#include <memory>
-#include <queue>
-#include <list>
-
-namespace ramulator
-{
-class CacheSystem;
-
-class Cache {
-protected:
-  ScalarStat cache_read_miss;
-  ScalarStat cache_write_miss;
-  ScalarStat cache_total_miss;
-  ScalarStat cache_eviction;
-  ScalarStat cache_read_access;
-  ScalarStat cache_write_access;
-  ScalarStat cache_total_access;
-  ScalarStat cache_mshr_hit;
-  ScalarStat cache_mshr_unavailable;
-  ScalarStat cache_set_unavailable;
-public:
-  enum class Level {
-    L1,
-    L2,
-    L3,
-    MAX
-  } level;
-  std::string level_string;
-
-  struct Line {
-    long addr;
-    long tag;
-    bool lock; // When the lock is on, the value is not valid yet.
-    bool dirty;
-    Line(long addr, long tag):
-        addr(addr), tag(tag), lock(true), dirty(false) {}
-    Line(long addr, long tag, bool lock, bool dirty):
-        addr(addr), tag(tag), lock(lock), dirty(dirty) {}
-  };
-
-  Cache(int size, int assoc, int block_size, int mshr_entry_num,
-      Level level, std::shared_ptr<CacheSystem> cachesys);
-
-  void tick();
-
-  // L1, L2, L3 accumulated latencies
-  int latency[int(Level::MAX)] = {4, 4 + 12, 4 + 12 + 31};
-  int latency_each[int(Level::MAX)] = {4, 12, 31};
-
-  std::shared_ptr<CacheSystem> cachesys;
-  // LLC has multiple higher caches
-  std::vector<Cache*> higher_cache;
-  Cache* lower_cache;
-
-  bool send(Request req);
-
-  void concatlower(Cache* lower);
-
-  void callback(Request& req);
-
-protected:
-
-  bool is_first_level;
-  bool is_last_level;
-  size_t size;
-  unsigned int assoc;
-  unsigned int block_num;
-  unsigned int index_mask;
-  unsigned int block_size;
-  unsigned int index_offset;
-  unsigned int tag_offset;
-  unsigned int mshr_entry_num;
-  std::vector<std::pair<long, std::list<Line>::iterator>> mshr_entries;
-  std::list<Request> retry_list;
-
-  std::map<int, std::list<Line> > cache_lines;
-
-  int calc_log2(int val) {
-      int n = 0;
-      while ((val >>= 1))
-          n ++;
-      return n;
-  }
-
-  int get_index(long addr) {
-    return (addr >> index_offset) & index_mask;
-  };
-
-  long get_tag(long addr) {
-    return (addr >> tag_offset);
-  }
-
-  // Align the address to cache line size
-  long align(long addr) {
-    return (addr & ~(block_size-1l));
-  }
-
-  // Evict the cache line from higher level to this level.
-  // Pass the dirty bit and update LRU queue.
-  void evictline(long addr, bool dirty);
-
-  // Invalidate the line from this level to higher levels
-  // The return value is a pair. The first element is invalidation
-  // latency, and the second is wether the value has new version
-  // in higher level and this level.
-  std::pair<long, bool> invalidate(long addr);
-
-  // Evict the victim from current set of lines.
-  // First do invalidation, then call evictline(L1 or L2) or send
-  // a write request to memory(L3) when dirty bit is on.
-  void evict(std::list<Line>* lines,
-      std::list<Line>::iterator victim);
-
-  // First test whether need eviction, if so, do eviction by
-  // calling evict function. Then allocate a new line and return
-  // the iterator points to it.
-  std::list<Line>::iterator allocate_line(
-      std::list<Line>& lines, long addr);
-
-  // Check whether the set to hold addr has space or eviction is
-  // needed.
-  bool need_eviction(const std::list<Line>& lines, long addr);
-
-  // Check whether this addr is hit and fill in the pos_ptr with
-  // the iterator to the hit line or lines.end()
-  bool is_hit(std::list<Line>& lines, long addr,
-              std::list<Line>::iterator* pos_ptr);
-
-  bool all_sets_locked(const std::list<Line>& lines) {
-    if (lines.size() < assoc) {
-      return false;
-    }
-    for (const auto& line : lines) {
-      if (!line.lock) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  bool check_unlock(long addr) {
-    auto it = cache_lines.find(get_index(addr));
-    if (it == cache_lines.end()) {
-      return true;
-    } else {
-      auto& lines = it->second;
-      auto line = find_if(lines.begin(), lines.end(),
-          [addr, this](Line l){return (l.tag == get_tag(addr));});
-      if (line == lines.end()) {
-        return true;
-      } else {
-        bool check = !line->lock;
-        if (!is_first_level) {
-          for (auto hc : higher_cache) {
-            if (!check) {
-              return check;
-            }
-            check = check && hc->check_unlock(line->addr);
-          }
-        }
-        return check;
-      }
-    }
-  }
-
-  std::vector<std::pair<long, std::list<Line>::iterator>>::iterator
-  hit_mshr(long addr) {
-    auto mshr_it =
-        find_if(mshr_entries.begin(), mshr_entries.end(),
-            [addr, this](std::pair<long, std::list<Line>::iterator>
-                   mshr_entry) {
-              return (align(mshr_entry.first) == align(addr));
-            });
-    return mshr_it;
-  }
-
-  std::list<Line>& get_lines(long addr) {
-    if (cache_lines.find(get_index(addr))
-        == cache_lines.end()) {
-      cache_lines.insert(make_pair(get_index(addr),
-          std::list<Line>()));
-    }
-    return cache_lines[get_index(addr)];
-  }
-
-};
-
-class CacheSystem {
-public:
-  CacheSystem(const Config& configs, std::function<bool(Request)> send_memory):
-    send_memory(send_memory) {
-      if (configs.has_core_caches()) {
-        first_level = Cache::Level::L1;
-      } else if (configs.has_l3_cache()) {
-        first_level = Cache::Level::L3;
-      } else {
-        last_level = Cache::Level::MAX; // no cache
-      }
-
-      if (configs.has_l3_cache()) {
-        last_level = Cache::Level::L3;
-      } else if (configs.has_core_caches()) {
-        last_level = Cache::Level::L2;
-      } else {
-        last_level = Cache::Level::MAX; // no cache
-      }
-    }
-
-  // wait_list contains miss requests with their latencies in
-  // cache. When this latency is met, the send_memory function
-  // will be called to send the request to the memory system.
-  std::list<std::pair<long, Request> > wait_list;
-
-  // hit_list contains hit requests with their latencies in cache.
-  // callback function will be called when this latency is met and
-  // set the instruction status to ready in processor's window.
-  std::list<std::pair<long, Request> > hit_list;
-
-  std::function<bool(Request)> send_memory;
-
-  long clk = 0;
-  void tick();
-
-  Cache::Level first_level;
-  Cache::Level last_level;
-};
-
-} // namespace ramulator
-
-#endif /* __CACHE_H */
diff --git a/ext/ramulator/Ramulator/src/Config.cpp b/ext/ramulator/Ramulator/src/Config.cpp
deleted file mode 100644
index b3a4658bb..000000000
--- a/ext/ramulator/Ramulator/src/Config.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-#include "Config.h"
-
-using namespace std;
-using namespace ramulator;
-
-Config::Config(const std::string& fname) {
-  parse(fname);
-}
-
-void Config::parse(const string& fname)
-{
-    ifstream file(fname);
-    assert(file.good() && "Bad config file");
-    string line;
-
-    while (getline(file, line)) {
-        char delim[] = " \t=";
-        vector<string> tokens;
-
-        while (true) {
-            size_t start = line.find_first_not_of(delim);
-            if (start == string::npos) 
-                break;
-
-            size_t end = line.find_first_of(delim, start);
-            if (end == string::npos) {
-                tokens.push_back(line.substr(start));
-                break;
-            }
-
-            tokens.push_back(line.substr(start, end - start));
-            line = line.substr(end);
-        }
-
-        // empty line
-        if (!tokens.size())
-            continue;
-
-        // comment line
-        if (tokens[0][0] == '#')
-            continue;
-
-        // parameter line
-        assert(tokens.size() == 2 && "Only allow two tokens in one line");
-
-        options[tokens[0]] = tokens[1];
-
-        if (tokens[0] == "channels") {
-          channels = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "ranks") {
-          ranks = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "subarrays") {
-          subarrays = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "cpu_tick") {
-          cpu_tick = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "mem_tick") {
-          mem_tick = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "expected_limit_insts") {
-          expected_limit_insts = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "warmup_insts") {
-          warmup_insts = atoi(tokens[1].c_str());
-        }
-    }
-    file.close();
-}
-
-
diff --git a/ext/ramulator/Ramulator/src/Config.h b/ext/ramulator/Ramulator/src/Config.h
deleted file mode 100644
index aef68dc70..000000000
--- a/ext/ramulator/Ramulator/src/Config.h
+++ /dev/null
@@ -1,126 +0,0 @@
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <string>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <iostream>
-#include <cassert>
-
-namespace ramulator
-{
-
-class Config {
-
-private:
-    std::map<std::string, std::string> options;
-    int channels;
-    int ranks;
-    int subarrays;
-    int cpu_tick;
-    int mem_tick;
-    int core_num = 0;
-    long expected_limit_insts = 0;
-    long warmup_insts = 0;
-    std::string tracefile_directory;
-
-public:
-    Config() {}
-    Config(const std::string& fname);
-    void parse(const std::string& fname);
-    std::string operator [] (const std::string& name) const {
-      if (options.find(name) != options.end()) {
-        return (options.find(name))->second;
-      } else {
-        return "";
-      }
-    }
-
-    bool contains(const std::string& name) const {
-      if (options.find(name) != options.end()) {
-        return true;
-      } else {
-        return false;
-      }
-    }
-
-    void add (const std::string& name, const std::string& value) {
-      if (!contains(name)) {
-        options.insert(make_pair(name, value));
-      } else {
-        printf("ramulator::Config::add options[%s] already set.\n", name.c_str());
-      }
-    }
-
-    std::string get_tracefile_directory() const { return tracefile_directory; }
-    void set_tracefile_directory(std::string directory) { tracefile_directory = directory; }
-    
-
-    void set_core_num(int _core_num) {core_num = _core_num;}
-
-    int get_channels() const {return channels;}
-    int get_subarrays() const {return subarrays;}
-    int get_ranks() const {return ranks;}
-    int get_cpu_tick() const {return cpu_tick;}
-    int get_mem_tick() const {return mem_tick;}
-    int get_core_num() const {return core_num;}
-    long get_expected_limit_insts() const {return expected_limit_insts;}
-    long get_warmup_insts() const {return warmup_insts;}
-
-    bool has_l3_cache() const {
-      if (options.find("cache") != options.end()) {
-        const std::string& cache_option = (options.find("cache"))->second;
-        return (cache_option == "all") || (cache_option == "L3");
-      } else {
-        return false;
-      }
-    }
-    bool has_core_caches() const {
-      if (options.find("cache") != options.end()) {
-        const std::string& cache_option = (options.find("cache"))->second;
-        return (cache_option == "all" || cache_option == "L1L2");
-      } else {
-        return false;
-      }
-    }
-    bool is_early_exit() const {
-      // the default value is true
-      if (options.find("early_exit") != options.end()) {
-        if ((options.find("early_exit"))->second == "off") {
-          return false;
-        }
-        return true;
-      }
-      return true;
-    }
-    bool calc_weighted_speedup() const {
-      return (expected_limit_insts != 0);
-    }
-    bool record_cmd_trace() const {
-      // the default value is false
-      if (options.find("record_cmd_trace") != options.end()) {
-        if ((options.find("record_cmd_trace"))->second == "on") {
-          return true;
-        }
-        return false;
-      }
-      return false;
-    }
-    bool print_cmd_trace() const {
-      // the default value is false
-      if (options.find("print_cmd_trace") != options.end()) {
-        if ((options.find("print_cmd_trace"))->second == "on") {
-          return true;
-        }
-        return false;
-      }
-      return false;
-    }
-};
-
-
-} /* namespace ramulator */
-
-#endif /* _CONFIG_H */
-
diff --git a/ext/ramulator/Ramulator/src/Controller.cpp b/ext/ramulator/Ramulator/src/Controller.cpp
deleted file mode 100644
index af2e9db13..000000000
--- a/ext/ramulator/Ramulator/src/Controller.cpp
+++ /dev/null
@@ -1,204 +0,0 @@
-#include "Controller.h"
-#include "SALP.h"
-#include "ALDRAM.h"
-#include "TLDRAM.h"
-
-using namespace ramulator;
-
-namespace ramulator
-{
-
-static vector<int> get_offending_subarray(DRAM<SALP>* channel, vector<int> & addr_vec){
-    int sa_id = 0;
-    auto rank = channel->children[addr_vec[int(SALP::Level::Rank)]];
-    auto bank = rank->children[addr_vec[int(SALP::Level::Bank)]];
-    auto sa = bank->children[addr_vec[int(SALP::Level::SubArray)]];
-    for (auto sa_other : bank->children)
-        if (sa != sa_other && sa_other->state == SALP::State::Opened){
-            sa_id = sa_other->id;
-            break;
-        }
-    vector<int> offending = addr_vec;
-    offending[int(SALP::Level::SubArray)] = sa_id;
-    offending[int(SALP::Level::Row)] = -1;
-    return offending;
-}
-
-
-template <>
-vector<int> Controller<SALP>::get_addr_vec(SALP::Command cmd, list<Request>::iterator req){
-    if (cmd == SALP::Command::PRE_OTHER)
-        return get_offending_subarray(channel, req->addr_vec);
-    else
-        return req->addr_vec;
-}
-
-
-template <>
-bool Controller<SALP>::is_ready(list<Request>::iterator req){
-    SALP::Command cmd = get_first_cmd(req);
-    if (cmd == SALP::Command::PRE_OTHER){
-
-        vector<int> addr_vec = get_offending_subarray(channel, req->addr_vec);
-        return channel->check(cmd, addr_vec.data(), clk);
-    }
-    else return channel->check(cmd, req->addr_vec.data(), clk);
-}
-
-template <>
-void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature){
-    channel->spec->aldram_timing(current_temperature);
-}
-
-
-template <>
-void Controller<TLDRAM>::tick(){
-    clk++;
-    req_queue_length_sum += readq.size() + writeq.size();
-    read_req_queue_length_sum += readq.size();
-    write_req_queue_length_sum += writeq.size();
-
-    /*** 1. Serve completed reads ***/
-    if (pending.size()) {
-        Request& req = pending[0];
-        if (req.depart <= clk) {
-          if (req.depart - req.arrive > 1) {
-                  read_latency_sum += req.depart - req.arrive;
-		  // gagan : demand and prefetch reads
-		  if(req.is_prefetch)
-		    prefetch_read_latency_sum += req.depart - req.arrive;
-		  else
-		    demand_read_latency_sum += req.depart - req.arrive;
-                  channel->update_serving_requests(
-                      req.addr_vec.data(), -1, clk);
-          }
-            req.callback(req);
-            pending.pop_front();
-        }
-    }
-
-    /*** 2. Should we schedule refreshes? ***/
-    refresh->tick_ref();
-
-    /*** 3. Should we schedule writes? ***/
-    if (!write_mode) {
-        // yes -- write queue is almost full or read queue is empty
-        if (writeq.size() >= int(0.8 * writeq.max) /*|| readq.size() == 0*/)
-            write_mode = true;
-    }
-    else {
-        // no -- write queue is almost empty and read queue is not empty
-        if (writeq.size() <= int(0.2 * writeq.max) && readq.size() != 0)
-            write_mode = false;
-    }
-
-    /*** 4. Find the best command to schedule, if any ***/
-    Queue* queue = !write_mode ? &readq : &writeq;
-    if (otherq.size())
-        queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-
-    auto req = scheduler->get_head(queue->q);
-    if (req == queue->q.end() || !is_ready(req)) {
-        // we couldn't find a command to schedule -- let's try to be speculative
-        auto cmd = TLDRAM::Command::PRE;
-        vector<int> victim = rowpolicy->get_victim(cmd);
-        if (!victim.empty()){
-            issue_cmd(cmd, victim);
-        }
-        return;  // nothing more to be done this cycle
-    }
-
-    if (req->is_first_command) {
-        int coreid = req->coreid;
-        req->is_first_command = false;
-        if (req->type == Request::Type::READ || req->type == Request::Type::WRITE) {
-          channel->update_serving_requests(req->addr_vec.data(), 1, clk);
-        }
-        int tx = (channel->spec->prefetch_size * channel->spec->channel_width / 8);
-        if (req->type == Request::Type::READ) {
-            if (is_row_hit(req)) {
-                ++read_row_hits[coreid];
-                ++row_hits;
-                // daz3
-                period_read_row_hits++;
-            } else if (is_row_open(req)) {
-                ++read_row_conflicts[coreid];
-                ++row_conflicts;
-                // daz3
-                period_read_row_conflicts++;
-            } else {
-                ++read_row_misses[coreid];
-                ++row_misses;
-                // daz3
-                period_read_row_misses++;
-            }
-            read_transaction_bytes += tx;
-        } else if (req->type == Request::Type::WRITE) {
-            if (is_row_hit(req)) {
-                ++write_row_hits[coreid];
-                ++row_hits;
-                // daz3
-                period_write_row_hits++;
-            } else if (is_row_open(req)) {
-                ++write_row_conflicts[coreid];
-                ++row_conflicts;
-                // daz3
-                period_write_row_conflicts++;
-            } else {
-                ++write_row_misses[coreid];
-                ++row_misses;
-                // daz3
-                period_write_row_misses++;
-            }
-          write_transaction_bytes += tx;
-        }
-    }
-
-    /*** 5. Change a read request to a migration request ***/
-    if (req->type == Request::Type::READ) {
-        req->type = Request::Type::EXTENSION;
-    }
-
-    // issue command on behalf of request
-    auto cmd = get_first_cmd(req);
-    issue_cmd(cmd, get_addr_vec(cmd, req));
-
-    // check whether this is the last command (which finishes the request)
-    if (cmd != channel->spec->translate[int(req->type)])
-        return;
-
-    // set a future completion time for read requests
-    if (req->type == Request::Type::READ || req->type == Request::Type::EXTENSION) {
-        req->depart = clk + channel->spec->read_latency;
-        pending.push_back(*req);
-    }
-    if (req->type == Request::Type::WRITE) {
-        channel->update_serving_requests(req->addr_vec.data(), -1, clk);
-    }
-
-    // remove request from queue
-    queue->q.erase(req);
-
-    // daz3
-    if(clk % my_print_intelval == 0)
-    {
-        std::cout << "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv" << std::endl;
-        std::cout << "clk " << clk << std::endl;
-        std::cout << "period_read_row_hits " << period_read_row_hits << std::endl;
-        std::cout << "period_read_row_misses " << period_read_row_misses << std::endl;
-        std::cout << "period_read_row_conflicts " << period_read_row_conflicts << std::endl;
-        std::cout << "period_write_row_hits " << period_write_row_hits << std::endl;
-        std::cout << "period_write_row_misses " << period_write_row_misses << std::endl;
-        std::cout << "period_write_row_conflicts " << period_write_row_conflicts << std::endl;
-        std::cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" << std::endl;
-    }
-}
-
-template<>
-void Controller<TLDRAM>::cmd_issue_autoprecharge(typename TLDRAM::Command& cmd,
-                                                    const vector<int>& addr_vec) {
-    //TLDRAM currently does not have autoprecharge commands
-    return;
-}
-
-} /* namespace ramulator */
diff --git a/ext/ramulator/Ramulator/src/Controller.h b/ext/ramulator/Ramulator/src/Controller.h
deleted file mode 100644
index 8a30e9d85..000000000
--- a/ext/ramulator/Ramulator/src/Controller.h
+++ /dev/null
@@ -1,902 +0,0 @@
-#ifndef __CONTROLLER_H
-#define __CONTROLLER_H
-
-#include <cassert>
-#include <cstdio>
-#include <deque>
-#include <fstream>
-#include <list>
-#include <string>
-#include <vector>
-#include <queue>
-
-#include "Config.h"
-#include "DRAM.h"
-#include "Refresh.h"
-#include "Request.h"
-#include "Scheduler.h"
-#include "Statistics.h"
-
-#include "ALDRAM.h"
-#include "SALP.h"
-#include "TLDRAM.h"
-#include "DDR4.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-    extern bool warmup_complete;
-
-template <typename T>
-class Controller
-{
-protected:
-    // For counting bandwidth
-    ScalarStat read_transaction_bytes;
-    ScalarStat write_transaction_bytes;
-
-    ScalarStat row_hits;
-    ScalarStat row_misses;
-    ScalarStat row_conflicts;
-    VectorStat read_row_hits;
-    VectorStat read_row_misses;
-    VectorStat read_row_conflicts;
-    VectorStat write_row_hits;
-    VectorStat write_row_misses;
-    VectorStat write_row_conflicts;
-    ScalarStat useless_activates;
-
-    ScalarStat read_latency_avg;
-    ScalarStat read_latency_sum;
-    // gagan : demand requests and prefetch requests
-    ScalarStat demand_read_latency_avg;
-    ScalarStat demand_read_latency_sum;
-    ScalarStat prefetch_read_latency_avg;
-    ScalarStat prefetch_read_latency_sum;
-
-    ScalarStat req_queue_length_avg;
-    ScalarStat req_queue_length_sum;
-    ScalarStat read_req_queue_length_avg;
-    ScalarStat read_req_queue_length_sum;
-    ScalarStat write_req_queue_length_avg;
-    ScalarStat write_req_queue_length_sum;
-
-#ifndef INTEGRATED_WITH_GEM5
-    VectorStat record_read_hits;
-    VectorStat record_read_misses;
-    VectorStat record_read_conflicts;
-    VectorStat record_write_hits;
-    VectorStat record_write_misses;
-    VectorStat record_write_conflicts;
-#endif
-
-public:
-    /* Member Variables */
-    long clk = 0;
-    DRAM<T>* channel;
-
-    // gagan : enable_debug
-    bool enable_debug;
-
-    // daz3
-    long period_read_row_hits;
-    long period_read_row_misses;
-    long period_read_row_conflicts;
-    long period_write_row_hits;
-    long period_write_row_misses;
-    long period_write_row_conflicts;
-    long my_print_intelval = 200000000; //every 0.2ms
-
-    Scheduler<T>* scheduler;  // determines the highest priority request whose commands will be issued
-    RowPolicy<T>* rowpolicy;  // determines the row-policy (e.g., closed-row vs. open-row)
-    RowTable<T>* rowtable;  // tracks metadata about rows (e.g., which are open and for how long)
-    Refresh<T>* refresh;
-
-    struct Queue {
-        list<Request> q;
-        unsigned int max = 32;
-        // daz3: test tWTR
-        // unsigned int max = 16;
-        unsigned int size() { return q.size(); }
-      void print()
-      {
-	//std::cout << "Printing queue: " << std::endl;
-	for(auto &i : q)
-	  {
-	    i.print();
-	  }
-      }
-
-      bool hasRequestType(Request::Type type)
-      {
-	for(auto &r : q)
-	  {
-	    if(r.type == type)
-	      return true;
-	  }
-	return false;
-      }
-    };
-
-    Queue readq;  // queue for read requests
-    Queue writeq;  // queue for write requests
-    Queue actq; // read and write requests for which activate was issued are moved to 
-                   // actq, which has higher priority than readq and writeq.
-                   // This is an optimization
-                   // for avoiding useless activations (i.e., PRECHARGE
-                   // after ACTIVATE w/o READ of WRITE command)
-    Queue otherq;  // queue for all "other" requests (e.g., refresh)
-
-    deque<Request> pending;  // read requests that are about to receive data from DRAM
-    bool write_mode = false;  // whether write requests should be prioritized over reads
-    float wr_high_watermark = 0.8f; // threshold for switching to write mode
-    float wr_low_watermark = 0.2f; // threshold for switching back to read mode
-    //long refreshed = 0;  // last time refresh requests were generated
-
-    /* Command trace for DRAMPower 3.1 */
-    string cmd_trace_prefix = "cmd-trace-";
-    vector<ofstream> cmd_trace_files;
-    bool record_cmd_trace = false;
-    /* Commands to stdout */
-    bool print_cmd_trace = false;
-
-    /* Constructor */
-    Controller(const Config& configs, DRAM<T>* channel, bool enable_debug) :
-        enable_debug(enable_debug),
-        channel(channel),
-        scheduler(new Scheduler<T>(this)),
-        rowpolicy(new RowPolicy<T>(this)),
-        rowtable(new RowTable<T>(this)),
-        refresh(new Refresh<T>(this)),
-        cmd_trace_files(channel->children.size())
-    {
-        // daz3: set read/write queue
-        // readq.max = 128;
-        readq.max = 512;
-        writeq.max = 128;
-        // writeq.max = 256;
-        std::cout << "Controller readq " << readq.max << ", writeq " << writeq.max << std::endl;
-
-        record_cmd_trace = configs.record_cmd_trace();
-        print_cmd_trace = configs.print_cmd_trace();
-        if (record_cmd_trace){
-            if (configs["cmd_trace_prefix"] != "") {
-              cmd_trace_prefix = configs["cmd_trace_prefix"];
-            }
-	    std::string traceDir = configs.get_tracefile_directory();
-            string prefix = traceDir + cmd_trace_prefix + "chan-" + to_string(channel->id) + "-rank-";
-            string suffix = ".cmdtrace";
-            for (unsigned int i = 0; i < channel->children.size(); i++)
-                cmd_trace_files[i].open(prefix + to_string(i) + suffix);
-        }
-
-        // daz3
-        period_read_row_hits = 0;
-        period_read_row_misses = 0;
-        period_read_row_conflicts = 0;
-        period_write_row_hits = 0;
-        period_write_row_misses = 0;
-        period_write_row_conflicts = 0;
-
-        // regStats
-
-        row_hits
-            .name("row_hits_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row hits per channel per core")
-            .precision(0)
-            ;
-        row_misses
-            .name("row_misses_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row misses per channel per core")
-            .precision(0)
-            ;
-        row_conflicts
-            .name("row_conflicts_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row conflicts per channel per core")
-            .precision(0)
-            ;
-
-        read_row_hits
-            .init(configs.get_core_num())
-            .name("read_row_hits_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row hits for read requests per channel per core")
-            .precision(0)
-            ;
-        read_row_misses
-            .init(configs.get_core_num())
-            .name("read_row_misses_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row misses for read requests per channel per core")
-            .precision(0)
-            ;
-        read_row_conflicts
-            .init(configs.get_core_num())
-            .name("read_row_conflicts_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row conflicts for read requests per channel per core")
-            .precision(0)
-            ;
-
-        write_row_hits
-            .init(configs.get_core_num())
-            .name("write_row_hits_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row hits for write requests per channel per core")
-            .precision(0)
-            ;
-        write_row_misses
-            .init(configs.get_core_num())
-            .name("write_row_misses_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row misses for write requests per channel per core")
-            .precision(0)
-            ;
-        write_row_conflicts
-            .init(configs.get_core_num())
-            .name("write_row_conflicts_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row conflicts for write requests per channel per core")
-            .precision(0)
-            ;
-
-        useless_activates
-            .name("useless_activates_"+to_string(channel->id)+ "_core")
-            .desc("Number of useless activations. E.g, ACT -> PRE w/o RD or WR")
-            .precision(0)
-            ;
-
-        read_transaction_bytes
-            .name("read_transaction_bytes_"+to_string(channel->id))
-            .desc("The total byte of read transaction per channel")
-            .precision(0)
-            ;
-        write_transaction_bytes
-            .name("write_transaction_bytes_"+to_string(channel->id))
-            .desc("The total byte of write transaction per channel")
-            .precision(0)
-            ;
-
-        read_latency_sum
-            .name("read_latency_sum_"+to_string(channel->id))
-            .desc("The memory latency cycles (in memory time domain) sum for all read requests in this channel")
-            .precision(0)
-            ;
-        read_latency_avg
-            .name("read_latency_avg_"+to_string(channel->id))
-            .desc("The average memory latency cycles (in memory time domain) per request for all read requests in this channel")
-            .precision(6)
-            ;
-	// gagan : demand and prefetch read requests
-        demand_read_latency_sum
-            .name("demand_read_latency_sum_"+to_string(channel->id))
-            .desc("The memory latency cycles (in memory time domain) sum for demand read requests in this channel")
-            .precision(0)
-            ;
-        demand_read_latency_avg
-            .name("demand_read_latency_avg_"+to_string(channel->id))
-            .desc("The average memory latency cycles (in memory time domain) per request for demand read requests in this channel")
-            .precision(6)
-            ;
-	prefetch_read_latency_sum
-            .name("prefetch_read_latency_sum_"+to_string(channel->id))
-            .desc("The memory latency cycles (in memory time domain) sum for prefetch read requests in this channel")
-            .precision(0)
-            ;
-        prefetch_read_latency_avg
-            .name("prefetch_read_latency_avg_"+to_string(channel->id))
-            .desc("The average memory latency cycles (in memory time domain) per request for prefetch read requests in this channel")
-            .precision(6)
-            ;
-        req_queue_length_sum
-            .name("req_queue_length_sum_"+to_string(channel->id))
-            .desc("Sum of read and write queue length per memory cycle per channel.")
-            .precision(0)
-            ;
-        req_queue_length_avg
-            .name("req_queue_length_avg_"+to_string(channel->id))
-            .desc("Average of read and write queue length per memory cycle per channel.")
-            .precision(6)
-            ;
-
-        read_req_queue_length_sum
-            .name("read_req_queue_length_sum_"+to_string(channel->id))
-            .desc("Read queue length sum per memory cycle per channel.")
-            .precision(0)
-            ;
-        read_req_queue_length_avg
-            .name("read_req_queue_length_avg_"+to_string(channel->id))
-            .desc("Read queue length average per memory cycle per channel.")
-            .precision(6)
-            ;
-
-        write_req_queue_length_sum
-            .name("write_req_queue_length_sum_"+to_string(channel->id))
-            .desc("Write queue length sum per memory cycle per channel.")
-            .precision(0)
-            ;
-        write_req_queue_length_avg
-            .name("write_req_queue_length_avg_"+to_string(channel->id))
-            .desc("Write queue length average per memory cycle per channel.")
-            .precision(6)
-            ;
-
-#ifndef INTEGRATED_WITH_GEM5
-        record_read_hits
-            .init(configs.get_core_num())
-            .name("record_read_hits")
-            .desc("record read hit count for this core when it reaches request limit or to the end")
-            ;
-
-        record_read_misses
-            .init(configs.get_core_num())
-            .name("record_read_misses")
-            .desc("record_read_miss count for this core when it reaches request limit or to the end")
-            ;
-
-        record_read_conflicts
-            .init(configs.get_core_num())
-            .name("record_read_conflicts")
-            .desc("record read conflict count for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_hits
-            .init(configs.get_core_num())
-            .name("record_write_hits")
-            .desc("record write hit count for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_misses
-            .init(configs.get_core_num())
-            .name("record_write_misses")
-            .desc("record write miss count for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_conflicts
-            .init(configs.get_core_num())
-            .name("record_write_conflicts")
-            .desc("record write conflict for this core when it reaches request limit or to the end")
-            ;
-#endif
-    }
-
-    ~Controller(){
-        delete scheduler;
-        delete rowpolicy;
-        delete rowtable;
-        delete channel;
-        delete refresh;
-        for (auto& file : cmd_trace_files)
-            file.close();
-        cmd_trace_files.clear();
-    }
-
-    void finish(long read_req, long demand_read_req, long prefetch_read_req,long dram_cycles) {
-      read_latency_avg = read_latency_sum.value() / read_req;
-      req_queue_length_avg = req_queue_length_sum.value() / dram_cycles;
-      read_req_queue_length_avg = read_req_queue_length_sum.value() / dram_cycles;
-      write_req_queue_length_avg = write_req_queue_length_sum.value() / dram_cycles;
-      // gagan : demand and prefetch reads
-      demand_read_latency_avg = demand_read_latency_sum.value() / demand_read_req;
-      prefetch_read_latency_avg = prefetch_read_latency_sum.value() / prefetch_read_req;
-      // call finish function of each channel
-      channel->finish(dram_cycles);
-    }
-
-    /* Member Functions */
-    Queue& get_queue(Request::Type type)
-    {
-        switch (int(type)) {
-            case int(Request::Type::READ): return readq;
-            case int(Request::Type::WRITE): return writeq;
-            default: return otherq;
-        }
-    }
-
-    // gagan :
-    bool promote(Request& req)
-    {
-      assert(req.type == Request::Type::READ);
-      // promote : actq
-      for(auto &r : actq.q)
-	{
-	  if(r.addr == req.addr && r.type == Request::Type::READ)
-	    {
-	      assert(r.is_prefetch == true);
-	      r.is_prefetch = false;
-	      r.arrive = clk;
-	    }
-	}
-
-      for(auto &r : readq.q)
-	{
-	  if(r.addr == req.addr)
-	    {
-	      assert(r.is_prefetch == true);
-	      r.arrive = clk;
-	      r.is_prefetch = false;
-	    }
-	}
-
-      return true;
-    }
-    
-    bool enqueue(Request& req)
-    {
-        Queue& queue = get_queue(req.type);
-        if (queue.max == queue.size())
-            return false;
-
-        req.arrive = clk;
-        queue.q.push_back(req);
-        // shortcut for read requests, if a write to same addr exists
-        // necessary for coherence
-        if (req.type == Request::Type::READ && find_if(writeq.q.begin(), writeq.q.end(),
-                [req](Request& wreq){ return req.addr == wreq.addr;}) != writeq.q.end()){
-            req.depart = clk + 1;
-            pending.push_back(req);
-            readq.q.pop_back();
-        }
-        return true;
-    }
-
-    void tick()
-    {
-        clk++;
-        req_queue_length_sum += readq.size() + writeq.size() + pending.size();
-        read_req_queue_length_sum += readq.size() + pending.size();
-        write_req_queue_length_sum += writeq.size();
-
-        /*** 1. Serve completed reads ***/
-        if (pending.size()) {
-            Request& req = pending[0];
-            if (req.depart <= clk) {
-                if (req.depart - req.arrive > 1) { // this request really accessed a row
-                  read_latency_sum += req.depart - req.arrive;
-		  // gagan : demand and prefetch reads
-		  if(req.is_prefetch)
-		      prefetch_read_latency_sum += req.depart - req.arrive;
-		  else
-		      demand_read_latency_sum += req.depart - req.arrive;
-                  channel->update_serving_requests(
-                      req.addr_vec.data(), -1, clk);
-                }
-                req.callback(req);
-                pending.pop_front();
-            }
-        }
-
-        /*** 2. Refresh scheduler ***/
-        refresh->tick_ref();
-
-        /*** 3. Should we schedule writes? ***/
-        if (!write_mode)
-	  {
-            // yes -- write queue is almost full or read queue is empty
-            if (writeq.size() > int(wr_high_watermark * writeq.max) 
-                    /*|| readq.size() == 0*/) // Hasan: Switching to write mode when there are just a few 
-                                              // write requests, even if the read queue is empty, incurs a lot of overhead. 
-                                              // Commented out the read request queue empty condition
-	      write_mode = true;
-        }
-        else {
-            // no -- write queue is almost empty and read queue is not empty
-            if (writeq.size() < int(wr_low_watermark * writeq.max) && readq.size() != 0)
-	      write_mode = false;
-        }
-
-        /*** 4. Find the best command to schedule, if any ***/
-
-        // First check the actq (which has higher priority) to see if there
-        // are requests available to service in this cycle
-        Queue* queue = &actq;
-
-	if(enable_debug)
-	  {
-	    std::cout << "<------------------------------------------->" << std::endl;
-	    std::cout << "Clk: " << clk << std::endl;
-	    std::cout << "Channel: " << channel->id << std::endl;
-	    if(actq.q.size() != 0)
-	      {
-		std::cout << "Activation Queue: " << std::endl;
-		actq.print();
-	      }
-	    if(readq.q.size() != 0)
-	      {
-		std::cout << "Read Queue: " << std::endl;
-		readq.print();
-	      }
-	    if(writeq.q.size() != 0)
-	      {
-		std::cout << "Write Queue: " << std::endl;
-		writeq.print();
-	      }
-	    if(otherq.q.size() != 0)
-	      {
-		std::cout << "Other Queue: " << std::endl;
-		otherq.print();
-	      }
-	    rowtable->print();
-	    std::cout << "<------------------------------------------->" << std::endl;
-	  }
-
-	/*
-	std::cout << "Clk: " << clk << std::endl;
-	std::cout << "Channel: " << channel->id << std::endl;
-	std::cout << "Refreshing rank: " << get_refreshing_rank() << std::endl;
-	if(otherq.q.size() != 0)
-	  {
-	    std::cout << "Other Queue: " << std::endl;
-	    otherq.print();
-	  }
-	*/
-	
-
-        auto req = scheduler->get_head(queue->q);
-        if (req == queue->q.end() || !is_ready(req)) {
-            queue = !write_mode ? &readq : &writeq;
-
-            if (otherq.size())
-                queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-
-            req = scheduler->get_head(queue->q);
-        }
-
-        if (req == queue->q.end() || !is_ready(req)) {
-            // we couldn't find a command to schedule -- let's try to be speculative
-            auto cmd = T::Command::PRE;
-            vector<int> victim = rowpolicy->get_victim(cmd);
-            if (!victim.empty()){
-                issue_cmd(cmd, victim);
-            }
-            return;  // nothing more to be done this cycle
-        }
-
-	if (req->is_first_command) {
-            req->is_first_command = false;
-            int coreid = req->coreid;
-            if (req->type == Request::Type::READ || req->type == Request::Type::WRITE) {
-              channel->update_serving_requests(req->addr_vec.data(), 1, clk);
-            }
-            int tx = (channel->spec->prefetch_size * channel->spec->channel_width / 8);
-            if (req->type == Request::Type::READ) {
-                if (is_row_hit(req)) {
-                    ++read_row_hits[coreid];
-                    ++row_hits;
-                    // daz3
-                    period_read_row_hits++;
-                } else if (is_row_open(req)) {
-                    ++read_row_conflicts[coreid];
-                    ++row_conflicts;
-                    // daz3
-                    period_read_row_conflicts++;
-                } else {
-                    ++read_row_misses[coreid];
-                    ++row_misses;
-                    // daz3
-                    period_read_row_misses++;
-                }
-              read_transaction_bytes += tx;
-            } else if (req->type == Request::Type::WRITE) {
-              if (is_row_hit(req)) {
-                  ++write_row_hits[coreid];
-                  ++row_hits;
-                  // daz3
-                  period_write_row_hits++;
-              } else if (is_row_open(req)) {
-                  ++write_row_conflicts[coreid];
-                  ++row_conflicts;
-                  // daz3
-                  period_write_row_conflicts++;
-              } else {
-                  ++write_row_misses[coreid];
-                  ++row_misses;
-                  // daz3
-                  period_write_row_misses++;
-              }
-              write_transaction_bytes += tx;
-            }
-        }
-
-        // issue command on behalf of request
-	//std::cout << "Issuing command on behalf of request: ";
-	//req->print();	  
-        auto cmd = get_first_cmd(req);
-        issue_cmd(cmd, get_addr_vec(cmd, req));
-
-        // check whether this is the last command (which finishes the request)
-        //if (cmd != channel->spec->translate[int(req->type)]){
-        if (!(channel->spec->is_accessing(cmd) || channel->spec->is_refreshing(cmd))) {
-            if(channel->spec->is_opening(cmd)) {
-                // promote the request that caused issuing activation to actq
-                actq.q.push_back(*req);
-                queue->q.erase(req);
-            }
-
-            return;
-        }
-
-        // set a future completion time for read requests
-        if (req->type == Request::Type::READ) {
-            req->depart = clk + channel->spec->read_latency;
-            pending.push_back(*req);
-        }
-
-        if (req->type == Request::Type::WRITE) {
-            channel->update_serving_requests(req->addr_vec.data(), -1, clk);
-        }
-
-	if(enable_debug)
-	  {
-	    std::cout << "Request completed: "; req->print();
-	  }
-
-	/*
-	// gagan : debug
-	if(req->type == Request::Type::REFRESH)
-	  {
-	    std::cout << "Request completed: "; req->print();
-	  }
-	*/
-	
-	if(req->type == Request::Type::READ || req->type == Request::Type::WRITE)
-	  {
-	    int rank = req->addr_vec[1];
-	    assert(rank != get_refreshing_rank());
-	  }
-        // remove request from queue
-        queue->q.erase(req);
-
-        // daz3
-        if(clk % my_print_intelval == 0)
-        {
-            std::cout << "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv" << std::endl;
-            std::cout << "clk " << clk << std::endl;
-            std::cout << "period_read_row_hits " << period_read_row_hits << std::endl;
-            std::cout << "period_read_row_misses " << period_read_row_misses << std::endl;
-            std::cout << "period_read_row_conflicts " << period_read_row_conflicts << std::endl;
-            std::cout << "period_write_row_hits " << period_write_row_hits << std::endl;
-            std::cout << "period_write_row_misses " << period_write_row_misses << std::endl;
-            std::cout << "period_write_row_conflicts " << period_write_row_conflicts << std::endl;
-            std::cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" << std::endl;
-        }
-    }
-
-    bool is_ready(list<Request>::iterator req)
-    {
-        typename T::Command cmd = get_first_cmd(req);
-        return channel->check(cmd, req->addr_vec.data(), clk);
-    }
-
-    bool is_ready(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-        return channel->check(cmd, addr_vec.data(), clk);
-    }
-
-    bool is_row_hit(list<Request>::iterator req)
-    {
-        // cmd must be decided by the request type, not the first cmd
-        typename T::Command cmd = channel->spec->translate[int(req->type)];
-        return channel->check_row_hit(cmd, req->addr_vec.data());
-    }
-
-    bool is_row_hit(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-        return channel->check_row_hit(cmd, addr_vec.data());
-    }
-
-    bool is_row_open(list<Request>::iterator req)
-    {
-        // cmd must be decided by the request type, not the first cmd
-        typename T::Command cmd = channel->spec->translate[int(req->type)];
-        return channel->check_row_open(cmd, req->addr_vec.data());
-    }
-
-    bool is_row_open(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-        return channel->check_row_open(cmd, addr_vec.data());
-    }
-
-    void update_temp(ALDRAM::Temp current_temperature)
-    {
-    }
-
-    // For telling whether this channel is busying in processing read or write
-    bool is_active() {
-      return (channel->cur_serving_requests > 0);
-    }
-
-    // For telling whether this channel is under refresh
-    /*
-    bool is_refresh() {
-      // gagan : for all-rank refresh
-      // return clk <= channel->end_of_refreshing;
-      // gagan : for staggered refresh
-      bool isAnyRankRefresh = false;
-      for(auto rank : channel->children)
-	{
-	  assert(isAnyRankRefresh == false);
-	  isAnyRankRefresh = (bool)(clk <= rank->end_of_refreshing);
-	}
-      return isAnyRankRefresh;
-    }
-    */
-
-    // gagan : returns which rank is refreshing, otherwise returns -1.
-    int get_refreshing_rank()
-    {
-      for(auto rank : channel->children)
-	{
-	  if(clk <= rank->end_of_refreshing)
-	    {
-	      return rank->id;
-	    }
-	}
-      return -1;
-    }
-
-    bool no_reads_to_non_refreshing_ranks(int refreshing_rank)
-    {
-      auto &read_queue = readq.q;
-      for(auto &req : read_queue)
-	{
-	  int rank = req.addr_vec[1];
-	  if(rank != refreshing_rank)
-	    return false;
-	}
-      return true;
-    }
-
-    void set_high_writeq_watermark(const float watermark) {
-       wr_high_watermark = watermark; 
-    }
-
-    void set_low_writeq_watermark(const float watermark) {
-       wr_low_watermark = watermark;
-    }
-
-    void record_core(int coreid) {
-#ifndef INTEGRATED_WITH_GEM5
-      record_read_hits[coreid] = read_row_hits[coreid];
-      record_read_misses[coreid] = read_row_misses[coreid];
-      record_read_conflicts[coreid] = read_row_conflicts[coreid];
-      record_write_hits[coreid] = write_row_hits[coreid];
-      record_write_misses[coreid] = write_row_misses[coreid];
-      record_write_conflicts[coreid] = write_row_conflicts[coreid];
-#endif
-    }
-
-private:
-    typename T::Command get_first_cmd(list<Request>::iterator req)
-    {
-        typename T::Command cmd = channel->spec->translate[int(req->type)];
-        return channel->decode(cmd, req->addr_vec.data());
-    }
-
-    // upgrade to an autoprecharge command
-    void cmd_issue_autoprecharge(typename T::Command& cmd,
-                                            const vector<int>& addr_vec) {
-
-        // currently, autoprecharge is only used with closed row policy
-        if(channel->spec->is_accessing(cmd) && rowpolicy->type == RowPolicy<T>::Type::ClosedAP) {
-            // check if it is the last request to the opened row
-            Queue* queue = write_mode ? &writeq : &readq;
-
-            auto begin = addr_vec.begin();
-            vector<int> rowgroup(begin, begin + int(T::Level::Row) + 1);
-
-			int num_row_hits = 0;
-
-            for (auto itr = queue->q.begin(); itr != queue->q.end(); ++itr) {
-                if (is_row_hit(itr)) { 
-                    auto begin2 = itr->addr_vec.begin();
-                    vector<int> rowgroup2(begin2, begin2 + int(T::Level::Row) + 1);
-                    if(rowgroup == rowgroup2)
-                        num_row_hits++;
-                }
-            }
-
-            if(num_row_hits == 0) {
-                Queue* queue = &actq;
-                for (auto itr = queue->q.begin(); itr != queue->q.end(); ++itr) {
-                    if (is_row_hit(itr)) {
-                        auto begin2 = itr->addr_vec.begin();
-                        vector<int> rowgroup2(begin2, begin2 + int(T::Level::Row) + 1);
-                        if(rowgroup == rowgroup2)
-                            num_row_hits++;
-                    }
-                }
-            }
-
-            assert(num_row_hits > 0); // The current request should be a hit, 
-                                      // so there should be at least one request 
-                                      // that hits in the current open row
-            if(num_row_hits == 1) {
-                if(cmd == T::Command::RD)
-                    cmd = T::Command::RDA;
-                else if (cmd == T::Command::WR)
-                    cmd = T::Command::WRA;
-                else
-                    assert(false && "Unimplemented command type.");
-            }
-        }
-
-    }
-
-    void issue_cmd(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-      	// gagan : staggered refresh
-      /*
-	if(channel->spec->standard_name == "DDR4" && int(cmd) == int(T::Command::REF))
-	  {
-	    assert(is_refresh() == false);
-	  }
-      */
-      
-        cmd_issue_autoprecharge(cmd, addr_vec);
-        assert(is_ready(cmd, addr_vec));
-        channel->update(cmd, addr_vec.data(), clk);
-
-	/*
-	 // gagan : debug
-	if(channel->spec->standard_name == "DDR4" && int(cmd) == int(T::Command::REF))
-	  {
-	    int i = 0;
-	    for (auto child : channel->children)
-	      {
-		std::cout << "end_of_refreshing_rank: " << i << ", clk: " << child->end_of_refreshing << std::endl;
-		i++;
-	      }
-	  }
-	*/
-
-        if(cmd == T::Command::PRE){
-            if(rowtable->get_hits(addr_vec, true) == 0){
-                useless_activates++;
-            }
-        }
- 
-        rowtable->update(cmd, addr_vec, clk);
-        if (record_cmd_trace){
-            // select rank
-            auto& file = cmd_trace_files[addr_vec[1]];
-            string& cmd_name = channel->spec->command_name[int(cmd)];
-            file<<clk<<','<<cmd_name;
-            // TODO bad coding here
-            if (cmd_name == "PREA" || cmd_name == "REF")
-                file<<endl;
-            else{
-                int bank_id = addr_vec[int(T::Level::Bank)];
-                if (channel->spec->standard_name == "DDR4" || channel->spec->standard_name == "GDDR5")
-                    bank_id += addr_vec[int(T::Level::Bank) - 1] * channel->spec->org_entry.count[int(T::Level::Bank)];
-                file<<','<<bank_id<<endl;
-            }
-        }
-        if (print_cmd_trace){
-            printf("%5s %10ld:", channel->spec->command_name[int(cmd)].c_str(), clk);
-            for (int lev = 0; lev < int(T::Level::MAX); lev++)
-                printf(" %5d", addr_vec[lev]);
-            printf("\n");
-        }
-    }
-    vector<int> get_addr_vec(typename T::Command cmd, list<Request>::iterator req){
-        return req->addr_vec;
-    }
-};
-
-template <>
-vector<int> Controller<SALP>::get_addr_vec(
-    SALP::Command cmd, list<Request>::iterator req);
-
-template <>
-bool Controller<SALP>::is_ready(list<Request>::iterator req);
-
-template <>
-void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature);
-
-template <>
-void Controller<TLDRAM>::tick();
-
-template <>
-void Controller<TLDRAM>::cmd_issue_autoprecharge(typename TLDRAM::Command& cmd,
-                                                    const vector<int>& addr_vec);
-
-} /*namespace ramulator*/
-
-#endif /*__CONTROLLER_H*/
diff --git a/ext/ramulator/Ramulator/src/DDR3.cpp b/ext/ramulator/Ramulator/src/DDR3.cpp
deleted file mode 100644
index bc3957dc0..000000000
--- a/ext/ramulator/Ramulator/src/DDR3.cpp
+++ /dev/null
@@ -1,357 +0,0 @@
-#include "DDR3.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string DDR3::standard_name = "DDR3";
-string DDR3::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum DDR3::Org> DDR3::org_map = {
-    {"DDR3_512Mb_x4", DDR3::Org::DDR3_512Mb_x4}, {"DDR3_512Mb_x8", DDR3::Org::DDR3_512Mb_x8}, {"DDR3_512Mb_x16", DDR3::Org::DDR3_512Mb_x16},
-    {"DDR3_1Gb_x4", DDR3::Org::DDR3_1Gb_x4}, {"DDR3_1Gb_x8", DDR3::Org::DDR3_1Gb_x8}, {"DDR3_1Gb_x16", DDR3::Org::DDR3_1Gb_x16},
-    {"DDR3_2Gb_x4", DDR3::Org::DDR3_2Gb_x4}, {"DDR3_2Gb_x8", DDR3::Org::DDR3_2Gb_x8}, {"DDR3_2Gb_x16", DDR3::Org::DDR3_2Gb_x16},
-    {"DDR3_4Gb_x4", DDR3::Org::DDR3_4Gb_x4}, {"DDR3_4Gb_x8", DDR3::Org::DDR3_4Gb_x8}, {"DDR3_4Gb_x16", DDR3::Org::DDR3_4Gb_x16},
-    {"DDR3_8Gb_x4", DDR3::Org::DDR3_8Gb_x4}, {"DDR3_8Gb_x8", DDR3::Org::DDR3_8Gb_x8}, {"DDR3_8Gb_x16", DDR3::Org::DDR3_8Gb_x16},
-};
-
-map<string, enum DDR3::Speed> DDR3::speed_map = {
-    {"DDR3_800D", DDR3::Speed::DDR3_800D}, {"DDR3_800E", DDR3::Speed::DDR3_800E},
-    {"DDR3_1066E", DDR3::Speed::DDR3_1066E}, {"DDR3_1066F", DDR3::Speed::DDR3_1066F}, {"DDR3_1066G", DDR3::Speed::DDR3_1066G},
-    {"DDR3_1333G", DDR3::Speed::DDR3_1333G}, {"DDR3_1333H", DDR3::Speed::DDR3_1333H},
-    {"DDR3_1600H", DDR3::Speed::DDR3_1600H}, {"DDR3_1600J", DDR3::Speed::DDR3_1600J}, {"DDR3_1600K", DDR3::Speed::DDR3_1600K},
-    {"DDR3_1866K", DDR3::Speed::DDR3_1866K}, {"DDR3_1866L", DDR3::Speed::DDR3_1866L},
-    {"DDR3_2133L", DDR3::Speed::DDR3_2133L}, {"DDR3_2133M", DDR3::Speed::DDR3_2133M},
-};
-
-
-DDR3::DDR3(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-DDR3::DDR3(const string& org_str, const string& speed_str) :
-    DDR3(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void DDR3::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void DDR3::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void DDR3::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void DDR3::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void DDR3::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR3::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR3::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DDR3>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR3>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void DDR3::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/DDR3.h b/ext/ramulator/Ramulator/src/DDR3.h
deleted file mode 100644
index bed966b1f..000000000
--- a/ext/ramulator/Ramulator/src/DDR3.h
+++ /dev/null
@@ -1,220 +0,0 @@
-#ifndef __DDR3_H
-#define __DDR3_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DDR3
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    DDR3(Org org, Speed speed);
-    DDR3(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-    
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<DDR3>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DDR3>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DDR3>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DDR3>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        DDR3_512Mb_x4, DDR3_512Mb_x8, DDR3_512Mb_x16,
-        DDR3_1Gb_x4,   DDR3_1Gb_x8,   DDR3_1Gb_x16,
-        DDR3_2Gb_x4,   DDR3_2Gb_x8,   DDR3_2Gb_x16,
-        DDR3_4Gb_x4,   DDR3_4Gb_x8,   DDR3_4Gb_x16,
-        DDR3_8Gb_x4,   DDR3_8Gb_x8,   DDR3_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DDR3_800D,  DDR3_800E,
-        DDR3_1066E, DDR3_1066F, DDR3_1066G,
-        DDR3_1333G, DDR3_1333H,
-        DDR3_1600H, DDR3_1600J, DDR3_1600K,
-        DDR3_1866K, DDR3_1866L,
-        DDR3_2133L, DDR3_2133M,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__DDR3_H*/
diff --git a/ext/ramulator/Ramulator/src/DDR4.cpp b/ext/ramulator/Ramulator/src/DDR4.cpp
deleted file mode 100644
index 1fceb8889..000000000
--- a/ext/ramulator/Ramulator/src/DDR4.cpp
+++ /dev/null
@@ -1,634 +0,0 @@
-
-#include "DDR4.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string DDR4::standard_name = "DDR4";
-string DDR4::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-
-map<string, enum DDR4::Org> DDR4::org_map = {
-    {"DDR4_2Gb_x4", DDR4::Org::DDR4_2Gb_x4}, {"DDR4_2Gb_x8", DDR4::Org::DDR4_2Gb_x8}, {"DDR4_2Gb_x16", DDR4::Org::DDR4_2Gb_x16},
-    {"DDR4_4Gb_x4", DDR4::Org::DDR4_4Gb_x4}, {"DDR4_4Gb_x8", DDR4::Org::DDR4_4Gb_x8}, {"DDR4_4Gb_x16", DDR4::Org::DDR4_4Gb_x16},
-    {"DDR4_8Gb_x4", DDR4::Org::DDR4_8Gb_x4}, {"DDR4_8Gb_x8", DDR4::Org::DDR4_8Gb_x8}, {"DDR4_8Gb_x16", DDR4::Org::DDR4_8Gb_x16},
-    {"DDR4_4Gb_x8_w16", DDR4::Org::DDR4_4Gb_x8_w16}, {"DDR4_4Gb_x8_w32", DDR4::Org::DDR4_4Gb_x8_w32}, {"DDR4_4Gb_x8_w64", DDR4::Org::DDR4_4Gb_x8_w64},
-    {"DDR4_4Gb_x8_w8", DDR4::Org::DDR4_4Gb_x8_w8},
-    {"DDR4_4Gb_x8_4xBank", DDR4::Org::DDR4_4Gb_x8_4xBank},
-    {"DDR4_4Gb_x8_2xBank", DDR4::Org::DDR4_4Gb_x8_2xBank}
-};
-
-map<string, enum DDR4::Speed> DDR4::speed_map = {
-    {"DDR4_1600K", DDR4::Speed::DDR4_1600K},
-    {"DDR4_1600L", DDR4::Speed::DDR4_1600L},
-    {"DDR4_1866M", DDR4::Speed::DDR4_1866M},
-    {"DDR4_1866N", DDR4::Speed::DDR4_1866N},
-    {"DDR4_2133P", DDR4::Speed::DDR4_2133P},
-    {"DDR4_2133R", DDR4::Speed::DDR4_2133R},
-    {"DDR4_2400R", DDR4::Speed::DDR4_2400R},
-    // gagan
-    {"DDR4_2400R_base", DDR4::Speed::DDR4_2400R_base},
-    {"DDR4_2400R_ideal_nbr_lbb", DDR4::Speed::DDR4_2400R_ideal_nbr_lbb},
-    {"DDR4_2933R_ideal_nbr_lbb_ts", DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts},
-    {"DDR4_2933R_ideal_nbr_lbb_sts", DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts},
-    // Ramulator
-    {"DDR4_2400U", DDR4::Speed::DDR4_2400U},
-    {"DDR4_3200", DDR4::Speed::DDR4_3200},
-    // daz3
-    {"DDR4_3200_base", DDR4::Speed::DDR4_3200_base},
-    {"DDR4_3200_ideal_v1", DDR4::Speed::DDR4_3200_ideal_v1},
-    {"DDR4_3200_ideal_v2", DDR4::Speed::DDR4_3200_ideal_v2},
-    {"DDR4_3200_ideal_v2_modified", DDR4::Speed::DDR4_3200_ideal_v2_modified},
-    {"DDR4_3200_ideal_v3", DDR4::Speed::DDR4_3200_ideal_v3},
-    {"DDR4_3200_ideal_v4", DDR4::Speed::DDR4_3200_ideal_v4},
-    {"DDR4_3200_ideal_v7", DDR4::Speed::DDR4_3200_ideal_v7},
-    {"DDR4_3200_ideal_v4s", DDR4::Speed::DDR4_3200_ideal_v4s},
-    {"DDR4_3200_ideal_v5a", DDR4::Speed::DDR4_3200_ideal_v5a},
-    {"DDR4_3600_ideal_v4", DDR4::Speed::DDR4_3600_ideal_v4},
-    {"DDR4_3866_ideal_v4", DDR4::Speed::DDR4_3866_ideal_v4},
-    {"DDR4_3200_ideal_nbr_lbb", DDR4::Speed::DDR4_3200_ideal_nbr_lbb},
-    {"DDR4_3866_ideal_nbr_lbb_ts", DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts},
-    {"DDR4_3866_ideal_nbr_lbb_sts", DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts},
-    {"DDR4_3200_base_half_w8", DDR4::Speed::DDR4_3200_base_half_w8},
-    {"DDR4_3200_base_half_w16", DDR4::Speed::DDR4_3200_base_half_w16},
-    {"DDR4_3200_base_half_w32", DDR4::Speed::DDR4_3200_base_half_w32},
-    {"DDR4_3200_base_half_w64", DDR4::Speed::DDR4_3200_base_half_w64},
-    {"DDR4_3200_base_full_w8", DDR4::Speed::DDR4_3200_base_full_w8},
-    {"DDR4_3200_base_full_w16", DDR4::Speed::DDR4_3200_base_full_w16},
-    {"DDR4_3200_base_full_w32", DDR4::Speed::DDR4_3200_base_full_w32},
-    {"DDR4_3200_base_full_w64", DDR4::Speed::DDR4_3200_base_full_w64},
-    {"DDR4_3200_base_quarter_w8", DDR4::Speed::DDR4_3200_base_quarter_w8},
-    {"DDR4_3200_base_quarter_w16", DDR4::Speed::DDR4_3200_base_quarter_w16},
-    {"DDR4_3200_base_quarter_w32", DDR4::Speed::DDR4_3200_base_quarter_w32},
-    {"DDR4_3200_base_quarter_w64", DDR4::Speed::DDR4_3200_base_quarter_w64},
-    {"DDR4_3734_reduced_tRCD_tRP", DDR4::Speed::DDR4_3734_reduced_tRCD_tRP},
-    {"DDR4_2666_base", DDR4::Speed::DDR4_2666_base},
-    {"DDR4_4000_base", DDR4::Speed::DDR4_4000_base},
-    {"DDR4_4000_base_reduced", DDR4::Speed::DDR4_4000_base_reduced},
-};
-
-
-DDR4::DDR4(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]), 
-    read_latency(speed_entry.nCL + speed_entry.nBL),
-    mySpeed(speed)//daz3
-{
-    if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w8))
-    {
-        channel_width = 8;
-    }
-    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w16))
-    {
-        channel_width = 16;
-    }
-    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w32))
-    {
-        channel_width = 32;
-    }
-    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w64))
-    {
-        channel_width = 64;
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3734_reduced_tRCD_tRP)
-            || int(speed) == int(DDR4::Speed::DDR4_4000_base_reduced))
-    {
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        int _RP = s.nRP;
-        int _REFI = s.nREFI;
-        s.nRAS -= 0.12 * _RCD;
-        s.nRC -= (0.12 * _RCD + 0.5 * _RP);
-        _RCD *= 0.88;
-        s.nRCD = _RCD;
-        _RP *= 0.5;
-        s.nRP = _RP;
-        _REFI *= 4;
-        s.nREFI = _REFI;
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v4) || int(speed) == int(DDR4::Speed::DDR4_3600_ideal_v4) ||
-       int(speed) == int(DDR4::Speed::DDR4_3866_ideal_v4) || int(speed) == int(DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts) ||
-       int(speed) == int(DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts))
-    {
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        _RCD *= 0.75;
-        int diff_RCD = _RCD - s.nRCD;
-        s.nRCD = _RCD;
-        s.nRC = s.nRC + diff_RCD;
-
-        int _RP = s.nRP;
-        _RP *= 0.75;
-        int diff_RP = _RP - s.nRP;
-        s.nRP = _RP;
-
-        s.nRAS = s.nRAS + diff_RCD + diff_RP;
-
-      /*
-	// gagan : 
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        _RCD *= 0.75;
-        int diff_RCD = _RCD - s.nRCD;
-        s.nRCD = _RCD;
-
-        int _RP = s.nRP;
-        _RP *= 0.75;
-        int diff_RP = _RP - s.nRP;
-        s.nRP = _RP;
-
-        s.nRC = s.nRC + diff_RCD + diff_RP;
-        s.nRAS = s.nRAS + diff_RCD + diff_RP;
-      */
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v4s) || int(speed) == int(DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts) ||
-       int(speed) == int(DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts))
-    {
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        _RCD -= (_RCD - 1);
-        int diff_RCD = _RCD - s.nRCD;
-        s.nRCD = _RCD;
-        s.nRC = s.nRC + diff_RCD;
-
-        int _RP = s.nRP;
-        _RP -= (_RP - 1);
-        int diff_RP = _RP - s.nRP;
-        s.nRP = _RP;
-
-	s.nRAS = s.nRAS + diff_RCD + diff_RP;
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v5a))
-    {
-    }
-
-    
-
-
-    std::cout << "ramulator channel width = " << channel_width << std::endl;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-DDR4::DDR4(const string& org_str, const string& speed_str) :
-    DDR4(org_map[org_str], speed_map[speed_str]) 
-{
-}
-
-void DDR4::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void DDR4::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void DDR4::init_speed()
-{
-    const static int RRDS_TABLE[2][7] = {
-      {4, 4, 4, 4, 4, 4, 4},
-      {5, 5, 6, 7, 9, 10, 11}
-    };
-    const static int RRDL_TABLE[2][7] = {
-        {5, 5, 6, 6, 8},
-        {6, 6, 7, 8, 11}
-    };
-    const static int FAW_TABLE[3][7] = {
-      {16, 16, 16, 16, 16, 16, 16},
-      {20, 22, 23, 26, 34, 38, 41},
-      {28, 28, 32, 36, 48, 54, 58}
-    };
-    const static int RFC_TABLE[int(RefreshMode::MAX)][3][7] = {{   
-	{128, 150, 171, 192, 256, 288, 310},
-	{208, 243, 278, 312, 416, 468, 503},
-	{280, 327, 374, 420, 560, 630, 677}
-        },{
-	{88, 103, 118, 132,  176, 198, 213},
-	{128, 150, 171, 192, 256, 288, 310},
-	{208, 243, 278, 312, 416, 468, 503} 
-        },{
-	{72, 84, 96, 108, 144, 162, 174},
-	{88, 103, 118, 132, 176, 198, 213},
-	{128, 150, 171, 192, 256, 288, 310}  
-        }
-    };
-    const static int REFI_TABLE[7] = {
-      6240, 7280, 8320, 9360, 12480, 14040, 15077
-    };
-    const static int XS_TABLE[3][7] = {
-      {136, 159, 182, 204, 272, 306, 329},
-      {216, 252, 288, 324, 432, 486, 522},
-      {288, 336, 384, 432, 576, 648, 697}
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1600: speed = 0; break;
-        case 1866: speed = 1; break;
-        case 2133: speed = 2; break;
-        case 2400: speed = 3; break;
-        case 2933: break; // gagan
-        case 3200: speed = 4; break;
-        case 3600: speed = 5; break;
-        case 3734: break;
-        case 4000: break;
-        case 2666: break;
-        case 3866: speed = 6; break;
-        case 6400: break;//daz3
-        case 800: break;//daz3
-        case 12800: break;
-        case 25600: break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 2: density = 0; break;
-        case 4: density = 1; break;
-        case 8: density = 2; break;
-        default: assert(false);
-    }
-    // daz3
-    if(mySpeed != DDR4::Speed::DDR4_3200_base 
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v1 
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v2 
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v3
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v4
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v7
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v4s
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v5a
-            && mySpeed != DDR4::Speed::DDR4_3600_ideal_v4
-            && mySpeed != DDR4::Speed::DDR4_3866_ideal_v4
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_nbr_lbb
-            && mySpeed != DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts
-            && mySpeed != DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w8
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w16
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w32
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w64
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w8
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w16
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w32
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w64
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w8
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w16
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w32
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w64
-            && mySpeed != DDR4::Speed::DDR4_3734_reduced_tRCD_tRP
-            && mySpeed != DDR4::Speed::DDR4_2666_base
-            && mySpeed != DDR4::Speed::DDR4_4000_base
-            && mySpeed != DDR4::Speed::DDR4_4000_base_reduced
-       // gagan
-            && mySpeed != DDR4::Speed::DDR4_2400R_base
-            && mySpeed != DDR4::Speed::DDR4_2400R_ideal_nbr_lbb
-            && mySpeed != DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts
-            && mySpeed != DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts)
-    {
-        speed_entry.nRRDS = RRDS_TABLE[org_entry.dq == 16? 1: 0][speed];
-        speed_entry.nRRDL = RRDL_TABLE[org_entry.dq == 16? 1: 0][speed];
-        speed_entry.nFAW = FAW_TABLE[org_entry.dq == 4? 0: org_entry.dq == 8? 1: 2][speed];
-        speed_entry.nRFC = RFC_TABLE[(int)refresh_mode][density][speed];
-        speed_entry.nREFI = (REFI_TABLE[speed] >> int(refresh_mode));
-        speed_entry.nXS = XS_TABLE[density][speed];
-    }
-    // speed_entry.nRRDS = RRDS_TABLE[org_entry.dq == 16? 1: 0][speed];
-    // speed_entry.nRRDL = RRDL_TABLE[org_entry.dq == 16? 1: 0][speed];
-    // speed_entry.nFAW = FAW_TABLE[org_entry.dq == 4? 0: org_entry.dq == 8? 1: 2][speed];
-    // speed_entry.nRFC = RFC_TABLE[(int)refresh_mode][density][speed];
-    // speed_entry.nREFI = (REFI_TABLE[speed] >> int(refresh_mode));
-    // speed_entry.nXS = XS_TABLE[density][speed];
-}
-
-
-void DDR4::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                else return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        for (auto bg : node->children)
-            for (auto bank: bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                return Command::PREA;
-            }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void DDR4::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR4::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR4::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DDR4>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                bank->state = State::Closed;
-                bank->row_state.clear();
-            }};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR4>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                node->state = State::ActPowerDown;
-                return;
-            }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void DDR4::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDS});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::RDA)].push_back({Command::REF, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::REF, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-    
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-    
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-    /*** Bank Group ***/ 
-    t = timing[int(Level::BankGroup)];
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDL});
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-
-    // daz3
-    std::cout << "rate " << s.rate << std::endl; 
-    std::cout << "freq " << s.freq << std::endl; 
-    std::cout << "tCK " << s.tCK << std::endl; 
-    std::cout << "nBL " << s.nBL << std::endl; 
-    std::cout << "nCCDS " << s.nCCDS << std::endl; 
-    std::cout << "nCCDL " << s.nCCDL << std::endl; 
-    std::cout << "nRTRS " << s.nRTRS << std::endl; 
-    std::cout << "nCL " << s.nCL << std::endl; 
-    std::cout << "nRCD " << s.nRCD << std::endl; 
-    std::cout << "nRP " << s.nRP << std::endl; 
-    std::cout << "nCWL " << s.nCWL << std::endl; 
-    std::cout << "nRAS " << s.nRAS << std::endl; 
-    std::cout << "nRC " << s.nRC << std::endl; 
-    std::cout << "nRTP " << s.nRTP << std::endl; 
-    std::cout << "nWTRS " << s.nWTRS << std::endl; 
-    std::cout << "nWTRL " << s.nWTRL << std::endl; 
-    std::cout << "nWR " << s.nWR << std::endl; 
-    std::cout << "nRRDS " << s.nRRDS << std::endl; 
-    std::cout << "nRRDL " << s.nRRDL << std::endl; 
-    std::cout << "nFAW " << s.nFAW << std::endl; 
-    std::cout << "nRFC " << s.nRFC << std::endl; 
-    std::cout << "nREFI " << s.nREFI << std::endl; 
-    std::cout << "nPD " << s.nPD << std::endl; 
-    std::cout << "nXP " << s.nXP << std::endl; 
-    std::cout << "nXPDLL " << s.nXPDLL << std::endl; 
-    std::cout << "nCKESR " << s.nCKESR << std::endl; 
-    std::cout << "nXS " << s.nXS << std::endl; 
-    std::cout << "nXSDLL " << s.nXSDLL << std::endl; 
-    std::cout << "nRCD " << s.nRCD << std::endl; 
-    std::cout << "nRC " << s.nRC << std::endl; 
-    std::cout << "nRP " << s.nRP << std::endl; 
-    std::cout << "channel_id " << org_entry.count[int(Level::Channel)] << std::endl; 
-    std::cout << "ranks " << org_entry.count[int(Level::Rank)] << std::endl; 
-}
diff --git a/ext/ramulator/Ramulator/src/DDR4.h b/ext/ramulator/Ramulator/src/DDR4.h
deleted file mode 100644
index 612e1f21d..000000000
--- a/ext/ramulator/Ramulator/src/DDR4.h
+++ /dev/null
@@ -1,311 +0,0 @@
-#ifndef __DDR4_H
-#define __DDR4_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DDR4
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    DDR4(Org org, Speed speed);
-    DDR4(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prereq */
-    function<Command(DRAM<DDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        DDR4_2Gb_x4,   DDR4_2Gb_x8,   DDR4_2Gb_x16,
-        DDR4_4Gb_x4,   DDR4_4Gb_x8,   DDR4_4Gb_x16,
-        DDR4_8Gb_x4,   DDR4_8Gb_x8,   DDR4_8Gb_x16,
-        DDR4_4Gb_x8_w16, DDR4_4Gb_x8_w32, DDR4_4Gb_x8_w64,
-        DDR4_4Gb_x8_w8,
-        DDR4_4Gb_x8_4xBank,
-        DDR4_4Gb_x8_2xBank,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {2<<10,  4, {0, 0, 4, 4, 1<<15, 1<<10}}, {2<<10,  8, {0, 0, 4, 4, 1<<14, 1<<10}}, {2<<10, 16, {0, 0, 2, 4, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 4, 4, 1<<16, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10, 16, {0, 0, 2, 4, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 4, 4, 1<<17, 1<<10}}, {8<<10,  8, {0, 0, 4, 4, 1<<16, 1<<10}}, {8<<10, 16, {0, 0, 2, 4, 1<<16, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//16,32,64B cacheline
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//8B cacheline
-        {4<<10,  8, {0, 0, 4, 16, 1<<15, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 8, 1<<15, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DDR4_1600K,
-	DDR4_1600L,
-        DDR4_1866M,
-	DDR4_1866N,
-        DDR4_2133P,
-	DDR4_2133R,
-        DDR4_2400R,
-        // gagan
-        DDR4_2400R_base,
-	DDR4_2400R_ideal_nbr_lbb,
-	DDR4_2933R_ideal_nbr_lbb_ts,
-	DDR4_2933R_ideal_nbr_lbb_sts,
-        // Ramulator
-	DDR4_2400U,
-        DDR4_3200,
-        // daz3
-        DDR4_3200_base,
-        DDR4_3200_ideal_v1,// tRFC=0
-        DDR4_3200_ideal_v2,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v2_modified,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v3,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0
-        DDR4_3200_ideal_v4,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0,tRDC*75%,tRP*75%
-        DDR4_3200_ideal_v7,// tRFC=0
-	DDR4_3200_ideal_v4s,
-	DDR4_3200_ideal_v5a,
-	DDR4_3600_ideal_v4,
-	DDR4_3866_ideal_v4,
-	DDR4_3200_ideal_nbr_lbb, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0
-	DDR4_3866_ideal_nbr_lbb_ts, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0,tRDC*=75%,tRP*=75%
-	DDR4_3866_ideal_nbr_lbb_sts, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0,tRDC=1,tRP=1
-        DDR4_3200_base_half_w8,// for different cacheline size
-        DDR4_3200_base_half_w16,// for different cacheline size
-        DDR4_3200_base_half_w32,
-        DDR4_3200_base_half_w64,
-        DDR4_3200_base_full_w8,// for different cacheline size
-        DDR4_3200_base_full_w16,// for different cacheline size
-        DDR4_3200_base_full_w32,
-        DDR4_3200_base_full_w64,
-        DDR4_3200_base_quarter_w8,// for different cacheline size
-        DDR4_3200_base_quarter_w16,// for different cacheline size
-        DDR4_3200_base_quarter_w32,
-        DDR4_3200_base_quarter_w64,
-        DDR4_3734_reduced_tRCD_tRP,
-        DDR4_2666_base,
-        DDR4_4000_base,
-        DDR4_4000_base_reduced,
-        MAX
-    }mySpeed;
-    // };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        Refresh_2X,
-        Refresh_4X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTRS, nWTRL, nWR;
-        int nRRDS, nRRDL, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL; // XPDLL not found in DDR4??
-        int nCKESR, nXS, nXSDLL; // nXSDLL TBD (nDLLK), nXS = (tRFC+10ns)/tCK
-    } speed_table[int(Speed::MAX)] = {
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 11, 11, 11,  9, 28, 39, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 12, 12, 12,  9, 28, 40, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 13, 13, 13, 10, 32, 45, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 14, 14, 14, 10, 32, 46, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 15, 15, 15, 11, 36, 51, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 16, 16, 16, 11, 36, 52, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 16, 16, 16, 12, 39, 55, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-	// gagan
-        {2400, 1200,   0.833, prefetch_size/2/*DDR*/,   4,    6,    2, 16, 16,  16, 12,  39, 55,   9,    3,     9,  18,   4,   6,   26, 660,  9360,    6,    8,    0,   7,   672,  768},
-        {2400, 1200,   0.833, prefetch_size/2/*DDR*/,   4,    6,    2, 16, 16,  16, 12,  39, 55,   9,    0,     0,   0,   0,   0,    0,   0,  9360,    6,    8,    0,   7,   672,  768},
-	{2933, 2933/2, 0.681, prefetch_size/2/*DDR*/,   4,    7,    2, 16, 20,  20, 15,  47, 67,  11,    0,     0,   0,   0,   0,    0,   0, 11439,    7,   10,    0,   9,   821,  939},
-	{2933, 2933/2, 0.681, prefetch_size/2/*DDR*/,   4,    7,    2, 16, 20,  20, 15,  47, 67,  11,    0,     0,   0,   0,   0,    0,   0, 11439,    7,   10,    0,   9,   821,  939},
-	//rate, freq,    tCK,             nBL,       nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC  nREFI   nPD   nXP  nXPDLL nCKESR nXS  nXSDLL
-	// Ramulator
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 18, 18, 18, 12, 39, 57, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,     10,   2,    22, 22,  22, 16,  56,  78, 12,  4,    12,   24, 8,    10,   40,  0,   0,    8,  10, 0,     8,     0,  0},
-        // daz3
-        // {3200, 1600, 0.625, prefetch_size/2[>DDR<], 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  480, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,  480, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   48,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3600, 1800, 0.555, prefetch_size/2/*DDR*/, 4,      9,   2,    25, 25,  25, 22,  57,  82, 13,  0,     0,   27, 0,     0,    0,    0, 14040,   9,   11,  0,   10, 1008, 1152},
-	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,   29, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,    0, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,    0, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,    0, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-	//{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22,  0,   0, 20,  10,  32, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	//rate, freq, tCK,  nBL,                    nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI   nPD   nXP  nXPDLL nCKESR nXS  nXSDLL
-
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-
-        {25600, 12800, 0.078125, prefetch_size*2/*DDR*/, 32,      64,   16,    176, 176,  176, 160, 416,  592, 96,  0,     0,   192, 0,     0,    0,    0, 99840,   64,   80,  0,   72,   7168, 8192},
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-        {800, 400, 2.5, prefetch_size/8/*DDR*/, 1,      2,   1,    6, 6,  6, 5,  13,  14, 3,  0,     0,   6, 0,     0,    0,    0, 3120,   2,   3,  0,   3,   224, 256},
-        //rate, freq, tCK,  nBL, nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-        // rate, freq, tCK,  nBL,                  nCCDS  nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL 480 nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-        {3734, 1867, 0.537, prefetch_size/2/*DDR*/, 4,      10,   3,    26, 26,  26, 24,  61,  87, 14,  5,    14,   28, 5,     10,   40,   560, 14563,   12,   12,  0,   11,   1046, 1195},
-        {2666, 1333, 0.75, prefetch_size/2/*DDR*/, 4,        7,   2,    19, 19,  19, 17,  44,  62, 10,  4,    10,   20, 4,     7,    29,   734, 10400,   7,   9,   0,   8,   747, 854},
-        {4000, 2000, 0.5, prefetch_size/2/*DDR*/,  4,       10,   2,    27, 27,  27, 25,  65,  92, 15,  4,    15,   30,  4,    10,   42,   600, 15600,   8,   12,  0,   11,   1120, 1280},
-        {4000, 2000, 0.5, prefetch_size/2/*DDR*/,  4,       10,   2,    27, 27,  27, 25,  65,  92, 15,  4,    15,   30, 4,     10,   42,   600, 15600,   0,    0,  0,    0,      0,    0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__DDR4_H*/
diff --git a/ext/ramulator/Ramulator/src/DDR4.h.backup b/ext/ramulator/Ramulator/src/DDR4.h.backup
deleted file mode 100644
index 02ad58508..000000000
--- a/ext/ramulator/Ramulator/src/DDR4.h.backup
+++ /dev/null
@@ -1,267 +0,0 @@
-#ifndef __DDR4_H
-#define __DDR4_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DDR4
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    DDR4(Org org, Speed speed);
-    DDR4(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prereq */
-    function<Command(DRAM<DDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        DDR4_2Gb_x4,   DDR4_2Gb_x8,   DDR4_2Gb_x16,
-        DDR4_4Gb_x4,   DDR4_4Gb_x8,   DDR4_4Gb_x16,
-        DDR4_8Gb_x4,   DDR4_8Gb_x8,   DDR4_8Gb_x16,
-        DDR4_4Gb_x8_w16, DDR4_4Gb_x8_w32, DDR4_4Gb_x8_w64,
-        DDR4_4Gb_x8_w8,
-        DDR4_4Gb_x8_4xBank,
-        DDR4_4Gb_x8_2xBank,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {2<<10,  4, {0, 0, 4, 4, 1<<15, 1<<10}}, {2<<10,  8, {0, 0, 4, 4, 1<<14, 1<<10}}, {2<<10, 16, {0, 0, 2, 4, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 4, 4, 1<<16, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10, 16, {0, 0, 2, 4, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 4, 4, 1<<17, 1<<10}}, {8<<10,  8, {0, 0, 4, 4, 1<<16, 1<<10}}, {8<<10, 16, {0, 0, 2, 4, 1<<16, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//16,32,64B cacheline
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//8B cacheline
-        {4<<10,  8, {0, 0, 4, 16, 1<<15, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 8, 1<<15, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DDR4_1600K, DDR4_1600L,
-        DDR4_1866M, DDR4_1866N,
-        DDR4_2133P, DDR4_2133R,
-        DDR4_2400R, DDR4_2400U,
-        DDR4_3200,
-        // daz3
-        DDR4_3200_base,
-        DDR4_3200_ideal_v1,// tRFC=0
-        DDR4_3200_ideal_v2,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v2_modified,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v3,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0
-        DDR4_3200_ideal_v4,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0,tRDC*75%,tRP*75%
-        DDR4_3200_base_half_w8,// for different cacheline size
-        DDR4_3200_base_half_w16,// for different cacheline size
-        DDR4_3200_base_half_w32,
-        DDR4_3200_base_half_w64,
-        DDR4_3200_base_full_w8,// for different cacheline size
-        DDR4_3200_base_full_w16,// for different cacheline size
-        DDR4_3200_base_full_w32,
-        DDR4_3200_base_full_w64,
-        DDR4_3200_base_quarter_w8,// for different cacheline size
-        DDR4_3200_base_quarter_w16,// for different cacheline size
-        DDR4_3200_base_quarter_w32,
-        DDR4_3200_base_quarter_w64,
-        MAX
-    }mySpeed;
-    // };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        Refresh_2X,
-        Refresh_4X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTRS, nWTRL, nWR;
-        int nRRDS, nRRDL, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL; // XPDLL not found in DDR4??
-        int nCKESR, nXS, nXSDLL; // nXSDLL TBD (nDLLK), nXS = (tRFC+10ns)/tCK
-    } speed_table[int(Speed::MAX)] = {
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 11, 11, 11,  9, 28, 39, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 12, 12, 12,  9, 28, 40, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 13, 13, 13, 10, 32, 45, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 14, 14, 14, 10, 32, 46, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 15, 15, 15, 11, 36, 51, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 16, 16, 16, 11, 36, 52, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 16, 16, 16, 12, 39, 55, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 18, 18, 18, 12, 39, 57, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,     10,   2,    22, 22,  22, 16,  56,  78, 12,  4,    12,   24, 8,    10,   40,  0,   0,    8,  10, 0,     8,     0,  0},
-        // daz3
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   48,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-
-        {25600, 12800, 0.078125, prefetch_size*2/*DDR*/, 32,      64,   16,    176, 176,  176, 160, 416,  592, 96,  0,     0,   192, 0,     0,    0,    0, 99840,   64,   80,  0,   72,   7168, 8192},
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-        {800, 400, 2.5, prefetch_size/8/*DDR*/, 1,      2,   1,    6, 6,  6, 5,  13,  14, 3,  0,     0,   6, 0,     0,    0,    0, 3120,   2,   3,  0,   3,   224, 256}
-        //rate, f eq, tCK,  nBL, nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-        // //rate, freq, tCK,  nBL,           nCCDS  nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__DDR4_H*/
diff --git a/ext/ramulator/Ramulator/src/DRAM.h b/ext/ramulator/Ramulator/src/DRAM.h
deleted file mode 100644
index 1456b4b50..000000000
--- a/ext/ramulator/Ramulator/src/DRAM.h
+++ /dev/null
@@ -1,451 +0,0 @@
-#ifndef __DRAM_H
-#define __DRAM_H
-
-#include "Statistics.h"
-#include <iostream>
-#include <vector>
-#include <deque>
-#include <map>
-#include <functional>
-#include <algorithm>
-#include <cassert>
-#include <type_traits>
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class DRAM
-{
-public:
-    ScalarStat active_cycles;
-    ScalarStat refresh_cycles;
-    ScalarStat busy_cycles;
-    ScalarStat active_refresh_overlap_cycles;
-
-    ScalarStat serving_requests;
-    ScalarStat average_serving_requests;
-
-    // Constructor
-    DRAM(T* spec, typename T::Level level);
-    ~DRAM();
-
-    // Specification (e.g., DDR3)
-    T* spec;
-
-    // Tree Organization (e.g., Channel->Rank->Bank->Row->Column)
-    typename T::Level level;
-    int id;
-    long size;
-    DRAM* parent;
-    vector<DRAM*> children;
-
-    // State (e.g., Opened, Closed)
-    typename T::State state;
-
-    // State of Rows:
-    // There are too many rows for them to be instantiated individually
-    // Instead, their bank (or an equivalent entity) tracks their state for them
-    map<int, typename T::State> row_state;
-
-    // Insert a node as one of my child nodes
-    void insert(DRAM<T>* child);
-
-    // Decode a command into its "prerequisite" command (if any is needed)
-    typename T::Command decode(typename T::Command cmd, const int* addr);
-
-    // Check whether a command is ready to be scheduled
-    bool check(typename T::Command cmd, const int* addr, long clk);
-
-    // Check whether a command is a row hit
-    bool check_row_hit(typename T::Command cmd, const int* addr);
-
-    // Check whether a row is open
-    bool check_row_open(typename T::Command cmd, const int* addr);
-
-    // Return the earliest clock when a command is ready to be scheduled
-    long get_next(typename T::Command cmd, const int* addr);
-
-    // Update the timing/state of the tree, signifying that a command has been issued
-    void update(typename T::Command cmd, const int* addr, long clk);
-    // Update statistics:
-
-    // Update the number of requests it serves currently
-    void update_serving_requests(const int* addr, int delta, long clk);
-
-    // TIANSHI: current serving requests count
-    int cur_serving_requests = 0;
-    long begin_of_serving = -1;
-    long end_of_serving = -1;
-    long begin_of_cur_reqcnt = -1;
-    long begin_of_refreshing = -1;
-    long end_of_refreshing = -1;
-    std::vector<std::pair<long, long>> refresh_intervals;
-
-    // register statistics
-    void regStats(const std::string& identifier);
-
-    void finish(long dram_cycles);
-
-private:
-    // Constructor
-    DRAM(){}
-
-    // Timing
-    long cur_clk = 0;
-    long next[int(T::Command::MAX)]; // the earliest time in the future when a command could be ready
-    deque<long> prev[int(T::Command::MAX)]; // the most recent history of when commands were issued
-
-    // Lookup table for which commands must be preceded by which other commands (i.e., "prerequisite")
-    // E.g., a read command to a closed bank must be preceded by an activate command
-    function<typename T::Command(DRAM<T>*, typename T::Command cmd, int)>* prereq;
-
-    // SAUGATA: added table for row hits
-    // Lookup table for whether a command is a row hit
-    // E.g., a read command to a closed bank must be preceded by an activate command
-    function<bool(DRAM<T>*, typename T::Command cmd, int)>* rowhit;
-    function<bool(DRAM<T>*, typename T::Command cmd, int)>* rowopen;
-
-    // Lookup table between commands and the state transitions they trigger
-    // E.g., an activate command to a closed bank opens both the bank and the row
-    function<void(DRAM<T>*, int)>* lambda;
-
-    // Lookup table for timing parameters
-    // E.g., activate->precharge: tRAS@bank, activate->activate: tRC@bank
-    vector<typename T::TimingEntry>* timing;
-
-    // Helper Functions
-    void update_state(typename T::Command cmd, const int* addr);
-    void update_timing(typename T::Command cmd, const int* addr, long clk);
-}; /* class DRAM */
-
-
-// register statistics
-template <typename T>
-void DRAM<T>::regStats(const std::string& identifier) {
-    active_cycles
-        .name("active_cycles" + identifier + "_" + to_string(id))
-        .desc("Total active cycles for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        ;
-    refresh_cycles
-        .name("refresh_cycles" + identifier + "_" + to_string(id))
-        .desc("(All-bank refresh only, only valid for rank level) The sum of cycles that is under refresh per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        .flags(Stats::nozero)
-        ;
-    busy_cycles
-        .name("busy_cycles" + identifier + "_" + to_string(id))
-        .desc("(All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        ;
-    active_refresh_overlap_cycles
-        .name("active_refresh_overlap_cycles" + identifier + "_" + to_string(id))
-        .desc("(All-bank refresh only, only valid for rank level) The sum of cycles that are both active and under refresh per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        .flags(Stats::nozero)
-        ;
-    serving_requests
-        .name("serving_requests" + identifier + "_" + to_string(id))
-        .desc("The sum of read and write requests that are served in this DRAM element per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        ;
-    average_serving_requests
-        .name("average_serving_requests" + identifier + "_" + to_string(id))
-        .desc("The average of read and write requests that are served in this DRAM element per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(6)
-        ;
-
-    if (!children.size()) {
-      return;
-    }
-
-    // recursively register children statistics
-    for (auto child : children) {
-      child->regStats(identifier + "_" + to_string(id));
-    }
-}
-
-template <typename T>
-void DRAM<T>::finish(long dram_cycles) {
-  // finalize busy cycles
-  busy_cycles = active_cycles.value() + refresh_cycles.value() - active_refresh_overlap_cycles.value();
-
-  // finalize average serving requests
-  average_serving_requests = serving_requests.value() / dram_cycles;
-
-  if (!children.size()) {
-    return;
-  }
-
-  for (auto child : children) {
-    child->finish(dram_cycles);
-  }
-}
-
-// Constructor
-template <typename T>
-DRAM<T>::DRAM(T* spec, typename T::Level level) :
-    spec(spec), level(level), id(0), parent(NULL)
-{
-
-    state = spec->start[(int)level];
-    prereq = spec->prereq[int(level)];
-    rowhit = spec->rowhit[int(level)];
-    rowopen = spec->rowopen[int(level)];
-    lambda = spec->lambda[int(level)];
-    timing = spec->timing[int(level)];
-
-    fill_n(next, int(T::Command::MAX), -1); // initialize future
-    for (int cmd = 0; cmd < int(T::Command::MAX); cmd++) {
-        int dist = 0;
-        for (auto& t : timing[cmd])
-            dist = max(dist, t.dist);
-
-        if (dist)
-            prev[cmd].resize(dist, -1); // initialize history
-    }
-
-    // try to recursively construct my children
-    int child_level = int(level) + 1;
-    if (child_level == int(T::Level::Row))
-        return; // stop recursion: rows are not instantiated as nodes
-
-    int child_max = spec->org_entry.count[child_level];
-    if (!child_max)
-        return; // stop recursion: the number of children is unspecified
-
-    // recursively construct my children
-    for (int i = 0; i < child_max; i++) {
-        DRAM<T>* child = new DRAM<T>(spec, typename T::Level(child_level));
-        child->parent = this;
-        child->id = i;
-        children.push_back(child);
-    }
-
-}
-
-template <typename T>
-DRAM<T>::~DRAM()
-{
-    for (auto child: children)
-        delete child;
-}
-
-// Insert
-template <typename T>
-void DRAM<T>::insert(DRAM<T>* child)
-{
-    child->parent = this;
-    child->id = children.size();
-    children.push_back(child);
-}
-
-// Decode
-template <typename T>
-typename T::Command DRAM<T>::decode(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (prereq[int(cmd)]) {
-        typename T::Command prereq_cmd = prereq[int(cmd)](this, cmd, child_id);
-        if (prereq_cmd != T::Command::MAX)
-            return prereq_cmd; // stop recursion: there is a prerequisite at this level
-    }
-
-    if (child_id < 0 || !children.size())
-        return cmd; // stop recursion: there were no prequisites at any level
-
-    // recursively decode at my child
-    return children[child_id]->decode(cmd, addr);
-}
-
-
-// Check
-template <typename T>
-bool DRAM<T>::check(typename T::Command cmd, const int* addr, long clk)
-{
-    if (next[int(cmd)] != -1 && clk < next[int(cmd)])
-        return false; // stop recursion: the check failed at this level
-
-    int child_id = addr[int(level)+1];
-    if (child_id < 0 || level == spec->scope[int(cmd)] || !children.size())
-        return true; // stop recursion: the check passed at all levels
-
-    // recursively check my child
-    return children[child_id]->check(cmd, addr, clk);
-}
-
-// SAUGATA: added function to check whether a command is a row hit
-// Check row hits
-template <typename T>
-bool DRAM<T>::check_row_hit(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (rowhit[int(cmd)]) {
-        return rowhit[int(cmd)](this, cmd, child_id);  // stop recursion: there is a row hit at this level
-    }
-
-    if (child_id < 0 || !children.size())
-        return false; // stop recursion: there were no row hits at any level
-
-    // recursively check for row hits at my child
-    return children[child_id]->check_row_hit(cmd, addr);
-}
-
-template <typename T>
-bool DRAM<T>::check_row_open(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (rowopen[int(cmd)]) {
-        return rowopen[int(cmd)](this, cmd, child_id);  // stop recursion: there is a row hit at this level
-    }
-
-    if (child_id < 0 || !children.size())
-        return false; // stop recursion: there were no row hits at any level
-
-    // recursively check for row hits at my child
-    return children[child_id]->check_row_open(cmd, addr);
-}
-
-template <typename T>
-long DRAM<T>::get_next(typename T::Command cmd, const int* addr)
-{
-    long next_clk = max(cur_clk, next[int(cmd)]);
-    auto node = this;
-    for (int l = int(level); l < int(spec->scope[int(cmd)]) && node->children.size() && addr[l + 1] >= 0; l++){
-        node = node->children[addr[l + 1]];
-        next_clk = max(next_clk, node->next[int(cmd)]);
-    }
-    return next_clk;
-}
-
-// Update
-template <typename T>
-void DRAM<T>::update(typename T::Command cmd, const int* addr, long clk)
-{
-    cur_clk = clk;
-    update_state(cmd, addr);
-    update_timing(cmd, addr, clk);
-}
-
-
-// Update (State)
-template <typename T>
-void DRAM<T>::update_state(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (lambda[int(cmd)])
-        lambda[int(cmd)](this, child_id); // update this level
-
-    if (level == spec->scope[int(cmd)] || !children.size())
-        return; // stop recursion: updated all levels
-
-    // recursively update my child
-    children[child_id]->update_state(cmd, addr);
-}
-
-
-// Update (Timing)
-template <typename T>
-void DRAM<T>::update_timing(typename T::Command cmd, const int* addr, long clk)
-{
-    // I am not a target node: I am merely one of its siblings
-    if (id != addr[int(level)]) {
-        for (auto& t : timing[int(cmd)]) {
-            if (!t.sibling)
-                continue; // not an applicable timing parameter
-
-            assert (t.dist == 1);
-
-            long future = clk + t.val;
-            next[int(t.cmd)] = max(next[int(t.cmd)], future); // update future
-        }
-
-        return; // stop recursion: only target nodes should be recursed
-    }
-
-    // I am a target node
-    if (prev[int(cmd)].size()) {
-        prev[int(cmd)].pop_back();  // FIXME TIANSHI why pop back?
-        prev[int(cmd)].push_front(clk); // update history
-    }
-
-    for (auto& t : timing[int(cmd)]) {
-        if (t.sibling)
-            continue; // not an applicable timing parameter
-
-        long past = prev[int(cmd)][t.dist-1];
-        if (past < 0)
-            continue; // not enough history
-
-        long future = past + t.val;
-        next[int(t.cmd)] = max(next[int(t.cmd)], future); // update future
-        // TIANSHI: for refresh statistics
-        if (spec->is_refreshing(cmd) && spec->is_opening(t.cmd)) {
-          assert(past == clk);
-          begin_of_refreshing = clk;
-          end_of_refreshing = max(end_of_refreshing, next[int(t.cmd)]);
-          refresh_cycles += end_of_refreshing - clk;
-          if (cur_serving_requests > 0) {
-            refresh_intervals.push_back(make_pair(begin_of_refreshing, end_of_refreshing));
-          }
-        }
-    }
-
-    // Some commands have timings that are higher that their scope levels, thus
-    // we do not stop at the cmd's scope level
-    if (!children.size())
-        return; // stop recursion: updated all levels
-
-    // recursively update *all* of my children
-    for (auto child : children)
-        child->update_timing(cmd, addr, clk);
-
-}
-
-template <typename T>
-void DRAM<T>::update_serving_requests(const int* addr, int delta, long clk) {
-  assert(id == addr[int(level)]);
-  assert(delta == 1 || delta == -1);
-  // update total serving requests
-  if (begin_of_cur_reqcnt != -1 && cur_serving_requests > 0) {
-    serving_requests += (clk - begin_of_cur_reqcnt) * cur_serving_requests;
-    active_cycles += clk - begin_of_cur_reqcnt;
-  }
-  // update begin of current request number
-  begin_of_cur_reqcnt = clk;
-  cur_serving_requests += delta;
-  assert(cur_serving_requests >= 0);
-
-  if (delta == 1 && cur_serving_requests == 1) {
-    // transform from inactive to active
-    begin_of_serving = clk;
-    if (end_of_refreshing > begin_of_serving) {
-      active_refresh_overlap_cycles += end_of_refreshing - begin_of_serving;
-    }
-  } else if (cur_serving_requests == 0) {
-    // transform from active to inactive
-    assert(begin_of_serving != -1);
-    assert(delta == -1);
-    active_cycles += clk - begin_of_cur_reqcnt;
-    end_of_serving = clk;
-
-    for (const auto& ref: refresh_intervals) {
-      active_refresh_overlap_cycles += min(end_of_serving, ref.second) - ref.first;
-    }
-    refresh_intervals.clear();
-  }
-
-  int child_id = addr[int(level) + 1];
-  // We only count the level bank or the level higher than bank
-  if (child_id < 0 || !children.size() || (int(level) > int(T::Level::Bank)) ) {
-    return;
-  }
-  children[child_id]->update_serving_requests(addr, delta, clk);
-}
-
-} /* namespace ramulator */
-
-#endif /* __DRAM_H */
diff --git a/ext/ramulator/Ramulator/src/DSARP.cpp b/ext/ramulator/Ramulator/src/DSARP.cpp
deleted file mode 100644
index 803f96a7a..000000000
--- a/ext/ramulator/Ramulator/src/DSARP.cpp
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * DSARP.cpp
- *
- * This a re-implementation of the refresh mechanisms proposed in Chang et al.,
- * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA
- * 2014.
- *
- *  Created on: Mar 16, 2015
- *      Author: kevincha
- */
-
-#include <vector>
-#include <functional>
-#include <cassert>
-#include <math.h>
-#include "DSARP.h"
-#include "DRAM.h"
-
-using namespace std;
-using namespace ramulator;
-
-string DSARP::standard_name = "DSARP";
-string DSARP::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Sa", "Ro", "Co"};
-
-map<string, enum DSARP::Org> DSARP::org_map = {
-  {"DSARP_8Gb_x8", DSARP::Org::DSARP_8Gb_x8},
-  {"DSARP_16Gb_x9", DSARP::Org::DSARP_16Gb_x8},
-  {"DSARP_32Gb_x8", DSARP::Org::DSARP_32Gb_x8},
-};
-
-map<string, enum DSARP::Speed> DSARP::speed_map = {
-  {"DSARP_1333", DSARP::Speed::DSARP_1333},
-};
-
-DSARP::DSARP(Org org, Speed speed, Type type, int n_sa) :
-  type(type),
-  org_entry(org_table[int(org)]),
-  speed_entry(speed_table[int(speed)]),
-  read_latency(speed_entry.nCL + speed_entry.nBL),
-  n_sa(n_sa)
-{
-  init_speed();
-  init_prereq();
-  init_rowhit(); // SAUGATA: added row hit function
-  init_rowopen();
-  init_lambda();
-  init_timing();
-
-  // All mechanisms are built on top of REFpb, except for REFab
-  b_ref_rank = false;
-  switch(int(type)){
-    case int(Type::REFAB):
-      standard_name = "REFAB";
-      b_ref_rank = true;
-      break;
-    case int(Type::REFPB): standard_name = "REFPB"; break;
-    case int(Type::DARP):  standard_name = "DARP"; break;
-    case int(Type::SARP):  standard_name = "SARP"; break;
-    case int(Type::DSARP): standard_name = "DSARP"; break;
-  }
-
-  // Update the SA count (is power of 2, within [1, 128]) and row count
-  assert(n_sa && n_sa <= 128 && (n_sa & (n_sa-1)) == 0);
-  org_entry.count[int(Level::SubArray)] = n_sa;
-  long tmp = long(org_entry.dq) * org_entry.count[int(Level::Bank)] *
-    n_sa * org_entry.count[int(Level::Column)];
-  org_entry.count[int(Level::Row)] = long(org_entry.size) * (1<<20) / tmp;
-
-  // Change the translation for refresh requests
-  if (!b_ref_rank)
-    translate[int(Request::Type::REFRESH)] = Command::REFPB;
-}
-
-DSARP::DSARP(const string& org_str, const string& speed_str, Type type, int n_sa) :
-  DSARP(org_map[org_str], speed_map[speed_str], type, n_sa) {}
-
-void DSARP::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void DSARP::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-
-void DSARP::init_speed()
-{
-  /* Numbers are in DRAM cycles */
-
-  // The numbers for RFCab are extrapolated based on past and current DRAM
-  // generation since they are not available yet. Details on the extrapolation
-  // are in the paper.
-  const static int RFCAB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-    {234}, {354}, {594},
-  };
-
-  // These are extrapolated using the RFCab/REFpb ratio from the LPDDR standard, which is 2.16.
-  const static int RFCPB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-    {109}, {164}, {275}
-  };
-
-  // High temperature mode (32ms retention time)
-  const static int REFI_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-    {2600},
-  };
-
-  const static int REFIPB_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-    {325},
-  };
-
-  int speed = 0, density = 0;
-  switch (speed_entry.rate) {
-    case 1333: speed = 0; break;
-    default: assert(false);
-  };
-  switch (org_entry.size >> 10){
-    case 8: density = 0; break;
-    case 16: density = 1; break;
-    case 32: density = 2; break;
-    default: assert(false && "Unknown density");
-  }
-
-  speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-  speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-  speed_entry.nREFI = REFI_TABLE[int(refresh_mode)][speed];
-  speed_entry.nREFIpb = REFIPB_TABLE[int(refresh_mode)][speed];
-}
-
-void DSARP::init_prereq()
-{
-  // RD
-  prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::PowerUp): return Command::MAX;
-      case int(State::ActPowerDown): return Command::PDX;
-      case int(State::PrePowerDown): return Command::PDX;
-      case int(State::SelfRefresh): return Command::SRX;
-      default: assert(false);
-    }};
-  // Rank transitions to Bank
-  prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::Closed): return Command::ACT;
-      case int(State::Opened):
-        // Really is the subarray state. If the subarray matches, check the row ID
-        if (node->row_state.find(id) != node->row_state.end())
-          return Command::MAX;
-        return Command::PRE;
-      default: assert(false);
-    }};
-  // Bank transitions to Subarray
-  prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::Closed): return Command::ACT;
-      case int(State::Opened):
-        // Actual row state
-        if (node->row_state.find(id) != node->row_state.end())
-          return cmd;
-        return Command::PRE;
-      default: assert(false);
-    }};
-
-  // WR
-  prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-  prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-  prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-
-  // REF -- on all banks
-  prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    for (auto bank : node->children) {
-      if (bank->state == State::Closed)
-        continue;
-      return Command::PREA;
-    }
-    return Command::REF;};
-
-  // REF -- per bank
-  prereq[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    if (node->state == State::Closed) return Command::REFPB;
-    else return Command::PRE;};
-
-  // PD
-  prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::PowerUp): return Command::PDE;
-      case int(State::ActPowerDown): return Command::PDE;
-      case int(State::PrePowerDown): return Command::PDE;
-      case int(State::SelfRefresh): return Command::SRX;
-      default: assert(false);
-    }};
-
-  // SR
-  prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::PowerUp): return Command::SRE;
-      case int(State::ActPowerDown): return Command::PDX;
-      case int(State::PrePowerDown): return Command::PDX;
-      case int(State::SelfRefresh): return Command::SRE;
-      default: assert(false);
-    }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void DSARP::init_rowhit()
-{
-  // RD
-  rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-      switch (int(node->state)){
-          case int(State::Closed): return false;
-          case int(State::Opened):
-              if (node->row_state.find(id) != node->row_state.end()) return true;
-              else return false;
-          default: assert(false);
-      }};
-  // WR
-  rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-}
-
-void DSARP::init_rowopen()
-{
-  // RD
-  rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-      switch (int(node->state)){
-          case int(State::Closed): return false;
-          case int(State::Opened): return true;
-          default: assert(false);
-      }};
-  // WR
-  rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-}
-
-void DSARP::init_lambda()
-{
-  // RANK
-  lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DSARP>* node, int id) {
-    node->row_state.clear();
-    for (auto bank : node->children) {
-      bank->state = State::Closed;
-      bank->row_state.clear();
-      for (auto sa : bank->children){
-        sa->state = State::Closed;
-        sa->row_state.clear();}}};
-  lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DSARP>* node, int id) {};
-
-  // Power down related commands
-  lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, int id) {
-    for (auto bank : node->children) {
-      if (bank->state == State::Closed)
-        continue;
-      node->state = State::ActPowerDown;
-      return;
-    }
-    node->state = State::PrePowerDown;};
-  lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::PowerUp;};
-  lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::SelfRefresh;};
-  lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::PowerUp;};
-
-  // Open a row
-  lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Opened;
-    node->row_state[id] = State::Opened;};
-  lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Opened;
-    node->row_state[id] = State::Opened;};
-
-  // Close a bank
-  lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();
-    for (auto sa : node->children){
-      sa->state = State::Closed;
-      sa->row_state.clear();}};
-
-  lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DSARP>* node, int id) {};
-  lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DSARP>* node, int id) {};
-
-  // Make sure the bank is closed after the column command
-  lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-
-  lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-
-  // Nothing much, just make sure the bank is closed
-  lambda[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<DSARP>* node, int id) {
-    assert(node->state == State::Closed);
-    node->row_state.clear();};
-
-  // COL
-  lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-  lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-
-  // PowerDown -- this has not been tested
-  lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, int id) {
-    for (auto bank : node->children)
-      for (auto sa : bank->children) {
-        if (sa->state == State::Closed)
-          continue;
-        node->state = State::ActPowerDown;
-        return;
-      }
-    node->state = State::PrePowerDown;};
-}
-
-void DSARP::init_timing()
-{
-  SpeedEntry& s = speed_entry;
-  vector<TimingEntry> *t;
-
-  /*** Channel ***/
-  t = timing[int(Level::Channel)];
-
-  // CAS <-> CAS
-  t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-  t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-  t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-  t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-  t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-  t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-  t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-  /*** Rank ***/
-  t = timing[int(Level::Rank)];
-
-  // CAS <-> CAS
-  t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-  t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-  t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-  t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-  t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-  t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-  t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-
-  // READ to WRITE
-  t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-  t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-  t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-
-  // WRITE to READ
-  t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-  t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-  t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-  t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-  // CAS <-> CAS (between sibling ranks)
-  t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-
-  t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-  t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-  t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-  t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-  // CAS <-> PREA
-  t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-  t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-  // CAS <-> PD
-  t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-  t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-  t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-  t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-  t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-  // RAS <-> RAS
-  t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-  t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-  t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-  t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRPab});
-
-  // RAS <-> REF
-  t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-  t[int(Command::PREA)].push_back({Command::REF, 1, s.nRPab});
-  t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-  // RAS <-> PD
-  t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-  t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-  // RAS <-> SR
-  t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRPpb});
-  t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRPab});
-  t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-  // REF <-> REF
-  t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-  t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-  t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-  // REF <-> PD
-  t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-  t[int(Command::REFPB)].push_back({Command::PDE, 1, 1});
-  t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-  // REF <-> SR
-  t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-  t[int(Command::SRX)].push_back({Command::REFPB, 1, s.nXS});
-
-  // PD <-> PD
-  t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-  t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-  // PD <-> SR
-  t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-  t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-  // SR <-> SR
-  t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-  t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-  // REFPB
-  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb });
-
-  /*** Bank ***/
-  t = timing[int(Level::Bank)];
-
-  // CAS <-> RAS
-  t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-  t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-  t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-  t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-  t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-  t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-  t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-  t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-
-  // RAS <-> RAS
-  t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-  t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-  t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-  t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-  // Cannot overlap REFPB
-  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb });
-
-  // B/w banks
-  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb, true});
-  t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-  t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-  // REFPB -- these are used when SARP is not enabled
-  if (!(type == Type::DSARP || type == Type::SARP)) {
-    t[int(Command::REFPB)].push_back( { Command::ACT, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::RD, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::RDA, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::WR, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::WRA, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::PRE, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::PREA, 1, s.nRFCpb });
-  }
-
-  /*** SubArray ***/
-  if (type == Type::DSARP || type == Type::SARP) {
-    t = timing[int(Level::SubArray)];
-
-    // between different subarrays -> Increase RRD
-    t[int(Command::ACT)].push_back({Command::REFPB, 1,
-        (int)ceil(((double)s.nRRD)*nRRD_factor), true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1,
-        (int)ceil(((double)s.nRRD)*nRRD_factor), true});
-
-    // Same subarray
-    t[int(Command::REF)].push_back( { Command::ACT, 1, s.nRFCab });
-    t[int(Command::REFPB)].push_back( { Command::ACT, 1, s.nRFCpb });
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back( { Command::RD, 1, s.nRCD });
-    t[int(Command::ACT)].push_back( { Command::RDA, 1, s.nRCD });
-    t[int(Command::ACT)].push_back( { Command::WR, 1, s.nRCD });
-    t[int(Command::ACT)].push_back( { Command::WRA, 1, s.nRCD });
-
-    t[int(Command::RD)].push_back( { Command::PRE, 1, s.nRTP });
-    t[int(Command::WR)].push_back(
-        { Command::PRE, 1, s.nCWL + s.nBL + s.nWR });
-
-    t[int(Command::RDA)].push_back( { Command::ACT, 1, s.nRTP + s.nRPpb });
-    t[int(Command::WRA)].push_back(
-        { Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb });
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back( { Command::ACT, 1, s.nRC });
-    t[int(Command::ACT)].push_back( { Command::PRE, 1, s.nRAS });
-    t[int(Command::PRE)].push_back( { Command::ACT, 1, s.nRPpb });
-    t[int(Command::PRE)].push_back( { Command::REFPB, 1, s.nRPpb });
-    t[int(Command::PRE)].push_back( { Command::REF, 1, s.nRPpb });
-
-    // Enforcing timings such that there's no subarray parallelism
-    // between sibling subarrays for demand requests
-    t[int(Command::ACT)].push_back( { Command::ACT, 1, s.nRC, true });
-    t[int(Command::PRE)].push_back( { Command::ACT, 1, s.nRPpb, true });
-    t[int(Command::RDA)].push_back( { Command::ACT, 1, s.nRTP + s.nRPpb,
-        true });
-    t[int(Command::WRA)].push_back(
-        { Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb, true });
-  }
-}
diff --git a/ext/ramulator/Ramulator/src/DSARP.h b/ext/ramulator/Ramulator/src/DSARP.h
deleted file mode 100644
index be02e71e3..000000000
--- a/ext/ramulator/Ramulator/src/DSARP.h
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * DSARP.h
- *
- * This a re-implementation of the refresh mechanisms proposed in Chang et al.,
- * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA
- * 2014.
- *
- * Note: the re-implementation of DSARP has not been widely tested across
- * different benchmarks and parameters. However, timing violations of
- * SARP/DSARP have been checked.
- *
- * Usage: The "type" determines the refresh mechanisms.
- * Examples:
- * DSARP::Org test_org = DSARP::Org::DSARP_8Gb_x8;
- *
- * DSARP* dsddr3_ab = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::REFAB, 8);
- *
- * DSARP* dsddr3_pb = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::REFPB, 8);
- *
- * DSARP* dsddr3_darp = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::DARP, 8);
- *
- * DSARP* dsddr3_sarp = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::SARP, 8);
- *
- * DSARP* dsddr3_dsarp = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::DSARP, 8);
- *
- *  Created on: Mar 16, 2015
- *      Author: kevincha
- */
-
-#ifndef DSARP_H_
-#define DSARP_H_
-
-#include <vector>
-#include <functional>
-#include "DRAM.h"
-#include "Request.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DSARP
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    enum class Type;
-    DSARP(Org org, Speed speed, Type type, int n_sa);
-    DSARP(const string& org_str, const string& speed_str, Type type, int n_sa);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    enum class Type : int
-    {
-        REFAB, REFPB, DARP, SARP, DSARP, MAX
-    } type;
-
-    /* Level */
-    // NOTE: Although there's subarray, there's no SALP at all. This is used
-    // for parallelizing REF and demand accesses.
-    enum class Level : int
-    {
-      Channel, Rank, Bank, SubArray, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, REFPB, PDE, PDX, SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "REFPB",
-        "PDE", "PDX", "SRE", "SRX"
-    };
-
-    // SubArray scope for REFPB to propagate the timings
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<DSARP>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DSARP>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DSARP>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DSARP>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        // These are the configurations used in the original paper, essentially DDR3
-        DSARP_8Gb_x8,
-        DSARP_16Gb_x8,
-        DSARP_32Gb_x8,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        // IMPORTANT: Do not change the count for channel/rank, where is set to
-        // 0 now. 0 means that this a flexible configuration that is not part
-        // of the spec, but rather something to change at a higher level
-        // (main.cpp).
-        {8<<10, 8,  {0, 0, 8, 0, 1<<16, 1<<11}},
-        {16<<10, 8, {0, 0, 8, 0, 1<<17, 1<<11}},
-        {32<<10, 8, {0, 0, 8, 0, 1<<18, 1<<11}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DSARP_1333,
-        MAX
-    };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 16; // 16n prefetch DDR
-    int channel_width = 32;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRPpb, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI, nREFIpb;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-        //int nCKE, nXP; // CKE value n/a
-        //int nSR, nXSR; // tXSR = tRFCab + 7.5ns
-    } speed_table[int(Speed::MAX)] = {
-      {1333,
-      (400.0/3)*5, (3/0.4)/5,
-       4, 4, 2,
-       9, 9, 8, 9, 7,
-       24, 33,
-       5, 5, 10,
-       5, 30,
-       0, 0, 0, 0, // set in DSARP.cpp
-       4, 4, 16,
-       5, 114, 512},
-    }, speed_entry;
-
-    int read_latency;
-
-    // Number of subarrays -- mainly for SARP. Doesn't affect others.
-    int n_sa;
-
-    // Refresh rank?
-    bool b_ref_rank;
-
-    // Increase RRD b/w REF and ACT when they go to the same bank (SARP)
-    double nRRD_factor = 1.138;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /* DSARP_H_ */
diff --git a/ext/ramulator/Ramulator/src/GDDR5.cpp b/ext/ramulator/Ramulator/src/GDDR5.cpp
deleted file mode 100644
index 45a17e99b..000000000
--- a/ext/ramulator/Ramulator/src/GDDR5.cpp
+++ /dev/null
@@ -1,357 +0,0 @@
-#include "GDDR5.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string GDDR5::standard_name = "GDDR5";
-string GDDR5::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-
-
-map<string, enum GDDR5::Org> GDDR5::org_map = {
-    {"GDDR5_512Mb_x16", GDDR5::Org::GDDR5_512Mb_x16}, {"GDDR5_512Mb_x32", GDDR5::Org::GDDR5_512Mb_x32},
-    {"GDDR5_1Gb_x16", GDDR5::Org::GDDR5_1Gb_x16}, {"GDDR5_1Gb_x32", GDDR5::Org::GDDR5_1Gb_x32},
-    {"GDDR5_2Gb_x16", GDDR5::Org::GDDR5_2Gb_x16}, {"GDDR5_2Gb_x32", GDDR5::Org::GDDR5_2Gb_x32},
-    {"GDDR5_4Gb_x16", GDDR5::Org::GDDR5_4Gb_x16}, {"GDDR5_4Gb_x32", GDDR5::Org::GDDR5_4Gb_x32},
-    {"GDDR5_8Gb_x16", GDDR5::Org::GDDR5_8Gb_x16}, {"GDDR5_8Gb_x32", GDDR5::Org::GDDR5_8Gb_x32},
-};
-
-map<string, enum GDDR5::Speed> GDDR5::speed_map = {
-    {"GDDR5_4000", GDDR5::Speed::GDDR5_4000}, {"GDDR5_4500", GDDR5::Speed::GDDR5_4500},
-    {"GDDR5_5000", GDDR5::Speed::GDDR5_5000}, {"GDDR5_5500", GDDR5::Speed::GDDR5_5500},
-    {"GDDR5_6000", GDDR5::Speed::GDDR5_6000}, {"GDDR5_6500", GDDR5::Speed::GDDR5_6500},
-    {"GDDR5_7000", GDDR5::Speed::GDDR5_7000},
-};
-
-GDDR5::GDDR5(Org org, Speed speed) : 
-    org_entry(org_table[int(org)]), 
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-GDDR5::GDDR5(const string& org_str, const string& speed_str) :
-    GDDR5(org_map[org_str], speed_map[speed_str]) 
-{
-}
-
-void GDDR5::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void GDDR5::set_rank_number(int rank) {
-  assert((rank == 1) && "GDDR5 rank number is fixed to 1.");
-}
-
-void GDDR5::init_speed()
-{
-    const int REFIL_TABLE[int(Speed::MAX)] = {3900, 4388, 4875, 5363, 5850, 6338, 6825};
-    const int REFIS_TABLE[int(Speed::MAX)] = {1900, 2138, 2375, 2613, 2850, 3088, 3325};
-    const int RFC_TABLE[5][int(Speed::MAX)] = {
-        // using DDR3 values
-        {90, 102, 113, 124, 135, 147, 158},
-        {110, 124, 138, 152, 165, 179, 193},
-        {160, 180, 200, 220, 240, 260, 280},
-        {260, 293, 325, 358, 390, 423, 455},
-        {350, 394, 438, 482, 525, 569, 613}
-    };
-    int speed = 0, density = 0;
-    switch (speed_entry.rate){
-        case 4000: speed = 0; break;
-        case 4500: speed = 1; break;
-        case 5000: speed = 2; break;
-        case 5500: speed = 3; break;
-        case 6000: speed = 4; break;
-        case 6500: speed = 5; break;
-        case 7000: speed = 6; break;
-        default: assert(0);
-    }
-    switch (org_entry.size >> 9){
-        case 1: density = 0; break;
-        case 2: density = 1; break;
-        case 4: density = 2; break;
-        case 8: density = 3; break;
-        case 16: density = 4; break;
-        default: assert(0);
-    }
-    if (org_entry.size <= 1024) speed_entry.nREFI = REFIL_TABLE[speed];
-    else speed_entry.nREFI = REFIS_TABLE[speed];
-    speed_entry.nRFC = RFC_TABLE[density][speed];
-}
-
-
-void GDDR5::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                return Command::PREA;
-            }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void GDDR5::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void GDDR5::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void GDDR5::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<GDDR5>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                bank->state = State::Closed;
-                bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<GDDR5>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<GDDR5>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<GDDR5>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                node->state = State::ActPowerDown;
-                return;
-            }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void GDDR5::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXPN});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::ACT, 32, s.n32AW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nPPD});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXPN});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXPN});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-    
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXPN});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXPN});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-    
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    // Bank group level
-    t = timing[int(Level::BankGroup)];
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCDW});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCDW});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/GDDR5.h b/ext/ramulator/Ramulator/src/GDDR5.h
deleted file mode 100644
index 23e929d33..000000000
--- a/ext/ramulator/Ramulator/src/GDDR5.h
+++ /dev/null
@@ -1,213 +0,0 @@
-#ifndef __GDDR5_H
-#define __GDDR5_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class GDDR5
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    GDDR5(Org org, Speed speed);
-    GDDR5(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<GDDR5>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<GDDR5>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<GDDR5>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<GDDR5>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        GDDR5_512Mb_x16, GDDR5_512Mb_x32,
-        GDDR5_1Gb_x16,   GDDR5_1Gb_x32,
-        GDDR5_2Gb_x16,   GDDR5_2Gb_x32,
-        GDDR5_4Gb_x16,   GDDR5_4Gb_x32,
-        GDDR5_8Gb_x16,   GDDR5_8Gb_x32,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        // fixed to have 1 rank
-        // in GDDR5 the column address is unique for a burst. e.g. 64 column addresses correspond with
-        // 256 column addresses actually. So we multiply 8 to the original address bit number in JEDEC standard
-        {  512, 16, {0, 1, 4, 2, 1<<12, 1<<(7+3)}}, {  512, 32, {0, 1, 4, 2, 1<<12, 1<<(6+3)}},
-        {1<<10, 16, {0, 1, 4, 4, 1<<12, 1<<(7+3)}}, {1<<10, 32, {0, 1, 4, 4, 1<<12, 1<<(6+3)}},
-        {2<<10, 16, {0, 1, 4, 4, 1<<13, 1<<(7+3)}}, {2<<10, 32, {0, 1, 4, 4, 1<<13, 1<<(6+3)}},
-        {4<<10, 16, {0, 1, 4, 4, 1<<14, 1<<(7+3)}}, {2<<10, 32, {0, 1, 4, 4, 1<<14, 1<<(6+3)}},
-        {8<<10, 16, {0, 1, 4, 4, 1<<14, 1<<(8+3)}}, {8<<10, 32, {0, 1, 4, 4, 1<<14, 1<<(7+3)}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        GDDR5_4000, GDDR5_4500,
-        GDDR5_5000, GDDR5_5500,
-        GDDR5_6000, GDDR5_6500,
-        GDDR5_7000,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch QDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL;
-        int nCL, nRCDR, nRCDW, nRP, nCWL;
-        int nRAS, nRC;
-        int nPPD, nRTP, nWTR, nWR;
-        int nRRD, nFAW, n32AW;
-        int nRFC, nREFI;
-        int nPD, nXPN, nLK;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-        {4000,  8*500/4,  8.0/8, 2, 2, 3, 12, 12, 10, 12, 3, 28, 40, 1, 2, 5, 12,  6, 23, 184, 0, 0, 10, 10, 0, 0, 0, 0},
-        {4500,  9*500/4,  8.0/9, 2, 2, 3, 14, 14, 12, 14, 4, 32, 46, 2, 2, 6, 14,  7, 26, 207, 0, 0, 10, 10, 0, 0, 0, 0},
-        {5000, 10*500/4, 8.0/10, 2, 2, 3, 15, 15, 13, 15, 4, 35, 50, 2, 2, 7, 15,  7, 29, 230, 0, 0, 10, 10, 0, 0, 0, 0},
-        {5500, 11*500/4, 8.0/11, 2, 2, 3, 17, 17, 14, 17, 5, 39, 56, 2, 2, 7, 17,  8, 32, 253, 0, 0, 10, 10, 0, 0, 0, 0},
-        {6000, 12*500/4, 8.0/12, 2, 2, 3, 18, 18, 15, 18, 5, 42, 60, 2, 2, 8, 18,  9, 35, 276, 0, 0, 10, 10, 0, 0, 0, 0},
-        {6500, 13*500/4, 8.0/13, 2, 2, 3, 20, 20, 17, 20, 5, 46, 66, 2, 2, 9, 20,  9, 38, 299, 0, 0, 10, 10, 0, 0, 0, 0},
-        {7000, 14*500/4, 8.0/14, 2, 2, 3, 21, 21, 18, 21, 6, 49, 70, 2, 2, 9, 21, 10, 41, 322, 0, 0, 10, 10, 0, 0, 0, 0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__GDDR5_H*/
diff --git a/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp b/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp
deleted file mode 100644
index 780c12ebd..000000000
--- a/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-#include <map>
-
-#include "Gem5Wrapper.h"
-#include "Config.h"
-#include "Request.h"
-#include "MemoryFactory.h"
-#include "Memory.h"
-#include "DDR3.h"
-#include "DDR4.h"
-#include "LPDDR3.h"
-#include "LPDDR4.h"
-#include "GDDR5.h"
-#include "WideIO.h"
-#include "WideIO2.h"
-#include "HBM.h"
-#include "SALP.h"
-
-using namespace ramulator;
-
-static map<string, function<MemoryBase *(const Config&, int, bool)> > name_to_func = {
-    {"DDR3", &MemoryFactory<DDR3>::create},
-    {"DDR4", &MemoryFactory<DDR4>::create},
-    {"LPDDR3", &MemoryFactory<LPDDR3>::create},
-    {"LPDDR4", &MemoryFactory<LPDDR4>::create},
-    {"GDDR5", &MemoryFactory<GDDR5>::create}, 
-    {"WideIO", &MemoryFactory<WideIO>::create},
-    {"WideIO2", &MemoryFactory<WideIO2>::create},
-    {"HBM", &MemoryFactory<HBM>::create},
-    {"SALP-1", &MemoryFactory<SALP>::create},
-    {"SALP-2", &MemoryFactory<SALP>::create},
-    {"SALP-MASA", &MemoryFactory<SALP>::create},
-};
-
-
-Gem5Wrapper::Gem5Wrapper(const Config& configs, int cacheline)
-{
-    const string& std_name = configs["standard"];
-    assert(name_to_func.find(std_name) != name_to_func.end() && "unrecognized standard name");
-    mem = name_to_func[std_name](configs, cacheline, false);
-    tCK = mem->clk_ns();
-    // daz3:  one wrapper
-    tickCount = 0;
-}
-
-
-Gem5Wrapper::~Gem5Wrapper() {
-    delete mem;
-}
-
-void Gem5Wrapper::tick()
-{
-    // mem->tick();
-    // daz3
-    if(tickCount % 2 == 0)
-    {
-        mem->tick();
-    }
-    tickCount++;
-}
-
-bool Gem5Wrapper::send(Request req)
-{
-  return mem->send(req);
-}
-
-void Gem5Wrapper::finish(void) {
-    mem->finish();
-}
diff --git a/ext/ramulator/Ramulator/src/Gem5Wrapper.h b/ext/ramulator/Ramulator/src/Gem5Wrapper.h
deleted file mode 100644
index 0745d38f3..000000000
--- a/ext/ramulator/Ramulator/src/Gem5Wrapper.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef __GEM5_WRAPPER_H
-#define __GEM5_WRAPPER_H
-
-#include <string>
-
-#include "Config.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-class Request;
-class MemoryBase;
-
-class Gem5Wrapper 
-{
-private:
-    MemoryBase *mem;
-// daz3: one wrapper
-    long tickCount;
-public:
-    double tCK;
-    Gem5Wrapper(const Config& configs, int cacheline);
-    ~Gem5Wrapper();
-    void tick();
-    bool send(Request req);
-    void finish(void);
-};
-
-} /*namespace ramulator*/
-
-#endif /*__GEM5_WRAPPER_H*/
diff --git a/ext/ramulator/Ramulator/src/HBM.cpp b/ext/ramulator/Ramulator/src/HBM.cpp
deleted file mode 100644
index 8ba7ef6af..000000000
--- a/ext/ramulator/Ramulator/src/HBM.cpp
+++ /dev/null
@@ -1,360 +0,0 @@
-#include "HBM.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string HBM::standard_name = "HBM";
-string HBM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-
-map<string, enum HBM::Org> HBM::org_map = {
-    {"HBM_1Gb", HBM::Org::HBM_1Gb},
-    {"HBM_2Gb", HBM::Org::HBM_2Gb},
-    {"HBM_4Gb", HBM::Org::HBM_4Gb},
-};
-
-map<string, enum HBM::Speed> HBM::speed_map = {
-    {"HBM_1Gbps", HBM::Speed::HBM_1Gbps},
-};
-
-HBM::HBM(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-HBM::HBM(const string& org_str, const string& speed_str) :
-    HBM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void HBM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void HBM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-
-void HBM::init_speed()
-{
-    const static int RFC_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {55, 80, 130}
-    };
-    const static int REFI1B_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {64, 128, 256}
-    };
-    const static int XS_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {60, 85, 135}
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1000: speed = 0; break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 1: density = 0; break;
-        case 2: density = 1; break;
-        case 4: density = 2; break;
-        default: assert(false);
-    }
-    speed_entry.nRFC = RFC_TABLE[speed][density];
-    speed_entry.nREFI1B = REFI1B_TABLE[speed][density];
-    speed_entry.nXS = XS_TABLE[speed][density];
-}
-
-
-void HBM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                else return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        for (auto bg : node->children)
-            for (auto bank: bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                return Command::PREA;
-            }
-        return Command::REF;};
-
-    // REFSB
-    prereq[int(Level::Bank)][int(Command::REFSB)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        if (node->state == State::Closed) return Command::REFSB;
-        return Command::PRE;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void HBM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void HBM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void HBM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<HBM>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                bank->state = State::Closed;
-                bank->row_state.clear();
-            }};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<HBM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<HBM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<HBM>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                node->state = State::ActPowerDown;
-                return;
-            }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void HBM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDS});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-    /*** Bank Group ***/
-    t = timing[int(Level::BankGroup)];
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDL});
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCDW});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCDW});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-
-    // REFSB
-    t[int(Command::PRE)].push_back({Command::REFSB, 1, s.nRP});
-    t[int(Command::REFSB)].push_back({Command::REFSB, 1, s.nRFC});
-    t[int(Command::REFSB)].push_back({Command::ACT, 1, s.nRFC});
-}
diff --git a/ext/ramulator/Ramulator/src/HBM.h b/ext/ramulator/Ramulator/src/HBM.h
deleted file mode 100644
index 76501be43..000000000
--- a/ext/ramulator/Ramulator/src/HBM.h
+++ /dev/null
@@ -1,201 +0,0 @@
-#ifndef __HBM_H
-#define __HBM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class HBM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    HBM(Org org, Speed speed);
-    HBM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /* Level */
-    enum class Level : int
-    {
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    {
-        ACT, PRE,   PREA,
-        RD,  WR,    RDA, WRA,
-        REF, REFSB, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    // REFSB and REF is not compatible, choose one or the other.
-    // REFSB can be issued to banks in any order, as long as REFI1B
-    // is satisfied for all banks
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE",   "PREA",
-        "RD",  "WR",    "RDA",  "WRA",
-        "REF", "REFSB", "PDE",  "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFSB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prereq */
-    function<Command(DRAM<HBM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<HBM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<HBM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<HBM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    { // per channel density here. Each stack comes with 8 channels
-        HBM_1Gb,
-        HBM_2Gb,
-        HBM_4Gb,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {1<<10, 128, {0, 0, 4, 2, 1<<13, 1<<(6+1)}},
-        {2<<10, 128, {0, 0, 4, 2, 1<<14, 1<<(6+1)}},
-        {4<<10, 128, {0, 0, 4, 4, 1<<14, 1<<(6+1)}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        HBM_1Gbps,
-        MAX
-    };
-
-    int prefetch_size = 4; // burst length could be 2 and 4 (choose 4 here), 2n prefetch
-    int channel_width = 128;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL;
-        int nCL, nRCDR, nRCDW, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTRS, nWTRL, nWR;
-        int nRRDS, nRRDL, nFAW;
-        int nRFC, nREFI, nREFI1B;
-        int nPD, nXP;
-        int nCKESR, nXS;
-    } speed_table[int(Speed::MAX)] = {
-        {1000, 500, 2.0, 2, 2, 3, 7, 7, 6, 7, 4, 17, 24, 7, 2, 4, 8, 4, 5, 20, 0, 1950, 0, 5, 5, 5, 0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__HBM_H*/
diff --git a/ext/ramulator/Ramulator/src/LPDDR3.cpp b/ext/ramulator/Ramulator/src/LPDDR3.cpp
deleted file mode 100644
index 63f47a531..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR3.cpp
+++ /dev/null
@@ -1,378 +0,0 @@
-#include "LPDDR3.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string LPDDR3::standard_name = "LPDDR3";
-string LPDDR3::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum LPDDR3::Org> LPDDR3::org_map = {
-    {"LPDDR3_4Gb_x16", LPDDR3::Org::LPDDR3_4Gb_x16}, {"LPDDR3_4Gb_x32", LPDDR3::Org::LPDDR3_4Gb_x32},
-    {"LPDDR3_6Gb_x16", LPDDR3::Org::LPDDR3_6Gb_x16}, {"LPDDR3_6Gb_x32", LPDDR3::Org::LPDDR3_6Gb_x32},
-    {"LPDDR3_8Gb_x16", LPDDR3::Org::LPDDR3_8Gb_x16}, {"LPDDR3_8Gb_x32", LPDDR3::Org::LPDDR3_8Gb_x32},
-    {"LPDDR3_12Gb_x16", LPDDR3::Org::LPDDR3_12Gb_x16}, {"LPDDR3_12Gb_x32", LPDDR3::Org::LPDDR3_12Gb_x32},
-    {"LPDDR3_16Gb_x16", LPDDR3::Org::LPDDR3_16Gb_x16}, {"LPDDR3_16Gb_x32", LPDDR3::Org::LPDDR3_16Gb_x32},
-};
-
-map<string, enum LPDDR3::Speed> LPDDR3::speed_map = {
-    {"LPDDR3_1333", LPDDR3::Speed::LPDDR3_1333},
-    {"LPDDR3_1600", LPDDR3::Speed::LPDDR3_1600},
-    {"LPDDR3_1866", LPDDR3::Speed::LPDDR3_1866},
-    {"LPDDR3_2133", LPDDR3::Speed::LPDDR3_2133},
-};
-
-LPDDR3::LPDDR3(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-LPDDR3::LPDDR3(const string& org_str, const string& speed_str) :
-    LPDDR3(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void LPDDR3::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void LPDDR3::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void LPDDR3::init_speed()
-{
-    // 12Gb/16Gb RFCab/RFCpb TBD
-
-    const static int RFCPB_TABLE[3][4] = {
-        {40, 48, 56, 64},
-        {60, 72, 84, 96},
-        {60, 72, 84, 96}
-    };
-
-    const static int RFCAB_TABLE[3][4] = {
-        {87, 104, 122, 139},
-        {140, 168, 196, 224},
-        {140, 168, 196, 224}
-    };
-
-    const static int XSR_TABLE[3][4] = {
-        {94, 112, 131, 150},
-        {147, 176, 206, 235},
-        {147, 176, 206, 235}
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1333: speed = 0; break;
-        case 1600: speed = 1; break;
-        case 1866: speed = 2; break;
-        case 2133: speed = 3; break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 4: density = 0; break;
-        case 6: density = 1; break;
-        case 8: density = 2; break;
-        default: assert(false && "12Gb/16Gb is still TBD");
-    }
-    speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-    speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-    speed_entry.nXSR = XSR_TABLE[density][speed];
-}
-
-
-void LPDDR3::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PRA;
-        }
-        return Command::REF;};
-
-    // REFPB
-    prereq[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-      if (node->state == State::Closed) return Command::REFPB;
-        else return Command::PRE;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PD;
-            case int(State::ActPowerDown): return Command::PD;
-            case int(State::PrePowerDown): return Command::PD;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void LPDDR3::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR3::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR3::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<LPDDR3>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<LPDDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<LPDDR3>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void LPDDR3::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    // section 4.7.3 table 11
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PRA
-    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRPab});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRPab});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRPab});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-    t[int(Command::REFPB)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-
-    // PD <-> PD
-    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-    // between different banks
-    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-    // REFSB
-    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-}
diff --git a/ext/ramulator/Ramulator/src/LPDDR3.h b/ext/ramulator/Ramulator/src/LPDDR3.h
deleted file mode 100644
index 6f95a613d..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR3.h
+++ /dev/null
@@ -1,210 +0,0 @@
-#ifndef __LPDDR3_H
-#define __LPDDR3_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class LPDDR3
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    LPDDR3(Org org, Speed speed);
-    LPDDR3(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PRA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, REFPB, PD, PDX,  SREF, SREFX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PRA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "REFPB", "PD", "PDX",  "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PD, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<LPDDR3>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<LPDDR3>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<LPDDR3>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<LPDDR3>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        LPDDR3_4Gb_x16, LPDDR3_4Gb_x32,
-        LPDDR3_6Gb_x16, LPDDR3_6Gb_x32,
-        LPDDR3_8Gb_x16, LPDDR3_8Gb_x32,
-        LPDDR3_12Gb_x16, LPDDR3_12Gb_x32,
-        LPDDR3_16Gb_x16, LPDDR3_16Gb_x32,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {4<<10, 16, {0, 0, 8, 1<<14, 1<<11}}, {4<<10, 32, {0, 0, 8, 1<<14, 1<<10}},
-        {6<<10, 16, {0, 0, 8, 3<<13, 1<<11}}, {6<<10, 32, {0, 0, 8, 3<<13, 1<<10}},
-        {8<<10, 16, {0, 0, 8, 1<<15, 1<<11}}, {8<<10, 32, {0, 0, 8, 1<<15, 1<<10}},
-        {12<<10, 16, {0, 0, 8, 3<<13, 1<<12}}, {12<<10, 32, {0, 0, 8, 3<<13, 1<<11}},
-        {16<<10, 16, {0, 0, 8, 1<<15, 1<<12}}, {16<<10, 32, {0, 0, 8, 1<<15, 1<<11}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        LPDDR3_1333,
-        LPDDR3_1600,
-        LPDDR3_1866,
-        LPDDR3_2133,
-        MAX
-    };
-
-    int prefetch_size = 8; // 16n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS, nDQSCK;
-        int nCL, nRCD, nRPpb, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI;
-        int nCKE, nXP; // CKE is PD, LPDDR3 has no DLL
-        int nCKESR, nXSR; // tXSR = tRFCab + 10ns
-    } speed_table[int(Speed::MAX)] = {
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2, 2, 10, 12, 12, 14, 6, 28, 40, 5, 5, 10,  7, 34, 0, 0, 2600, 5, 5, 10, 0},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 2, 12, 15, 15, 17, 6, 34, 48, 6, 6, 12,  8, 40, 0, 0, 3120, 6, 6, 12, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 3, 14, 17, 17, 20, 8, 40, 56, 7, 7, 14, 10, 47, 0, 0, 3640, 7, 7, 14, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 3, 16, 20, 20, 23, 8, 45, 64, 8, 8, 16, 11, 54, 0, 0, 4160, 8, 8, 16, 0}
-    }, speed_entry;
-
-    // LPDDR3 defines {fast, typical, slow} timing for tRCD and tRP. (typ)
-    // WL as diff. values for set A/B (A)
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__LPDDR3_H*/
diff --git a/ext/ramulator/Ramulator/src/LPDDR4.cpp b/ext/ramulator/Ramulator/src/LPDDR4.cpp
deleted file mode 100644
index d0510c260..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR4.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-#include "LPDDR4.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string LPDDR4::standard_name = "LPDDR4";
-string LPDDR4::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum LPDDR4::Org> LPDDR4::org_map = {
-    {"LPDDR4_4Gb_x16", LPDDR4::Org::LPDDR4_4Gb_x16},
-    {"LPDDR4_6Gb_x16", LPDDR4::Org::LPDDR4_6Gb_x16},
-    {"LPDDR4_8Gb_x16", LPDDR4::Org::LPDDR4_8Gb_x16},
-};
-
-map<string, enum LPDDR4::Speed> LPDDR4::speed_map = {
-    {"LPDDR4_1600", LPDDR4::Speed::LPDDR4_1600},
-    {"LPDDR4_2400", LPDDR4::Speed::LPDDR4_2400},
-    {"LPDDR4_3200", LPDDR4::Speed::LPDDR4_3200},
-};
-
-LPDDR4::LPDDR4(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-LPDDR4::LPDDR4(const string& org_str, const string& speed_str) :
-    LPDDR4(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void LPDDR4::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void LPDDR4::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-
-void LPDDR4::init_speed()
-{
-    // 12Gb/16Gb RFCab/RFCpb TBD
-    // Numbers are in DRAM cycles
-    const static int RFCPB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-        {48,  72,  96},
-        {72, 108, 144},
-        {72, 108, 144}
-    };
-
-    const static int RFCAB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-        {104, 156, 208},
-        {144, 216, 288},
-        {144, 216, 288}
-    };
-
-    const static int REFI_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-        {3124, 4685, 6247},
-        {1563, 2344, 3125},
-        { 782, 1172, 1563}
-    };
-
-    const static int XSR_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-        {110, 165, 220},
-        {150, 225, 300},
-        {150, 225, 300},
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1600: speed = 0; break;
-        case 2400: speed = 1; break;
-        case 3200: speed = 2; break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 2: density = 0; break;
-        case 3: density = 1; break;
-        case 4: density = 2; break;
-        default: assert(false && "12Gb/16Gb is still TBD");
-    }
-    speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-    speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-    speed_entry.nREFI = REFI_TABLE[int(refresh_mode)][speed];
-    speed_entry.nXSR = XSR_TABLE[density][speed];
-}
-
-
-void LPDDR4::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void LPDDR4::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR4::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR4::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<LPDDR4>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<LPDDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<LPDDR4>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void LPDDR4::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PREA
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRPab});
-    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nPPD});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRPab});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-    t[int(Command::PREA)].push_back({Command::SREF, 1, s.nRPab});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::REFPB)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PDE, 1, s.nXSR});
-
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nSR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-    // between different banks
-    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-    // REFPB
-    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-}
diff --git a/ext/ramulator/Ramulator/src/LPDDR4.h b/ext/ramulator/Ramulator/src/LPDDR4.h
deleted file mode 100644
index d8b736bcd..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR4.h
+++ /dev/null
@@ -1,224 +0,0 @@
-#ifndef __LPDDR4_H
-#define __LPDDR4_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class LPDDR4
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    LPDDR4(Org org, Speed speed);
-    LPDDR4(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, REFPB, PDE, PDX, SREF, SREFX, 
-        MAX
-    };
-    // Due to multiplexing on the cmd/addr bus:
-    //      ACT, RD, WR, RDA, WRA take 4 cycles
-    //      PRE, PREA, REF, REFPB, PDE, PDX, SREF, SREFX take 2 cycles
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "REFPB", "PDE", "PDX", "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<LPDDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<LPDDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<LPDDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<LPDDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        // this is per-die density, actual per-chan density is half
-        LPDDR4_4Gb_x16,
-        LPDDR4_6Gb_x16,
-        LPDDR4_8Gb_x16,
-        // LPDDR4_12Gb_x16, // tRFC TBD
-        // LPDDR4_16Gb_x16, // tRFC TBD
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {3<<10, 16, {0, 0, 8, 3<<13, 1<<10}},
-        {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-
-    /* Speed */
-    enum class Speed : int
-    {
-        LPDDR4_1600,
-        LPDDR4_2400,
-        LPDDR4_3200,
-        MAX
-    };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        Refresh_2X,
-        Refresh_4X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 16; // 16n prefetch DDR
-    int channel_width = 32;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS, nDQSCK;
-        int nCL, nRCD, nRPpb, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nPPD, nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI;
-        int nCKE, nXP; // CKE value n/a
-        int nSR, nXSR; // tXSR = tRFCab + 7.5ns
-    } speed_table[int(Speed::MAX)] = {
-        // LPDDR4 is 16n prefetch. Latencies in JESD209-4 counts from and to 
-        // the end of each command, I've converted them as if all commands take
-        // only 1 cycle like other standards
-        // CL-RCD-RPpb are set to the same value althrough CL is not explicitly specified.
-        // CWL is made up, half of CL.
-        // calculated from 10.2 core timing table 89
-        {1600, 400.0*2, 2.5/2, 8, 8, 2, 1, 15+3, 15, 15-2, 17-2,  8+3, 34, 47,  8+2,  8, 15-1, 4,  8, 32, 0, 0, 0, 0,  6, 12, 0},
-        {2400, 400.0*3, 2.5/3, 8, 8, 2, 2, 22+3, 22, 22-2, 26-2, 11+3, 51, 71,  9+2, 12, 22-1, 4, 12, 48, 0, 0, 0, 0,  9, 18, 0},
-        {3200, 400.0*4, 2.5/4, 8, 8, 2, 3, 29+3, 29, 29-2, 34-2, 15+3, 68, 95, 12+2, 16, 29-1, 4, 16, 64, 0, 0, 0, 0, 12, 24, 0}
-    }, speed_entry;
-
-    // LPDDR4 defines {fast, typical, slow} timing for tRCD and tRP. (typ)
-    // WL as diff. values for set A/B (A)
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__LPDDR4_H*/
diff --git a/ext/ramulator/Ramulator/src/Main.cpp b/ext/ramulator/Ramulator/src/Main.cpp
deleted file mode 100644
index e46b49ed8..000000000
--- a/ext/ramulator/Ramulator/src/Main.cpp
+++ /dev/null
@@ -1,277 +0,0 @@
-#include "Processor.h"
-#include "Config.h"
-#include "Controller.h"
-#include "SpeedyController.h"
-#include "Memory.h"
-#include "DRAM.h"
-#include "Statistics.h"
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <stdlib.h>
-#include <functional>
-#include <map>
-
-/* Standards */
-#include "Gem5Wrapper.h"
-#include "DDR3.h"
-#include "DDR4.h"
-#include "DSARP.h"
-#include "GDDR5.h"
-#include "LPDDR3.h"
-#include "LPDDR4.h"
-#include "WideIO.h"
-#include "WideIO2.h"
-#include "HBM.h"
-#include "SALP.h"
-#include "ALDRAM.h"
-#include "TLDRAM.h"
-#include "STTMRAM.h"
-#include "PCM.h"
-
-using namespace std;
-using namespace ramulator;
-
-bool ramulator::warmup_complete = false;
-
-template<typename T>
-void run_dramtrace(const Config& configs, Memory<T, Controller>& memory, const char* tracename) {
-
-    /* initialize DRAM trace */
-    Trace trace(tracename);
-
-    /* run simulation */
-    bool stall = false, end = false;
-    int reads = 0, writes = 0, clks = 0;
-    long addr = 0;
-    Request::Type type = Request::Type::READ;
-    map<int, int> latencies;
-    auto read_complete = [&latencies](Request& r){latencies[r.depart - r.arrive]++;};
-
-    Request req(addr, type, read_complete);
-
-    while (!end || memory.pending_requests()){
-        if (!end && !stall){
-            end = !trace.get_dramtrace_request(addr, type);
-        }
-
-        if (!end){
-            req.addr = addr;
-            req.type = type;
-            stall = !memory.send(req);
-            if (!stall){
-                if (type == Request::Type::READ) reads++;
-                else if (type == Request::Type::WRITE) writes++;
-            }
-        }
-        else {
-            memory.set_high_writeq_watermark(0.0f); // make sure that all write requests in the
-                                                    // write queue are drained
-        }
-
-        memory.tick();
-        clks ++;
-        Stats::curTick++; // memory clock, global, for Statistics
-    }
-    // This a workaround for statistics set only initially lost in the end
-    memory.finish();
-    Stats::statlist.printall();
-
-}
-
-template <typename T>
-void run_cputrace(const Config& configs, Memory<T, Controller>& memory, const std::vector<const char *>& files)
-{
-    int cpu_tick = configs.get_cpu_tick();
-    int mem_tick = configs.get_mem_tick();
-    auto send = bind(&Memory<T, Controller>::send, &memory, placeholders::_1);
-    Processor proc(configs, files, send, memory);
-
-    long warmup_insts = configs.get_warmup_insts();
-    bool is_warming_up = (warmup_insts != 0);
-
-    for(long i = 0; is_warming_up; i++){
-        proc.tick();
-        Stats::curTick++;
-        if (i % cpu_tick == (cpu_tick - 1))
-            for (int j = 0; j < mem_tick; j++)
-                memory.tick();
-
-        is_warming_up = false;
-        for(int c = 0; c < proc.cores.size(); c++){
-            if(proc.cores[c]->get_insts() < warmup_insts)
-                is_warming_up = true;
-        }
-
-        if (is_warming_up && proc.has_reached_limit()) {
-            printf("WARNING: The end of the input trace file was reached during warmup. "
-                    "Consider changing warmup_insts in the config file. \n");
-            break;
-        }
-
-    }
-
-    warmup_complete = true;
-    printf("Warmup complete! Resetting stats...\n");
-    Stats::reset_stats();
-    proc.reset_stats();
-    assert(proc.get_insts() == 0);
-
-    printf("Starting the simulation...\n");
-
-    int tick_mult = cpu_tick * mem_tick;
-    for (long i = 0; ; i++) {
-        if (((i % tick_mult) % mem_tick) == 0) { // When the CPU is ticked cpu_tick times,
-                                                 // the memory controller should be ticked mem_tick times
-            proc.tick();
-            Stats::curTick++; // processor clock, global, for Statistics
-
-            if (configs.calc_weighted_speedup()) {
-                if (proc.has_reached_limit()) {
-                    break;
-                }
-            } else {
-                if (configs.is_early_exit()) {
-                    if (proc.finished())
-                    break;
-                } else {
-                if (proc.finished() && (memory.pending_requests() == 0))
-                    break;
-                }
-            }
-        }
-
-        if (((i % tick_mult) % cpu_tick) == 0) // TODO_hasan: Better if the processor ticks the memory controller
-            memory.tick();
-
-    }
-    // This a workaround for statistics set only initially lost in the end
-    memory.finish();
-    Stats::statlist.printall();
-}
-
-template<typename T>
-void start_run(const Config& configs, T* spec, const vector<const char*>& files) {
-  // initiate controller and memory
-  int C = configs.get_channels(), R = configs.get_ranks();
-  // Check and Set channel, rank number
-  spec->set_channel_number(C);
-  spec->set_rank_number(R);
-  std::vector<Controller<T>*> ctrls;
-  for (int c = 0 ; c < C ; c++) {
-    DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
-    channel->id = c;
-    channel->regStats("");
-    Controller<T>* ctrl = new Controller<T>(configs, channel, false); // gagan : enable_debug set to false
-    ctrls.push_back(ctrl);
-  }
-  Memory<T, Controller> memory(configs, ctrls);
-
-  assert(files.size() != 0);
-  if (configs["trace_type"] == "CPU") {
-    run_cputrace(configs, memory, files);
-  } else if (configs["trace_type"] == "DRAM") {
-    run_dramtrace(configs, memory, files[0]);
-  }
-}
-
-int main(int argc, const char *argv[])
-{
-    if (argc < 2) {
-        printf("Usage: %s <configs-file> --mode=cpu,dram [--stats <filename>] <trace-filename1> <trace-filename2>\n"
-            "Example: %s ramulator-configs.cfg --mode=cpu cpu.trace cpu.trace\n", argv[0], argv[0]);
-        return 0;
-    }
-
-    Config configs(argv[1]);
-
-    const std::string& standard = configs["standard"];
-    assert(standard != "" || "DRAM standard should be specified.");
-
-    const char *trace_type = strstr(argv[2], "=");
-    trace_type++;
-    if (strcmp(trace_type, "cpu") == 0) {
-      configs.add("trace_type", "CPU");
-    } else if (strcmp(trace_type, "dram") == 0) {
-      configs.add("trace_type", "DRAM");
-    } else {
-      printf("invalid trace type: %s\n", trace_type);
-      assert(false);
-    }
-
-    int trace_start = 3;
-    string stats_out;
-    if (strcmp(argv[trace_start], "--stats") == 0) {
-      Stats::statlist.output(argv[trace_start+1]);
-      stats_out = argv[trace_start+1];
-      trace_start += 2;
-    } else {
-      Stats::statlist.output(standard+".stats");
-      stats_out = standard + string(".stats");
-    }
-
-    // A separate file defines mapping for easy config.
-    if (strcmp(argv[trace_start], "--mapping") == 0) {
-      configs.add("mapping", argv[trace_start+1]);
-      trace_start += 2;
-    } else {
-      configs.add("mapping", "defaultmapping");
-    }
-
-    std::vector<const char*> files(&argv[trace_start], &argv[argc]);
-    configs.set_core_num(argc - trace_start);
-
-    if (standard == "DDR3") {
-      DDR3* ddr3 = new DDR3(configs["org"], configs["speed"]);
-      start_run(configs, ddr3, files);
-    } else if (standard == "DDR4") {
-      DDR4* ddr4 = new DDR4(configs["org"], configs["speed"]);
-      start_run(configs, ddr4, files);
-    } else if (standard == "SALP-MASA") {
-      SALP* salp8 = new SALP(configs["org"], configs["speed"], "SALP-MASA", configs.get_subarrays());
-      start_run(configs, salp8, files);
-    } else if (standard == "LPDDR3") {
-      LPDDR3* lpddr3 = new LPDDR3(configs["org"], configs["speed"]);
-      start_run(configs, lpddr3, files);
-    } else if (standard == "LPDDR4") {
-      // total cap: 2GB, 1/2 of others
-      LPDDR4* lpddr4 = new LPDDR4(configs["org"], configs["speed"]);
-      start_run(configs, lpddr4, files);
-    } else if (standard == "GDDR5") {
-      GDDR5* gddr5 = new GDDR5(configs["org"], configs["speed"]);
-      start_run(configs, gddr5, files);
-    } else if (standard == "HBM") {
-      HBM* hbm = new HBM(configs["org"], configs["speed"]);
-      start_run(configs, hbm, files);
-    } else if (standard == "WideIO") {
-      // total cap: 1GB, 1/4 of others
-      WideIO* wio = new WideIO(configs["org"], configs["speed"]);
-      start_run(configs, wio, files);
-    } else if (standard == "WideIO2") {
-      // total cap: 2GB, 1/2 of others
-      WideIO2* wio2 = new WideIO2(configs["org"], configs["speed"], configs.get_channels());
-      wio2->channel_width *= 2;
-      start_run(configs, wio2, files);
-    } else if (standard == "STTMRAM") {
-      STTMRAM* sttmram = new STTMRAM(configs["org"], configs["speed"]);
-      start_run(configs, sttmram, files);
-    } else if (standard == "PCM") {
-      PCM* pcm = new PCM(configs["org"], configs["speed"]);
-      start_run(configs, pcm, files);
-    }
-    // Various refresh mechanisms
-      else if (standard == "DSARP") {
-      DSARP* dsddr3_dsarp = new DSARP(configs["org"], configs["speed"], DSARP::Type::DSARP, configs.get_subarrays());
-      start_run(configs, dsddr3_dsarp, files);
-    } else if (standard == "ALDRAM") {
-      ALDRAM* aldram = new ALDRAM(configs["org"], configs["speed"]);
-      start_run(configs, aldram, files);
-    } else if (standard == "TLDRAM") {
-      TLDRAM* tldram = new TLDRAM(configs["org"], configs["speed"], configs.get_subarrays());
-      start_run(configs, tldram, files);
-    }
-
-    printf("Simulation done. Statistics written to %s\n", stats_out.c_str());
-
-    return 0;
-}
diff --git a/ext/ramulator/Ramulator/src/Memory.h b/ext/ramulator/Ramulator/src/Memory.h
deleted file mode 100644
index 9fefa0345..000000000
--- a/ext/ramulator/Ramulator/src/Memory.h
+++ /dev/null
@@ -1,870 +0,0 @@
-#ifndef __MEMORY_H
-#define __MEMORY_H
-
-#include "Config.h"
-#include "DRAM.h"
-#include "Request.h"
-#include "Controller.h"
-#include "SpeedyController.h"
-#include "Statistics.h"
-#include "GDDR5.h"
-#include "HBM.h"
-#include "LPDDR3.h"
-#include "LPDDR4.h"
-#include "WideIO2.h"
-#include "DSARP.h"
-#include <vector>
-#include <functional>
-#include <cmath>
-#include <cassert>
-#include <tuple>
-
-using namespace std;
-
-typedef vector<unsigned int> MapSrcVector;
-typedef map<unsigned int, MapSrcVector > MapSchemeEntry;
-typedef map<unsigned int, MapSchemeEntry> MapScheme;
-
-namespace ramulator
-{
-
-class MemoryBase{
-public:
-    MemoryBase() {}
-    virtual ~MemoryBase() {}
-    virtual double clk_ns() = 0;
-    virtual void tick() = 0;
-    virtual bool send(Request req) = 0;
-    virtual int pending_requests() = 0;
-    virtual void finish(void) = 0;
-    virtual long page_allocator(long addr, int coreid) = 0;
-    virtual void record_core(int coreid) = 0;
-    virtual void set_high_writeq_watermark(const float watermark) = 0;
-    virtual void set_low_writeq_watermark(const float watermark) = 0;
-};
-
-template <class T, template<typename> class Controller = Controller >
-class Memory : public MemoryBase
-{
-protected:
-  ScalarStat dram_capacity;
-  ScalarStat num_dram_cycles;
-  ScalarStat num_incoming_requests;
-  VectorStat num_read_requests;
-  VectorStat num_write_requests;
-  ScalarStat ramulator_active_cycles;
-  VectorStat incoming_requests_per_channel;
-  VectorStat incoming_read_reqs_per_channel;
-  // gagan : demand and prefetch read reqs
-  VectorStat incoming_demand_read_reqs_per_channel;
-  VectorStat incoming_prefetch_read_reqs_per_channel;
-  VectorStat prefetch_to_demand_read_promotion;
-
-  ScalarStat physical_page_replacement;
-  ScalarStat maximum_bandwidth;
-  ScalarStat in_queue_req_num_sum;
-  ScalarStat in_queue_read_req_num_sum;
-  ScalarStat in_queue_write_req_num_sum;
-  ScalarStat in_queue_req_num_avg;
-  ScalarStat in_queue_read_req_num_avg;
-  ScalarStat in_queue_write_req_num_avg;
-
-#ifndef INTEGRATED_WITH_GEM5
-  VectorStat record_read_requests;
-  VectorStat record_write_requests;
-#endif
-
-  long max_address;
-  MapScheme mapping_scheme;
-  
-public:
-    enum class Type {
-        ChRaBaRoCo,
-        RoBaRaCoCh,
-        RoRaBaChCo,//daz3
-        RoRaBaChCo_XOR,
-        RoRaBaChCo_XOR_chint,
-	intel_quad_chan,
-        RoRaBaChCo_XOR_new,	  
-        MAX,
-	  } type = Type::RoRaBaChCo;
-    //daz3
-    // } type = Type::RoBaRaCoCh;
-
-    enum class Translation {
-      None,
-      Random,
-      MAX,
-    } translation = Translation::None;
-
-    std::map<string, Translation> name_to_translation = {
-      {"None", Translation::None},
-      {"Random", Translation::Random},
-    };
-
-    vector<int> free_physical_pages;
-    long free_physical_pages_remaining;
-    map<pair<int, long>, long> page_translation;
-
-    vector<Controller<T>*> ctrls;
-    T * spec;
-    vector<int> addr_bits;
-    string mapping_file;
-    bool use_mapping_file;
-    bool dump_mapping;
-    
-    int tx_bits;
-
-    Memory(const Config& configs, vector<Controller<T>*> ctrls)
-        : ctrls(ctrls),
-          spec(ctrls[0]->channel->spec),
-          addr_bits(int(T::Level::MAX))
-    {
-        // make sure 2^N channels/ranks
-        // TODO support channel number that is not powers of 2
-        int *sz = spec->org_entry.count;
-        assert((sz[0] & (sz[0] - 1)) == 0);
-        assert((sz[1] & (sz[1] - 1)) == 0);
-        // validate size of one transaction
-        int tx = (spec->prefetch_size * spec->channel_width / 8);
-        tx_bits = calc_log2(tx);
-        assert((1<<tx_bits) == tx);
-        
-        // Parsing mapping file and initialize mapping table
-        use_mapping_file = false;
-        dump_mapping = false;
-        if (spec->standard_name.substr(0, 4) == "DDR3"){
-            if (configs["mapping"] != "defaultmapping"){
-              init_mapping_with_file(configs["mapping"]);
-              // dump_mapping = true;
-              use_mapping_file = true;
-            }
-        }
-        // If hi address bits will not be assigned to Rows
-        // then the chips must not be LPDDRx 6Gb, 12Gb etc.
-        if (type != Type::RoBaRaCoCh && spec->standard_name.substr(0, 5) == "LPDDR")
-            assert((sz[int(T::Level::Row)] & (sz[int(T::Level::Row)] - 1)) == 0);
-
-        max_address = spec->channel_width / 8;
-
-        for (unsigned int lev = 0; lev < addr_bits.size(); lev++) {
-          addr_bits[lev] = calc_log2(sz[lev]);
-            max_address *= sz[lev];
-        }
-
-        addr_bits[int(T::Level::MAX) - 1] -= calc_log2(spec->prefetch_size);
-
-        // Initiating translation
-        if (configs.contains("translation")) {
-          translation = name_to_translation[configs["translation"]];
-        }
-        if (translation != Translation::None) {
-          // construct a list of available pages
-          // TODO: this should not assume a 4KB page!
-          free_physical_pages_remaining = max_address >> 12;
-
-          free_physical_pages.resize(free_physical_pages_remaining, -1);
-        }
-
-        dram_capacity
-            .name("dram_capacity")
-            .desc("Number of bytes in simulated DRAM")
-            .precision(0)
-            ;
-        dram_capacity = max_address;
-
-        num_dram_cycles
-            .name("dram_cycles")
-            .desc("Number of DRAM cycles simulated")
-            .precision(0)
-            ;
-        num_incoming_requests
-            .name("incoming_requests")
-            .desc("Number of incoming requests to DRAM")
-            .precision(0)
-            ;
-        num_read_requests
-            .init(configs.get_core_num())
-            .name("read_requests")
-            .desc("Number of incoming read requests to DRAM per core")
-            .precision(0)
-            ;
-        num_write_requests
-            .init(configs.get_core_num())
-            .name("write_requests")
-            .desc("Number of incoming write requests to DRAM per core")
-            .precision(0)
-            ;
-        incoming_requests_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_requests_per_channel")
-            .desc("Number of incoming requests to each DRAM channel")
-            ;
-        incoming_read_reqs_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_read_reqs_per_channel")
-            .desc("Number of incoming read requests to each DRAM channel")
-            ;
-	// gagan : demand read reqs
-	incoming_demand_read_reqs_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_demand_read_reqs_per_channel")
-            .desc("Number of incoming demand read requests to each DRAM channel")
-            ;
-	// gagan : prefetch read reqs
-	incoming_prefetch_read_reqs_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_prefetch_read_reqs_per_channel")
-            .desc("Number of incoming prefetch read requests to each DRAM channel")
-            ;
-	// gagab : prefecth req to demand req promotion
-	prefetch_to_demand_read_promotion
-            .init(sz[int(T::Level::Channel)])
-            .name("prefetch_to_demand_read_promotion")
-            .desc("Number of incoming prefetch read requests promoted to demand request")
-            ;
-        ramulator_active_cycles
-            .name("ramulator_active_cycles")
-            .desc("The total number of cycles that the DRAM part is active (serving R/W)")
-            .precision(0)
-            ;
-        physical_page_replacement
-            .name("physical_page_replacement")
-            .desc("The number of times that physical page replacement happens.")
-            .precision(0)
-            ;
-        maximum_bandwidth
-            .name("maximum_bandwidth")
-            .desc("The theoretical maximum bandwidth (Bps)")
-            .precision(0)
-            ;
-        in_queue_req_num_sum
-            .name("in_queue_req_num_sum")
-            .desc("Sum of read/write queue length")
-            .precision(0)
-            ;
-        in_queue_read_req_num_sum
-            .name("in_queue_read_req_num_sum")
-            .desc("Sum of read queue length")
-            .precision(0)
-            ;
-        in_queue_write_req_num_sum
-            .name("in_queue_write_req_num_sum")
-            .desc("Sum of write queue length")
-            .precision(0)
-            ;
-        in_queue_req_num_avg
-            .name("in_queue_req_num_avg")
-            .desc("Average of read/write queue length per memory cycle")
-            .precision(6)
-            ;
-        in_queue_read_req_num_avg
-            .name("in_queue_read_req_num_avg")
-            .desc("Average of read queue length per memory cycle")
-            .precision(6)
-            ;
-        in_queue_write_req_num_avg
-            .name("in_queue_write_req_num_avg")
-            .desc("Average of write queue length per memory cycle")
-            .precision(6)
-            ;
-#ifndef INTEGRATED_WITH_GEM5
-        record_read_requests
-            .init(configs.get_core_num())
-            .name("record_read_requests")
-            .desc("record read requests for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_requests
-            .init(configs.get_core_num())
-            .name("record_write_requests")
-            .desc("record write requests for this core when it reaches request limit or to the end")
-            ;
-#endif
-
-    }
-
-    ~Memory()
-    {
-        for (auto ctrl: ctrls)
-            delete ctrl;
-        delete spec;
-    }
-
-    double clk_ns()
-    {
-        return spec->speed_entry.tCK;
-    }
-
-    void record_core(int coreid) {
-#ifndef INTEGRATED_WITH_GEM5
-      record_read_requests[coreid] = num_read_requests[coreid];
-      record_write_requests[coreid] = num_write_requests[coreid];
-#endif
-      for (auto ctrl : ctrls) {
-        ctrl->record_core(coreid);
-      }
-    }
-
-    void tick()
-    {
-        ++num_dram_cycles;
-        int cur_que_req_num = 0;
-        int cur_que_readreq_num = 0;
-        int cur_que_writereq_num = 0;
-        for (auto ctrl : ctrls) {
-          cur_que_req_num += ctrl->readq.size() + ctrl->writeq.size() + ctrl->pending.size();
-          cur_que_readreq_num += ctrl->readq.size() + ctrl->pending.size();
-          cur_que_writereq_num += ctrl->writeq.size();
-        }
-        in_queue_req_num_sum += cur_que_req_num;
-        in_queue_read_req_num_sum += cur_que_readreq_num;
-        in_queue_write_req_num_sum += cur_que_writereq_num;
-
-        bool is_active = false;
-        for (auto ctrl : ctrls) {
-          is_active = is_active || ctrl->is_active();
-          ctrl->tick();
-        }
-        if (is_active) {
-          ramulator_active_cycles++;
-        }
-    }
-
-bool send(Request req)
-    {
-      bool promote = false;
-        req.addr_vec.resize(addr_bits.size());
-        long addr = req.addr;
-        int coreid = req.coreid;
-
-	int column, channel, bank, bankgroup, rank, row, tempA, tempB, channel_mask, channel_mask_temp;
-	long addr_copy;
-
-        // Each transaction size is 2^tx_bits, so first clear the lowest tx_bits bits
-        clear_lower_bits(addr, tx_bits);
-
-        if (use_mapping_file){
-            apply_mapping(addr, req.addr_vec);
-        }
-        else {
-            switch(int(type)){
-                case int(Type::ChRaBaRoCo):
-                    for (int i = addr_bits.size() - 1; i >= 0; i--)
-                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-                    break;
-                case int(Type::RoBaRaCoCh):
-                    req.addr_vec[0] = slice_lower_bits(addr, addr_bits[0]);
-                    req.addr_vec[addr_bits.size() - 1] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-                    for (int i = 1; i <= int(T::Level::Row); i++)
-                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-                    break;
-                // daz3
-                case int(Type::RoRaBaChCo):
-                    req.addr_vec[addr_bits.size() - 1] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-                    req.addr_vec[0] = slice_lower_bits(addr, addr_bits[0]);
-                    for (int i = 2; i < int(T::Level::Row); i++)
-                    {
-                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-                    }
-                    req.addr_vec[1] = slice_lower_bits(addr, addr_bits[1]);
-                    req.addr_vec[addr_bits.size() - 2] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 2]);
-                    break;
-	    case int(Type::RoRaBaChCo_XOR):
-		//std::cout << std::hex << "Addr: " << addr << "\n";
-		//std::cout << "bitwidths: ";
-		//for(int i = 0; i < addr_bits.size(); ++i)
-		//  std::cout << std::dec << addr_bits[i] << " ";
-
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = slice_lower_bits(addr, addr_bits[0]);
-		bank = slice_lower_bits(addr, addr_bits[3]);
-		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-		rank = slice_lower_bits(addr, addr_bits[1]);
-		row = slice_lower_bits(addr, addr_bits[4]);
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		tempA = row & ((1 << addr_bits[2]) - 1);
-		tempB = (row >> 2) & ((1 << addr_bits[3]) - 1);
-
-		bankgroup = bankgroup ^ tempA;
-		bank = bank ^ tempB;
-
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		//std::cout << "address mapping:\n";
-		//for(int i = 0; i < 6; ++i)
-		//  std::cout << std::dec << req.addr_vec[i] << "\n";
-		//std::cout << "\n";
-		break;
-	    case int(Type::RoRaBaChCo_XOR_chint):
-		/*
-		std::cout << std::hex << "Addr: " << addr << "\n";
-		std::cout << "bitwidths: ";
-		for(int i = 0; i < addr_bits.size(); ++i)
-		  std::cout << std::dec << addr_bits[i] << " ";
-		std::cout << "\n";
-		*/
-		
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = slice_lower_bits(addr, addr_bits[0]);
-		bank = slice_lower_bits(addr, addr_bits[3]);
-		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-		rank = slice_lower_bits(addr, addr_bits[1]);
-		row = slice_lower_bits(addr, addr_bits[4]);
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		tempA = row & ((1 << addr_bits[2]) - 1);
-		tempB = (row >> 2) & ((1 << addr_bits[3]) - 1);
-
-		bankgroup = bankgroup ^ tempA;
-		bank = bank ^ tempB;
-
-		channel_mask_temp = column;
-		//std::cout << "channel_mask_temp: " << channel_mask_temp << "\n";
-		channel_mask_temp >>= (addr_bits[addr_bits.size() - 1] - addr_bits[0]);
-		//std::cout << "channel_mask_temp: " << channel_mask_temp << "\n";
-		channel_mask = channel_mask_temp & ((1 << addr_bits[0]) - 1);
-		//std::cout << "channel_mask: " << channel_mask << "\n";
-
-		channel = channel_mask;
-
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		/*
-		std::cout << "address mapping:\n";
-		for(int i = 0; i < 6; ++i)
-		  std::cout << std::dec << req.addr_vec[i] << "\n";
-		std::cout << "\n";
-		*/
-		break;
-	    case int(Type::intel_quad_chan):
-		
-		/*
-		std::cout << std::hex << "Addr: " << addr << "\n";
-		std::cout << "bitwidths: ";
-		for(int i = 0; i < addr_bits.size(); ++i)
-		  std::cout << std::dec << addr_bits[i] << " ";
-		std::cout << "\n";
-		*/
-		
-		addr_copy = addr;
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = get_bit_at(addr_copy, 8) ^ get_bit_at(addr_copy, 13) ^ get_bit_at(addr_copy, 15) ^ get_bit_at(addr_copy, 17) ^ get_bit_at(addr_copy, 19) ^ get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 23) ^ get_bit_at(addr_copy, 25)  ^ get_bit_at(addr_copy, 27);
-		channel = (channel << 1) | (get_bit_at(addr_copy, 7) ^ get_bit_at(addr_copy, 12) ^ get_bit_at(addr_copy, 14) ^ get_bit_at(addr_copy, 16) ^ get_bit_at(addr_copy, 18) ^ get_bit_at(addr_copy, 20) ^ get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 24)  ^ get_bit_at(addr_copy, 26));
-		// row = [+23][19 to 17]
-		slice_lower_bits(addr, 10);
-		// tempA : [19 to 17]
-		tempA = slice_lower_bits(addr, 3);
-		// tempB : use 2 bits for banks and 1 bit for ranks
-		tempB = slice_lower_bits(addr, 3);
-		row = slice_lower_bits(addr, addr_bits[4] - 3);
-		row = (row << 3) | tempA;
-
-		// rank
-		if(addr_bits[1] == 1)
-		  {
-		    rank = get_bit_at(addr_copy, 15);
-		  }
-		else if(addr_bits[1] == 2)
-		  {
-		    rank = (get_bit_at(tempB, 0) << 1) | get_bit_at(addr_copy, 15);
-		  }
-		else
-		  {
-		    std::cout << "Rank bits > 2. Not supported.\n";
-		    exit(0);
-		  }
-
-		// bank
-		if(addr_bits[3] == 2)
-		  {
-		    bank = ((get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 26)) << 1) | (get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 25));
-		  }
-		else if(addr_bits[3] == 4)
-		  {
-		    bank = get_bit_at(tempB, 1);
-		    bank = (bank << 1) | get_bit_at(tempB, 2);
-		    bank = (bank << 2) | ((get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 26)) << 1) | (get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 25));
-		  }
-		else
-		  {
-		    std::cout << "Bank bits != {2, 4}. Not supported.\n";
-		    exit(0);
-		  }
-
-		// bankgroup
-		if(addr_bits[2] == 2)
-		  {
-		    bankgroup = ((get_bit_at(addr_copy, 24) ^ get_bit_at(addr_copy, 20)) << 1) | (get_bit_at(addr_copy, 23) ^ get_bit_at(addr_copy, 26));
-		  }
-		else
-		  {
-		    std::cout << "Bankgroup bits != 2. Not supported.\n";
-		    exit(0);
-		  }
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		/*
-		std::cout << "address mapping:\n";
-		for(int i = 0; i < 6; ++i)
-		  std::cout << std::dec << req.addr_vec[i] << "\n";
-		std::cout << "\n";
-		*/
-		
-		break;
-
-	    case int(Type::RoRaBaChCo_XOR_new):
-		/*
-		std::cout << std::hex << "Addr: " << addr << "\n";
-		std::cout << "bitwidths: ";
-		for(int i = 0; i < addr_bits.size(); ++i)
-		  std::cout << std::dec << addr_bits[i] << " ";
-		*/
-
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = slice_lower_bits(addr, addr_bits[0]);
-		rank = slice_lower_bits(addr, addr_bits[1]);
-		bank = slice_lower_bits(addr, addr_bits[3]);
-		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-		row = slice_lower_bits(addr, addr_bits[4]);
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		tempA = row & ((1 << addr_bits[3]) - 1);
-		tempB = (row >> addr_bits[3]) & ((1 << addr_bits[2]) - 1);
-
-		bank = bank ^ tempA;
-		bankgroup = bankgroup ^ tempB;
-
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		/*
-		std::cout << "address mapping:\n";
-		for(int i = 0; i < 6; ++i)
-		  std::cout << std::dec << req.addr_vec[i] << "\n";
-		std::cout << "\n";
-		*/
-		break;
-                default:
-                    assert(false);
-            }
-        }
-
-	if(promote == false)
-	  {
-	    if(ctrls[req.addr_vec[0]]->enqueue(req)) {
-	      // tally stats here to avoid double counting for requests that aren't enqueued
-	      ++num_incoming_requests;
-	      if (req.type == Request::Type::READ) {
-		++num_read_requests[coreid];
-		++incoming_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-		if(req.is_prefetch)
-		  ++incoming_prefetch_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-		else
-		  ++incoming_demand_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	      }
-	      if (req.type == Request::Type::WRITE) {
-		++num_write_requests[coreid];
-	      }
-	      ++incoming_requests_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	      return true;
-	    }
-	  }
-	else
-	  {
-	    ctrls[req.addr_vec[0]]->promote(req);
-	    --incoming_prefetch_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	    ++incoming_demand_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	    ++prefetch_to_demand_read_promotion[req.addr_vec[int(T::Level::Channel)]];
-	    return true;
-	  }
-
-        return false;
-    }
-    
-    void init_mapping_with_file(string filename){
-        ifstream file(filename);
-        assert(file.good() && "Bad mapping file");
-        // possible line types are:
-        // 0. Empty line
-        // 1. Direct bit assignment   : component N   = x
-        // 2. Direct range assignment : component N:M = x:y
-        // 3. XOR bit assignment      : component N   = x y z ...
-        // 4. Comment line            : # comment here
-        string line;
-        char delim[] = " \t";
-        while (getline(file, line)) {
-            short capture_flags = 0;
-            int level = -1;
-            int target_bit = -1, target_bit2 = -1;
-            int source_bit = -1, source_bit2 = -1;
-            // cout << "Processing: " << line << endl;
-            bool is_range = false;
-            while (true) { // process next word
-                size_t start = line.find_first_not_of(delim);
-                if (start == string::npos) // no more words
-                    break;
-                size_t end = line.find_first_of(delim, start);
-                string word = line.substr(start, end - start);
-                
-                if (word.at(0) == '#')// starting a comment
-                    break;
-                
-                size_t col_index;
-                int source_min, target_min, target_max;
-                switch (capture_flags){
-                    case 0: // capturing the component name
-                        // fetch component level from channel spec
-                        for (int i = 0; i < int(T::Level::MAX); i++)
-                            if (word.find(T::level_str[i]) != string::npos) {
-                                level = i;
-                                capture_flags ++;
-                            }
-                        break;
-
-                    case 1: // capturing target bit(s)
-                        col_index = word.find(":");
-                        if ( col_index != string::npos ){
-                            target_bit2 = stoi(word.substr(col_index+1));
-                            word = word.substr(0,col_index);
-                            is_range = true;
-                        }
-                        target_bit = stoi(word);
-                        capture_flags ++;
-                        break;
-
-                    case 2: //this should be the delimiter
-                        assert(word.find("=") != string::npos);
-                        capture_flags ++;
-                        break;
-
-                    case 3:
-                        if (is_range){
-                            col_index = word.find(":");
-                            source_bit  = stoi(word.substr(0,col_index));
-                            source_bit2 = stoi(word.substr(col_index+1));
-                            assert(source_bit2 - source_bit == target_bit2 - target_bit);
-                            source_min = min(source_bit, source_bit2);
-                            target_min = min(target_bit, target_bit2);
-                            target_max = max(target_bit, target_bit2);
-                            while (target_min <= target_max){
-                                mapping_scheme[level][target_min].push_back(source_min);
-                                // cout << target_min << " <- " << source_min << endl;
-                                source_min ++;
-                                target_min ++;
-                            }
-                        }
-                        else {
-                            source_bit = stoi(word);
-                            mapping_scheme[level][target_bit].push_back(source_bit);
-                        }
-                }
-                if (end == string::npos) { // this is the last word
-                    break;
-                }
-                line = line.substr(end);
-            }
-        }
-        if (dump_mapping)
-            dump_mapping_scheme();
-    }
-    
-    void dump_mapping_scheme(){
-        cout << "Mapping Scheme: " << endl;
-        for (MapScheme::iterator mapit = mapping_scheme.begin(); mapit != mapping_scheme.end(); mapit++)
-        {
-            int level = mapit->first;
-            for (MapSchemeEntry::iterator entit = mapit->second.begin(); entit != mapit->second.end(); entit++){
-                cout << T::level_str[level] << "[" << entit->first << "] := ";
-                cout << "PhysicalAddress[" << *(entit->second.begin()) << "]";
-                entit->second.erase(entit->second.begin());
-                for (MapSrcVector::iterator it = entit->second.begin() ; it != entit->second.end(); it ++)
-                    cout << " xor PhysicalAddress[" << *it << "]";
-                cout << endl;
-            }
-        }
-    }
-    
-    void apply_mapping(long addr, std::vector<int>& addr_vec){
-        int *sz = spec->org_entry.count;
-        int addr_total_bits = sizeof(addr_vec)*8;
-        int addr_bits [int(T::Level::MAX)];
-        for (int i = 0 ; i < int(T::Level::MAX) ; i ++)
-        {
-            if ( i != int(T::Level::Row))
-            {
-                addr_bits[i] = calc_log2(sz[i]);
-                addr_total_bits -= addr_bits[i];
-            }
-        }
-        // Row address is an integer.
-        addr_bits[int(T::Level::Row)] = min((int)sizeof(int)*8, max(addr_total_bits, calc_log2(sz[int(T::Level::Row)])));
-
-        // printf("Address: %lx => ",addr);
-        for (unsigned int lvl = 0; lvl < int(T::Level::MAX); lvl++)
-        {
-            unsigned int lvl_bits = addr_bits[lvl];
-            addr_vec[lvl] = 0;
-            for (unsigned int bitindex = 0 ; bitindex < lvl_bits ; bitindex++){
-                bool bitvalue = false;
-                for (MapSrcVector::iterator it = mapping_scheme[lvl][bitindex].begin() ;
-                    it != mapping_scheme[lvl][bitindex].end(); it ++)
-                {
-                    bitvalue = bitvalue xor get_bit_at(addr, *it);
-                }
-                addr_vec[lvl] |= (bitvalue << bitindex);
-            }
-            // printf("%s: %x, ",T::level_str[lvl].c_str(),addr_vec[lvl]);
-        }
-        // printf("\n");
-    }
-
-    int pending_requests()
-    {
-        int reqs = 0;
-        for (auto ctrl: ctrls)
-            reqs += ctrl->readq.size() + ctrl->writeq.size() + ctrl->otherq.size() + ctrl->actq.size() + ctrl->pending.size();
-        return reqs;
-    }
-
-    void set_high_writeq_watermark(const float watermark) {
-        for (auto ctrl: ctrls)
-            ctrl->set_high_writeq_watermark(watermark);
-    }
-
-    void set_low_writeq_watermark(const float watermark) {
-    for (auto ctrl: ctrls)
-        ctrl->set_low_writeq_watermark(watermark);
-    }
-
-    void finish(void) {
-      dram_capacity = max_address;
-      int *sz = spec->org_entry.count;
-      maximum_bandwidth = spec->speed_entry.rate * 1e6 * spec->channel_width * sz[int(T::Level::Channel)] / 8;
-      long dram_cycles = num_dram_cycles.value();
-      for (auto ctrl : ctrls) {
-        long read_req = long(incoming_read_reqs_per_channel[ctrl->channel->id].value());
-	long demand_read_req = long(incoming_demand_read_reqs_per_channel[ctrl->channel->id].value());
-	long prefetch_read_req = long(incoming_prefetch_read_reqs_per_channel[ctrl->channel->id].value());
-        ctrl->finish(read_req, demand_read_req, prefetch_read_req, dram_cycles);
-      }
-
-      // finalize average queueing requests
-      in_queue_req_num_avg = in_queue_req_num_sum.value() / dram_cycles;
-      in_queue_read_req_num_avg = in_queue_read_req_num_sum.value() / dram_cycles;
-      in_queue_write_req_num_avg = in_queue_write_req_num_sum.value() / dram_cycles;
-    }
-
-    long page_allocator(long addr, int coreid) {
-        long virtual_page_number = addr >> 12;
-
-        switch(int(translation)) {
-            case int(Translation::None): {
-              return addr;
-            }
-            case int(Translation::Random): {
-                auto target = make_pair(coreid, virtual_page_number);
-                if(page_translation.find(target) == page_translation.end()) {
-                    // page doesn't exist, so assign a new page
-                    // make sure there are physical pages left to be assigned
-
-                    // if physical page doesn't remain, replace a previous assigned
-                    // physical page.
-                    if (!free_physical_pages_remaining) {
-                      physical_page_replacement++;
-                      long phys_page_to_read = lrand() % free_physical_pages.size();
-                      assert(free_physical_pages[phys_page_to_read] != -1);
-                      page_translation[target] = phys_page_to_read;
-                    } else {
-                        // assign a new page
-                        long phys_page_to_read = lrand() % free_physical_pages.size();
-                        // if the randomly-selected page was already assigned
-                        if(free_physical_pages[phys_page_to_read] != -1) {
-                            long starting_page_of_search = phys_page_to_read;
-
-                            do {
-                                // iterate through the list until we find a free page
-                                // TODO: does this introduce serious non-randomness?
-                                ++phys_page_to_read;
-                                phys_page_to_read %= free_physical_pages.size();
-                            }
-                            while((phys_page_to_read != starting_page_of_search) && free_physical_pages[phys_page_to_read] != -1);
-                        }
-
-                        assert(free_physical_pages[phys_page_to_read] == -1);
-
-                        page_translation[target] = phys_page_to_read;
-                        free_physical_pages[phys_page_to_read] = coreid;
-                        --free_physical_pages_remaining;
-                    }
-                }
-
-                // SAUGATA TODO: page size should not always be fixed to 4KB
-                return (page_translation[target] << 12) | (addr & ((1 << 12) - 1));
-            }
-            default:
-                assert(false);
-        }
-
-    }
-
-private:
-
-    int calc_log2(int val){
-        int n = 0;
-        while ((val >>= 1))
-            n ++;
-        return n;
-    }
-    int slice_lower_bits(long& addr, int bits)
-    {
-        int lbits = addr & ((1<<bits) - 1);
-        addr >>= bits;
-        return lbits;
-    }
-    bool get_bit_at(long addr, int bit)
-    {
-        return (((addr >> bit) & 1) == 1);
-    }
-    void clear_lower_bits(long& addr, int bits)
-    {
-        addr >>= bits;
-    }
-    long lrand(void) {
-        if(sizeof(int) < sizeof(long)) {
-            return static_cast<long>(rand()) << (sizeof(int) * 8) | rand();
-        }
-
-        return rand();
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__MEMORY_H*/
diff --git a/ext/ramulator/Ramulator/src/MemoryFactory.cpp b/ext/ramulator/Ramulator/src/MemoryFactory.cpp
deleted file mode 100644
index 2d2f77406..000000000
--- a/ext/ramulator/Ramulator/src/MemoryFactory.cpp
+++ /dev/null
@@ -1,80 +0,0 @@
-#include "MemoryFactory.h"
-#include "LPDDR4.h"
-#include "WideIO.h"
-#include "WideIO2.h"
-#include "HBM.h"
-#include "SALP.h"
-
-using namespace ramulator;
-
-namespace ramulator
-{
-
-template <>
-void MemoryFactory<LPDDR4>::validate(int channels, int ranks, const Config& configs) {
-    assert(channels >= 2 && "LPDDR4 requires 2, 4, 8 ... channels");
-}
-
-template <>
-void MemoryFactory<WideIO>::validate(int channels, int ranks, const Config& configs) {
-    assert(channels == 4 && "WideIO comes with 4 channels");
-}
-
-template <>
-void MemoryFactory<WideIO2>::validate(int channels, int ranks, const Config& configs) {
-    assert((channels == 4 || channels == 8) && "WideIO2 comes with 4 or 8 channels");
-    assert((ranks == 1 || ranks == 2) && "WideIO2 comes with 1 or 2 ranks");
-}
-
-template <>
-void MemoryFactory<HBM>::validate(int channels, int ranks, const Config& configs) {
-    assert(channels == 8 && "HBM comes with 8 channels");
-}
-
-template <>
-MemoryBase *MemoryFactory<WideIO2>::create(const Config& configs, int cacheline, bool enable_debug) {
-    int channels = stoi(configs["channels"], NULL, 0);
-    int ranks = stoi(configs["ranks"], NULL, 0);
-    validate(channels, ranks, configs);
-
-    const string& org_name = configs["org"];
-    const string& speed_name = configs["speed"];
-
-    WideIO2 *spec = new WideIO2(org_name, speed_name, channels);
-
-    extend_channel_width(spec, cacheline);
-
-    return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-}
-
-
-template <>
-MemoryBase *MemoryFactory<SALP>::create(const Config& configs, int cacheline, bool enable_debug) {
-    int channels = stoi(configs["channels"], NULL, 0);
-    int ranks = stoi(configs["ranks"], NULL, 0);
-    int subarrays = stoi(configs["subarrays"], NULL, 0);
-    validate(channels, ranks, configs);
-
-    const string& std_name = configs["standard"];
-    const string& org_name = configs["org"];
-    const string& speed_name = configs["speed"];
-
-    SALP *spec = new SALP(org_name, speed_name, std_name, subarrays);
-
-    extend_channel_width(spec, cacheline);
-
-    return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-}
-
-}
-
-// This function can be used by autoconf AC_CHECK_LIB since
-// apparently it can't detect C++ functions.
-// Basically just an entry in the symbol table
-extern "C"
-{
-    void libramulator_is_present(void)
-    {
-        ;
-    }
-}
diff --git a/ext/ramulator/Ramulator/src/MemoryFactory.h b/ext/ramulator/Ramulator/src/MemoryFactory.h
deleted file mode 100644
index f85d773b3..000000000
--- a/ext/ramulator/Ramulator/src/MemoryFactory.h
+++ /dev/null
@@ -1,86 +0,0 @@
-#ifndef __MEMORY_FACTORY_H
-#define __MEMORY_FACTORY_H
-
-#include <map>
-#include <string>
-#include <cassert>
-
-#include "Config.h"
-#include "Memory.h"
-
-#include "WideIO2.h"
-#include "SALP.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class MemoryFactory {
-public:
-    static void extend_channel_width(T* spec, int cacheline)
-    {
-        int channel_unit = spec->prefetch_size * spec->channel_width / 8;
-        int gang_number = cacheline / channel_unit;
-        
-        assert(gang_number >= 1 && 
-            "cacheline size must be greater or equal to minimum channel width");
-        
-        assert(cacheline == gang_number * channel_unit &&
-            "cacheline size must be a multiple of minimum channel width");
-        
-        spec->channel_width *= gang_number;
-    }
-
-    static Memory<T> *populate_memory(const Config& configs, T *spec, int channels, int ranks, bool enable_debug) {
-        int& default_ranks = spec->org_entry.count[int(T::Level::Rank)];
-        int& default_channels = spec->org_entry.count[int(T::Level::Channel)];
-
-        if (default_channels == 0) default_channels = channels;
-        if (default_ranks == 0) default_ranks = ranks;
-
-        vector<Controller<T> *> ctrls;
-        for (int c = 0; c < channels; c++){
-            DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
-            channel->id = c;
-            channel->regStats("");
-            ctrls.push_back(new Controller<T>(configs, channel, enable_debug));
-        }
-        
-        // daz3
-        std::cout << "Ramulator::channels " << channels << ", ::ranks " << ranks << ", ::enable_debug" << enable_debug << std::endl;
-
-        return new Memory<T>(configs, ctrls);
-    }
-
-    static void validate(int channels, int ranks, const Config& configs) {
-        assert(channels > 0 && ranks > 0);
-    }
-
-    static MemoryBase *create(const Config& configs, int cacheline, bool enable_debug)
-    {
-        int channels = stoi(configs["channels"], NULL, 0);
-        int ranks = stoi(configs["ranks"], NULL, 0);
-        
-        validate(channels, ranks, configs);
-
-        const string& org_name = configs["org"];
-        const string& speed_name = configs["speed"];
-
-        T *spec = new T(org_name, speed_name);
-
-        extend_channel_width(spec, cacheline);
-
-        return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-    }
-};
-
-template <>
-  MemoryBase *MemoryFactory<WideIO2>::create(const Config& configs, int cacheline, bool enable_debug);
-template <>
-  MemoryBase *MemoryFactory<SALP>::create(const Config& configs, int cacheline, bool enable_debug);
-
-} /*namespace ramulator*/
-
-#endif /*__MEMORY_FACTORY_H*/
diff --git a/ext/ramulator/Ramulator/src/PCM.cpp b/ext/ramulator/Ramulator/src/PCM.cpp
deleted file mode 100644
index 309ace8a1..000000000
--- a/ext/ramulator/Ramulator/src/PCM.cpp
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Benjamin C. Lee, Engin Ipek, Onur Mutlu, and Doug Burger. 2009.
-* Architecting phase change memory as a scalable dram alternative.
-* In Proceedings of the 36th annual international symposium on Computer architecture (ISCA '09).
-* ACM, New York, NY, USA, 2-13.
-* DOI: https://doi.org/10.1145/1555754.1555758
-*
-*/
-#include "PCM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string PCM::standard_name = "PCM";
-string PCM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum PCM::Org> PCM::org_map = {
-    {"PCM_512Mb_x4", PCM::Org::PCM_512Mb_x4}, {"PCM_512Mb_x8", PCM::Org::PCM_512Mb_x8}, {"PCM_512Mb_x16", PCM::Org::PCM_512Mb_x16},
-    {"PCM_1Gb_x4", PCM::Org::PCM_1Gb_x4}, {"PCM_1Gb_x8", PCM::Org::PCM_1Gb_x8}, {"PCM_1Gb_x16", PCM::Org::PCM_1Gb_x16},
-    {"PCM_2Gb_x4", PCM::Org::PCM_2Gb_x4}, {"PCM_2Gb_x8", PCM::Org::PCM_2Gb_x8}, {"PCM_2Gb_x16", PCM::Org::PCM_2Gb_x16},
-    {"PCM_4Gb_x4", PCM::Org::PCM_4Gb_x4}, {"PCM_4Gb_x8", PCM::Org::PCM_4Gb_x8}, {"PCM_4Gb_x16", PCM::Org::PCM_4Gb_x16},
-    {"PCM_8Gb_x4", PCM::Org::PCM_8Gb_x4}, {"PCM_8Gb_x8", PCM::Org::PCM_8Gb_x8}, {"PCM_8Gb_x16", PCM::Org::PCM_8Gb_x16},
-};
-
-map<string, enum PCM::Speed> PCM::speed_map = {
-    {"PCM_800D", PCM::Speed::PCM_800D}
-};
-
-
-PCM::PCM(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-PCM::PCM(const string& org_str, const string& speed_str) :
-    PCM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void PCM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void PCM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void PCM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = 0; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        default: assert(false);
-    }
-}
-
-
-void PCM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void PCM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void PCM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void PCM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<PCM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<PCM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<PCM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<PCM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void PCM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDact});
-    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nRRDact});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/PCM.h b/ext/ramulator/Ramulator/src/PCM.h
deleted file mode 100644
index 785d07d73..000000000
--- a/ext/ramulator/Ramulator/src/PCM.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Benjamin C. Lee, Engin Ipek, Onur Mutlu, and Doug Burger. 2009.
-* Architecting phase change memory as a scalable dram alternative.
-* In Proceedings of the 36th annual international symposium on Computer architecture (ISCA '09).
-* ACM, New York, NY, USA, 2-13.
-* DOI: https://doi.org/10.1145/1555754.1555758
-*
-*/
-#ifndef __PCM_H
-#define __PCM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class PCM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    PCM(Org org, Speed speed);
-    PCM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<PCM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<PCM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<PCM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<PCM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        PCM_512Mb_x4, PCM_512Mb_x8, PCM_512Mb_x16,
-        PCM_1Gb_x4,   PCM_1Gb_x8,   PCM_1Gb_x16,
-        PCM_2Gb_x4,   PCM_2Gb_x8,   PCM_2Gb_x16,
-        PCM_4Gb_x4,   PCM_4Gb_x8,   PCM_4Gb_x16,
-        PCM_8Gb_x4,   PCM_8Gb_x8,   PCM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        PCM_800D,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRDact, nRRDpre, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, 2.5, 4, 4, 2,  5,  22,  60,  5, 22, 60, 3, 3,  6, 2, 11, 0, 0, 3900, 0, 3, 10, 4, 0, 512},
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__PCM_H*/
diff --git a/ext/ramulator/Ramulator/src/Processor.cpp b/ext/ramulator/Ramulator/src/Processor.cpp
deleted file mode 100644
index bd94e5581..000000000
--- a/ext/ramulator/Ramulator/src/Processor.cpp
+++ /dev/null
@@ -1,473 +0,0 @@
-#include "Processor.h"
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-Processor::Processor(const Config& configs,
-    vector<const char*> trace_list,
-    function<bool(Request)> send_memory,
-    MemoryBase& memory)
-    : ipcs(trace_list.size(), -1),
-    early_exit(configs.is_early_exit()),
-    no_core_caches(!configs.has_core_caches()),
-    no_shared_cache(!configs.has_l3_cache()),
-    cachesys(new CacheSystem(configs, send_memory)),
-    llc(l3_size, l3_assoc, l3_blocksz,
-         mshr_per_bank * trace_list.size(),
-         Cache::Level::L3, cachesys) {
-
-  assert(cachesys != nullptr);
-  int tracenum = trace_list.size();
-  assert(tracenum > 0);
-  printf("tracenum: %d\n", tracenum);
-  for (int i = 0 ; i < tracenum ; ++i) {
-    printf("trace_list[%d]: %s\n", i, trace_list[i]);
-  }
-  if (no_shared_cache) {
-    for (int i = 0 ; i < tracenum ; ++i) {
-      cores.emplace_back(new Core(
-          configs, i, trace_list[i], send_memory, nullptr,
-          cachesys, memory));
-    }
-  } else {
-    for (int i = 0 ; i < tracenum ; ++i) {
-      cores.emplace_back(new Core(configs, i, trace_list[i],
-          std::bind(&Cache::send, &llc, std::placeholders::_1),
-          &llc, cachesys, memory));
-    }
-  }
-  for (int i = 0 ; i < tracenum ; ++i) {
-    cores[i]->callback = std::bind(&Processor::receive, this,
-        placeholders::_1);
-  }
-
-  // regStats
-  cpu_cycles.name("cpu_cycles")
-            .desc("cpu cycle number")
-            .precision(0)
-            ;
-  cpu_cycles = 0;
-}
-
-void Processor::tick() {
-  cpu_cycles++;
-
-  if((int(cpu_cycles.value()) % 50000000) == 0)
-      printf("CPU heartbeat, cycles: %d \n", (int(cpu_cycles.value())));
-
-  if (!(no_core_caches && no_shared_cache)) {
-    cachesys->tick();
-  }
-  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-    Core* core = cores[i].get();
-    core->tick();
-  }
-}
-
-void Processor::receive(Request& req) {
-  if (!no_shared_cache) {
-    llc.callback(req);
-  } else if (!cores[0]->no_core_caches) {
-    // Assume all cores have caches or don't have caches
-    // at the same time.
-    for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-      Core* core = cores[i].get();
-      core->caches[0]->callback(req);
-    }
-  }
-  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-    Core* core = cores[i].get();
-    core->receive(req);
-  }
-}
-
-bool Processor::finished() {
-  if (early_exit) {
-    for (unsigned int i = 0 ; i < cores.size(); ++i) {
-      if (cores[i]->finished()) {
-        for (unsigned int j = 0 ; j < cores.size() ; ++j) {
-          ipc += cores[j]->calc_ipc();
-        }
-        return true;
-      }
-    }
-    return false;
-  } else {
-    for (unsigned int i = 0 ; i < cores.size(); ++i) {
-      if (!cores[i]->finished()) {
-        return false;
-      }
-      if (ipcs[i] < 0) {
-        ipcs[i] = cores[i]->calc_ipc();
-        ipc += ipcs[i];
-      }
-    }
-    return true;
-  }
-}
-
-bool Processor::has_reached_limit() {
-  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-    if (!cores[i]->has_reached_limit()) {
-      return false;
-    }
-  }
-  return true;
-}
-
-long Processor::get_insts() {
-    long insts_total = 0;
-    for (unsigned int i = 0 ; i < cores.size(); i++) {
-        insts_total += cores[i]->get_insts();
-    }
-
-    return insts_total;
-}
-
-void Processor::reset_stats() {
-    for (unsigned int i = 0 ; i < cores.size(); i++) {
-        cores[i]->reset_stats();
-    }
-
-    ipc = 0;
-
-    for (unsigned int i = 0; i < ipcs.size(); i++)
-        ipcs[i] = -1;
-}
-
-Core::Core(const Config& configs, int coreid,
-    const char* trace_fname, function<bool(Request)> send_next,
-    Cache* llc, std::shared_ptr<CacheSystem> cachesys, MemoryBase& memory)
-    : id(coreid), no_core_caches(!configs.has_core_caches()),
-    no_shared_cache(!configs.has_l3_cache()),
-    llc(llc), trace(trace_fname), memory(memory)
-{
-  // set expected limit instruction for calculating weighted speedup
-  expected_limit_insts = configs.get_expected_limit_insts();
-  trace.expected_limit_insts = expected_limit_insts;
-
-  // Build cache hierarchy
-  if (no_core_caches) {
-    send = send_next;
-  } else {
-    // L2 caches[0]
-    caches.emplace_back(new Cache(
-        l2_size, l2_assoc, l2_blocksz, l2_mshr_num,
-        Cache::Level::L2, cachesys));
-    // L1 caches[1]
-    caches.emplace_back(new Cache(
-        l1_size, l1_assoc, l1_blocksz, l1_mshr_num,
-        Cache::Level::L1, cachesys));
-    send = bind(&Cache::send, caches[1].get(), placeholders::_1);
-    if (llc != nullptr) {
-      caches[0]->concatlower(llc);
-    }
-    caches[1]->concatlower(caches[0].get());
-
-    first_level_cache = caches[1].get();
-  }
-  if (no_core_caches) {
-    more_reqs = trace.get_filtered_request(
-        bubble_cnt, req_addr, req_type);
-    req_addr = memory.page_allocator(req_addr, id);
-  } else {
-    more_reqs = trace.get_unfiltered_request(
-        bubble_cnt, req_addr, req_type);
-    req_addr = memory.page_allocator(req_addr, id);
-  }
-
-  
-  // regStats
-  record_cycs.name("record_cycs_core_" + to_string(id))
-             .desc("Record cycle number for calculating weighted speedup. (Only valid when expected limit instruction number is non zero in config file.)")
-             .precision(0)
-             ;
-
-  record_insts.name("record_insts_core_" + to_string(id))
-              .desc("Retired instruction number when record cycle number. (Only valid when expected limit instruction number is non zero in config file.)")
-              .precision(0)
-              ;
-
-  memory_access_cycles.name("memory_access_cycles_core_" + to_string(id))
-                      .desc("memory access cycles in memory time domain")
-                      .precision(0)
-                      ;
-  memory_access_cycles = 0;
-  cpu_inst.name("cpu_instructions_core_" + to_string(id))
-          .desc("cpu instruction number")
-          .precision(0)
-          ;
-  cpu_inst = 0;
-}
-
-
-double Core::calc_ipc()
-{
-    printf("[%d]retired: %ld, clk, %ld\n", id, retired, clk);
-    return (double) retired / clk;
-}
-
-void Core::tick()
-{
-    clk++;
-
-    if(first_level_cache != nullptr)
-        first_level_cache->tick();
-
-    retired += window.retire();
-
-    if (expected_limit_insts == 0 && !more_reqs) return;
-
-    // bubbles (non-memory operations)
-    int inserted = 0;
-    while (bubble_cnt > 0) {
-        if (inserted == window.ipc) return;
-        if (window.is_full()) return;
-
-        window.insert(true, -1);
-        inserted++;
-        bubble_cnt--;
-        cpu_inst++;
-        if (long(cpu_inst.value()) == expected_limit_insts && !reached_limit) {
-          record_cycs = clk;
-          record_insts = long(cpu_inst.value());
-          memory.record_core(id);
-          reached_limit = true;
-        }
-    }
-
-    if (req_type == Request::Type::READ) {
-        // read request
-        if (inserted == window.ipc) return;
-        if (window.is_full()) return;
-
-        Request req(req_addr, req_type, callback, id);
-        if (!send(req)) return;
-
-        window.insert(false, req_addr);
-        cpu_inst++;
-    }
-    else {
-        // write request
-        assert(req_type == Request::Type::WRITE);
-        Request req(req_addr, req_type, callback, id);
-        if (!send(req)) return;
-        cpu_inst++;
-    }
-    if (long(cpu_inst.value()) == expected_limit_insts && !reached_limit) {
-      record_cycs = clk;
-      record_insts = long(cpu_inst.value());
-      memory.record_core(id);
-      reached_limit = true;
-    }
-
-    if (no_core_caches) {
-      more_reqs = trace.get_filtered_request(
-          bubble_cnt, req_addr, req_type);
-      if (req_addr != -1) {
-        req_addr = memory.page_allocator(req_addr, id);
-      }
-    } else {
-      more_reqs = trace.get_unfiltered_request(
-          bubble_cnt, req_addr, req_type);
-      if (req_addr != -1) {
-        req_addr = memory.page_allocator(req_addr, id);
-      }
-    }
-    if (!more_reqs) {
-      if (!reached_limit) { // if the length of this trace is shorter than expected length, then record it when the whole trace finishes, and set reached_limit to true.
-        // Hasan: overriding this behavior. We start the trace from the
-        // beginning until the requested amount of instructions are
-        // simulated. This should never be reached now.
-        assert((expected_limit_insts == 0) && "Shouldn't be reached when expected_limit_insts > 0 since we start over the trace");
-        record_cycs = clk;
-        record_insts = long(cpu_inst.value());
-        memory.record_core(id);
-        reached_limit = true;
-      }
-    }
-}
-
-bool Core::finished()
-{
-    return !more_reqs && window.is_empty();
-}
-
-bool Core::has_reached_limit() {
-  return reached_limit;
-}
-
-long Core::get_insts() {
-    return long(cpu_inst.value());
-}
-
-void Core::receive(Request& req)
-{
-    window.set_ready(req.addr, ~(l1_blocksz - 1l));
-    if (req.arrive != -1 && req.depart > last) {
-      memory_access_cycles += (req.depart - max(last, req.arrive));
-      last = req.depart;
-    }
-}
-
-void Core::reset_stats() {
-    clk = 0;
-    retired = 0;
-    cpu_inst = 0;
-}
-
-bool Window::is_full()
-{
-    return load == depth;
-}
-
-bool Window::is_empty()
-{
-    return load == 0;
-}
-
-
-void Window::insert(bool ready, long addr)
-{
-    assert(load <= depth);
-
-    ready_list.at(head) = ready;
-    addr_list.at(head) = addr;
-
-    head = (head + 1) % depth;
-    load++;
-}
-
-
-long Window::retire()
-{
-    assert(load <= depth);
-
-    if (load == 0) return 0;
-
-    int retired = 0;
-    while (load > 0 && retired < ipc) {
-        if (!ready_list.at(tail))
-            break;
-
-        tail = (tail + 1) % depth;
-        load--;
-        retired++;
-    }
-
-    return retired;
-}
-
-
-void Window::set_ready(long addr, int mask)
-{
-    if (load == 0) return;
-
-    for (int i = 0; i < load; i++) {
-        int index = (tail + i) % depth;
-        if ((addr_list.at(index) & mask) != (addr & mask))
-            continue;
-        ready_list.at(index) = true;
-    }
-}
-
-
-
-Trace::Trace(const char* trace_fname) : file(trace_fname), trace_name(trace_fname)
-{
-    if (!file.good()) {
-        std::cerr << "Bad trace file: " << trace_fname << std::endl;
-        exit(1);
-    }
-}
-
-bool Trace::get_unfiltered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type)
-{
-    string line;
-    getline(file, line);
-    if (file.eof()) {
-      file.clear();
-      file.seekg(0, file.beg);
-      getline(file, line);
-      //return false;
-    }
-    size_t pos, end;
-    bubble_cnt = std::stoul(line, &pos, 10);
-    pos = line.find_first_not_of(' ', pos+1);
-    req_addr = std::stoul(line.substr(pos), &end, 0);
-
-    pos = line.find_first_not_of(' ', pos+end);
-
-    if (pos == string::npos || line.substr(pos)[0] == 'R')
-        req_type = Request::Type::READ;
-    else if (line.substr(pos)[0] == 'W')
-        req_type = Request::Type::WRITE;
-    else assert(false);
-    return true;
-}
-
-bool Trace::get_filtered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type)
-{
-    static bool has_write = false;
-    static long write_addr;
-    static int line_num = 0;
-    if (has_write){
-        bubble_cnt = 0;
-        req_addr = write_addr;
-        req_type = Request::Type::WRITE;
-        has_write = false;
-        return true;
-    }
-    string line;
-    getline(file, line);
-    line_num ++;
-    if (file.eof() || line.size() == 0) {
-        file.clear();
-        file.seekg(0, file.beg);
-        line_num = 0;
-
-        if(expected_limit_insts == 0) {
-            has_write = false;
-            return false;
-        }
-        else { // starting over the input trace file
-            getline(file, line);
-            line_num++;
-        }
-    }
-
-    size_t pos, end;
-    bubble_cnt = std::stoul(line, &pos, 10);
-
-    pos = line.find_first_not_of(' ', pos+1);
-    req_addr = stoul(line.substr(pos), &end, 0);
-    req_type = Request::Type::READ;
-
-    pos = line.find_first_not_of(' ', pos+end);
-    if (pos != string::npos){
-        has_write = true;
-        write_addr = stoul(line.substr(pos), NULL, 0);
-    }
-    return true;
-}
-
-bool Trace::get_dramtrace_request(long& req_addr, Request::Type& req_type)
-{
-    string line;
-    getline(file, line);
-    if (file.eof()) {
-        return false;
-    }
-    size_t pos;
-    req_addr = std::stoul(line, &pos, 16);
-
-    pos = line.find_first_not_of(' ', pos+1);
-
-    if (pos == string::npos || line.substr(pos)[0] == 'R')
-        req_type = Request::Type::READ;
-    else if (line.substr(pos)[0] == 'W')
-        req_type = Request::Type::WRITE;
-    else assert(false);
-    return true;
-}
diff --git a/ext/ramulator/Ramulator/src/Processor.h b/ext/ramulator/Ramulator/src/Processor.h
deleted file mode 100644
index 0cdc46427..000000000
--- a/ext/ramulator/Ramulator/src/Processor.h
+++ /dev/null
@@ -1,149 +0,0 @@
-#ifndef __PROCESSOR_H
-#define __PROCESSOR_H
-
-#include "Cache.h"
-#include "Config.h"
-#include "Memory.h"
-#include "Request.h"
-#include "Statistics.h"
-#include <iostream>
-#include <vector>
-#include <fstream>
-#include <string>
-#include <ctype.h>
-#include <functional>
-
-namespace ramulator 
-{
-
-class Trace {
-public:
-    Trace(const char* trace_fname);
-    // trace file format 1:
-    // [# of bubbles(non-mem instructions)] [read address(dec or hex)] <optional: write address(evicted cacheline)>
-    bool get_unfiltered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type);
-    bool get_filtered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type);
-    // trace file format 2:
-    // [address(hex)] [R/W]
-    bool get_dramtrace_request(long& req_addr, Request::Type& req_type);
-
-    long expected_limit_insts = 0;
-
-private:
-    std::ifstream file;
-    std::string trace_name;
-};
-
-
-class Window {
-public:
-    int ipc = 4;
-    int depth = 128;
-
-    Window() : ready_list(depth), addr_list(depth, -1) {}
-    bool is_full();
-    bool is_empty();
-    void insert(bool ready, long addr);
-    long retire();
-    void set_ready(long addr, int mask);
-
-private:
-    int load = 0;
-    int head = 0;
-    int tail = 0;
-    std::vector<bool> ready_list;
-    std::vector<long> addr_list;
-};
-
-
-class Core {
-public:
-    long clk = 0;
-    long retired = 0;
-    int id = 0;
-    function<bool(Request)> send;
-
-    Core(const Config& configs, int coreid,
-        const char* trace_fname,
-        function<bool(Request)> send_next, Cache* llc,
-        std::shared_ptr<CacheSystem> cachesys, MemoryBase& memory);
-    void tick();
-    void receive(Request& req);
-    void reset_stats();
-    double calc_ipc();
-    bool finished();
-    bool has_reached_limit();
-    long get_insts(); // the number of the instructions issued to the core
-    function<void(Request&)> callback;
-
-    bool no_core_caches = true;
-    bool no_shared_cache = true;
-    int l1_size = 1 << 15;
-    int l1_assoc = 1 << 3;
-    int l1_blocksz = 1 << 6;
-    int l1_mshr_num = 16;
-
-    int l2_size = 1 << 18;
-    int l2_assoc = 1 << 3;
-    int l2_blocksz = 1 << 6;
-    int l2_mshr_num = 16;
-    std::vector<std::shared_ptr<Cache>> caches;
-    Cache* llc;
-
-    ScalarStat record_cycs;
-    ScalarStat record_insts;
-    long expected_limit_insts;
-    // This is set true iff expected number of instructions has been executed or all instructions are executed.
-    bool reached_limit = false;
-
-private:
-    Trace trace;
-    Window window;
-
-    long bubble_cnt;
-    long req_addr = -1;
-    Request::Type req_type;
-    bool more_reqs;
-    long last = 0;
-
-    Cache* first_level_cache = nullptr;
-
-    ScalarStat memory_access_cycles;
-    ScalarStat cpu_inst;
-    MemoryBase& memory;
-};
-
-class Processor {
-public:
-    Processor(const Config& configs, vector<const char*> trace_list,
-        function<bool(Request)> send, MemoryBase& memory);
-    void tick();
-    void receive(Request& req);
-    void reset_stats();
-    bool finished();
-    bool has_reached_limit();
-    long get_insts(); // the total number of instructions issued to all cores
-
-    std::vector<std::unique_ptr<Core>> cores;
-    std::vector<double> ipcs;
-    double ipc = 0;
-
-    // When early_exit is true, the simulation exits when the earliest trace finishes.
-    bool early_exit;
-
-    bool no_core_caches = true;
-    bool no_shared_cache = true;
-
-    int l3_size = 1 << 23;
-    int l3_assoc = 1 << 3;
-    int l3_blocksz = 1 << 6;
-    int mshr_per_bank = 16;
-
-    std::shared_ptr<CacheSystem> cachesys;
-    Cache llc;
-
-    ScalarStat cpu_cycles;
-};
-
-}
-#endif /* __PROCESSOR_H */
diff --git a/ext/ramulator/Ramulator/src/Refresh.cpp b/ext/ramulator/Ramulator/src/Refresh.cpp
deleted file mode 100644
index b3b59ce7f..000000000
--- a/ext/ramulator/Ramulator/src/Refresh.cpp
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Refresh.cpp
- *
- * Mainly DSARP specialization at the moment.
- *
- *  Created on: Mar 17, 2015
- *      Author: kevincha
- */
-
-#include <stdlib.h>
-
-#include "Refresh.h"
-#include "Controller.h"
-#include "DRAM.h"
-#include "DSARP.h"
-
-using namespace std;
-using namespace ramulator;
-
-namespace ramulator {
-
-/**** DSARP specialization ****/
-template<>
-Refresh<DSARP>::Refresh(Controller<DSARP>* ctrl) : ctrl(ctrl) {
-  clk = refreshed = 0;
-  max_rank_count = ctrl->channel->children.size();
-  max_bank_count = ctrl->channel->spec->org_entry.count[(int)DSARP::Level::Bank];
-  max_sa_count = ctrl->channel->spec->org_entry.count[(int)DSARP::Level::SubArray];
-
-  // Init refresh counters
-  for (int r = 0; r < max_rank_count; r++) {
-    bank_ref_counters.push_back(0);
-    bank_refresh_backlog.push_back(new vector<int>(max_bank_count, 0));
-    vector<int> sa_counters(ctrl->channel->spec->org_entry.count[(int)DSARP::Level::SubArray], 0);
-    subarray_ref_counters.push_back(sa_counters);
-  }
-
-  level_chan = (int)DSARP::Level::Channel;
-  level_rank = (int)DSARP::Level::Rank;
-  level_bank = (int)DSARP::Level::Bank;
-  level_sa   = (int)DSARP::Level::SubArray;
-}
-
-template<>
-void Refresh<DSARP>::early_inject_refresh() {
-  // Only enabled during reads
-  if (ctrl->write_mode)
-    return;
-
-  // OoO bank-level refresh
-  vector<bool> is_bank_occupied(max_rank_count * max_bank_count, false);
-  Controller<DSARP>::Queue& rdq = ctrl->readq;
-
-  // Figure out which banks are idle in order to refresh one of them
-  for (auto req: rdq.q)
-  {
-    assert(req.addr_vec[level_chan] == ctrl->channel->id);
-    int ridx = req.addr_vec[level_rank] * max_bank_count;
-    int bidx = req.addr_vec[level_bank];
-    is_bank_occupied[ridx+bidx] = true;
-  }
-
-  // Try to pick an idle bank to refresh per rank
-  for (int r = 0; r < max_rank_count; r++) {
-    // Randomly pick a bank to examine
-    int bidx_start = rand() % max_bank_count;
-
-    for (int b = 0; b < max_bank_count; b++)
-    {
-      int bidx = (bidx_start + b) % max_bank_count;
-      // Idle cycle only
-      if (is_bank_occupied[(r * max_bank_count) + bidx])
-        continue;
-
-      // Pending refresh
-      bool pending_ref = false;
-      for (Request req : ctrl->otherq.q)
-        if (req.type == Request::Type::REFRESH
-            && req.addr_vec[level_chan] == ctrl->channel->id
-            && req.addr_vec[level_rank] == r && req.addr_vec[level_bank] == bidx)
-          pending_ref = true;
-      if (pending_ref)
-        continue;
-
-      // Only pull in refreshes when we are almost running out of credits
-      if ((*(bank_refresh_backlog[r]))[bidx] >= backlog_early_pull_threshold ||
-          ctrl->otherq.q.size() >= ctrl->otherq.max)
-        continue;
-
-      // Refresh now
-      refresh_target(ctrl, r, bidx, subarray_ref_counters[r][bidx]);
-      // One credit for delaying a future ref
-      (*(bank_refresh_backlog[r]))[bidx]++;
-      subarray_ref_counters[r][bidx] = (subarray_ref_counters[r][bidx]+1) % max_sa_count;
-      break;
-    }
-  }
-}
-
-template<>
-void Refresh<DSARP>::inject_refresh(bool b_ref_rank) {
-  // Rank-level refresh
-  if (b_ref_rank)
-    for (auto rank : ctrl->channel->children)
-      refresh_target(ctrl, rank->id, -1, -1);
-  // Bank-level refresh. Simultaneously issue to all ranks (better performance than staggered refreshes).
-  else {
-    for (auto rank : ctrl->channel->children) {
-      int rid = rank->id;
-      int bid = bank_ref_counters[rid];
-
-      // Behind refresh schedule by 1 ref
-      (*(bank_refresh_backlog[rid]))[bid]--;
-
-      // Next time, refresh the next bank in the same bank
-      bank_ref_counters[rid] = (bank_ref_counters[rid] + 1) % max_bank_count;
-
-      // Check to see if we can skip a refresh
-      if (ctrl->channel->spec->type == DSARP::Type::DARP ||
-        ctrl->channel->spec->type == DSARP::Type::DSARP) {
-
-        bool ref_now = false;
-        // 1. Any pending refrehes?
-        bool pending_ref = false;
-        for (Request req : ctrl->otherq.q) {
-          if (req.type == Request::Type::REFRESH) {
-            pending_ref = true;
-            break;
-          }
-        }
-
-        // 2. Track readq
-        if (!pending_ref && ctrl->readq.size() == 0)
-          ref_now = true;
-
-        // 3. Track log status. If we are too behind the schedule, then we need to refresh now.
-        if ((*(bank_refresh_backlog[rid]))[bid] <= backlog_min)
-          ref_now = true;
-
-        // Otherwise skip refresh
-        if (!ref_now)
-          continue;
-      }
-
-      refresh_target(ctrl, rid, bid, subarray_ref_counters[rid][bid]);
-      // Get 1 ref credit
-      (*(bank_refresh_backlog[rid]))[bid]++;
-      // Next time, refresh the next sa in the same bank
-      subarray_ref_counters[rid][bid] = (subarray_ref_counters[rid][bid]+1) % max_sa_count;
-    }
-  }
-  refreshed = clk;
-}
-
-// first = wrq.count; second = bank idx
-typedef pair<int, int> wrq_idx;
-bool wrq_comp (wrq_idx l, wrq_idx r)
-{
-  return l.first < r.first;
-}
-
-// WRP
-template<>
-void Refresh<DSARP>::wrp() {
-  for (int ref_rid = 0; ref_rid < max_rank_count; ref_rid++)
-  {
-    // Pending refresh in the rank?
-    bool pending_ref = false;
-    for (Request req : ctrl->otherq.q) {
-      if (req.type == Request::Type::REFRESH && req.addr_vec[level_rank] == ref_rid) {
-        pending_ref = true;
-        break;
-      }
-    }
-    if (pending_ref)
-      continue;
-
-    // Find the bank with the lowest number of writes+reads
-    vector<wrq_idx> sorted_bank_demand;
-    for (int b = 0; b < max_bank_count; b++)
-      sorted_bank_demand.push_back(wrq_idx(0,b));
-    // Filter out all the writes to this rank
-    int total_wr = 0;
-    for (auto req : ctrl->writeq.q) {
-      if (req.addr_vec[level_rank] == ref_rid) {
-        sorted_bank_demand[req.addr_vec[level_bank]].first++;
-        total_wr++;
-      }
-    }
-    // If there's no write, just skip.
-    if (total_wr == 0)
-      continue;
-
-    // Add read
-    for (auto req : ctrl->readq.q)
-      if (req.addr_vec[level_rank] == ref_rid)
-        sorted_bank_demand[req.addr_vec[level_bank]].first++;
-
-    // Sort based on the entries
-    std::sort(sorted_bank_demand.begin(), sorted_bank_demand.end(), wrq_comp);
-
-    // Randomly select an idle bank to refresh
-    int top_idle_idx = 0;
-    for (int i = 0; i < max_bank_count; i++) {
-      if (sorted_bank_demand[i].second != 0) {
-        top_idle_idx = i;
-        break;
-      }
-    }
-
-    // Select a bank to ref
-    int ref_bid_idx = (top_idle_idx == 0) ? 0 : rand() % top_idle_idx;
-    int ref_bid = sorted_bank_demand[ref_bid_idx].second;
-
-    // Make sure we don't exceed the credit
-    if ((*(bank_refresh_backlog[ref_rid]))[ref_bid] < backlog_max
-        && ctrl->otherq.q.size() < ctrl->otherq.max) {
-      refresh_target(ctrl, ref_rid, ref_bid, subarray_ref_counters[ref_rid][ref_bid]);
-      // Get 1 ref credit
-      (*(bank_refresh_backlog[ref_rid]))[ref_bid]++;
-      subarray_ref_counters[ref_rid][ref_bid] = (subarray_ref_counters[ref_rid][ref_bid]+1) % max_sa_count;
-    }
-  }
-}
-
-// OoO refresh of DSARP
-template<>
-void Refresh<DSARP>::tick_ref() {
-  clk++;
-
-  bool b_ref_rank = ctrl->channel->spec->b_ref_rank;
-  int refresh_interval =
-      (b_ref_rank) ?
-          ctrl->channel->spec->speed_entry.nREFI :
-          ctrl->channel->spec->speed_entry.nREFIpb;
-
-  // DARP
-  if (ctrl->channel->spec->type == DSARP::Type::DARP ||
-    ctrl->channel->spec->type == DSARP::Type::DSARP) {
-    // Write-Refresh Parallelization. Issue refreshes when the controller enters writeback mode
-    if (!ctrl_write_mode && ctrl->write_mode)
-      wrp();
-    // Record write mode
-    ctrl_write_mode = ctrl->write_mode;
-    // Inject early to pull in some refreshes during read mode
-    early_inject_refresh();
-  }
-
-  // Time to schedule a refresh and also try to skip some refreshes
-  if ((clk - refreshed) >= refresh_interval)
-    inject_refresh(b_ref_rank);
-}
-/**** End DSARP specialization ****/
-
-} /* namespace ramulator */
diff --git a/ext/ramulator/Ramulator/src/Refresh.h b/ext/ramulator/Ramulator/src/Refresh.h
deleted file mode 100644
index 66d03040b..000000000
--- a/ext/ramulator/Ramulator/src/Refresh.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Refresh.h
- *
- * This is a refresh scheduler. A list of refresh policies implemented:
- *
- * 1. All-bank refresh
- * 2. Per-bank refresh (only DSARP memory module has been completed to work with REFpb).
- *     The other modules (LPDDRx) have not been updated to pass a knob to turn on/off REFpb.
- * 3. A re-implementation of DSARP from the refresh mechanisms proposed in Chang et al.,
- * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA 2014.
- *
- *  Created on: Mar 17, 2015
- *      Author: kevincha
- */
-
-#ifndef __REFRESH_H_
-#define __REFRESH_H_
-
-#include <stddef.h>
-#include <cassert>
-#include <iostream>
-#include <vector>
-
-#include "Request.h"
-#include "DSARP.h"
-#include "ALDRAM.h"
-
-using namespace std;
-using namespace ramulator;
-
-namespace ramulator {
-
-template <typename T>
-class Controller;
-
-template <typename T>
-class Refresh {
-public:
-  Controller<T>* ctrl;
-  long clk, refreshed;
-  // daz3
-  typedef struct _ref_cnt {
-      int rank_id;
-      long refreshed;
-      _ref_cnt(int _id, long _refreshed) {
-          rank_id = _id;
-          refreshed = _refreshed;
-      }
-  }RefCounter;
-  vector<RefCounter> refreshed_counters;
-
-  // Per-bank refresh counter to track the refresh progress for each rank
-  vector<int> bank_ref_counters;
-  int max_rank_count, max_bank_count;
-  int level_chan, level_rank, level_bank, level_sa;
-
-  // ctor
-  Refresh(Controller<T>* ctrl) : ctrl(ctrl) {
-    clk = refreshed = 0;
-    max_rank_count = ctrl->channel->children.size();
-    max_bank_count = ctrl->channel->spec->org_entry.count[(int)T::Level::Bank];
-
-    // Init refresh counters
-    for (int r = 0; r < max_rank_count; r++) {
-      bank_ref_counters.push_back(0);
-      bank_refresh_backlog.push_back(new vector<int>(max_bank_count, 0));
-    }
-
-    level_chan = (int)T::Level::Channel;
-    level_rank = (int)T::Level::Rank;
-    level_bank = (int)T::Level::Bank;
-    level_sa   = -1; // Most DRAM doesn't have subarray level
-
-    // daz3
-    int i = 0;
-    for (auto rank : ctrl->channel->children)
-    {
-        refreshed_counters.push_back(RefCounter(rank->id, (long)((ctrl->channel->spec->speed_entry.nREFI/ctrl->channel->spec->speed_entry.tCK)/max_rank_count) * (i+1) - ctrl->channel->spec->speed_entry.nREFI));
-        i++;
-    }
-  }
-
-  // dtor
-  virtual ~Refresh() {
-    // Clean up backlog
-    for (unsigned int i = 0; i < bank_refresh_backlog.size(); i++)
-      delete bank_refresh_backlog[i];
-  }
-
-  // Basic refresh scheduling for all bank refresh that is applicable to all DRAM types
-  // void tick_ref() {
-  //   clk++;
-  //
-  //   int refresh_interval = ctrl->channel->spec->speed_entry.nREFI;
-  //
-  //   // Time to schedule a refresh
-  //   if ((clk - refreshed) >= refresh_interval) {
-  //     inject_refresh(true);
-  //     // ALDRAM: update timing parameters based on temperatures
-  //     ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-  //     ctrl->update_temp(current_temperature);
-  //   }
-  // }
-  // daz3: stackle refresh
-  void tick_ref() {
-    clk++;
-    int refresh_interval = ctrl->channel->spec->speed_entry.nREFI;
-    // Time to schedule a refresh
-    for(int i = 0; i < max_rank_count; i++)
-    {
-        if ((clk - refreshed_counters[i].refreshed) >= refresh_interval) {
-            refresh_target(ctrl, refreshed_counters[i].rank_id, -1, -1);
-            // ALDRAM: update timing parameters based on temperatures
-            ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-            ctrl->update_temp(current_temperature);
-            refreshed_counters[i].refreshed = clk;
-        }
-    }
-  }
-
-private:
-  // Keeping track of refresh status of every bank: + means ahead of schedule, - means behind schedule
-  vector<vector<int>*> bank_refresh_backlog;
-  // Keeping track of which subarray to refresh next
-  vector<vector<int>> subarray_ref_counters;
-  int max_sa_count = 0;
-  // As defined in the standards
-  int backlog_max = 8;
-  int backlog_min = -8;
-  int backlog_early_pull_threshold = -6;
-  bool ctrl_write_mode = false;
-
-  // Refresh based on the specified address
-  void refresh_target(Controller<T>* ctrl, int rank, int bank, int sa)
-  {
-    vector<int> addr_vec(int(T::Level::MAX), -1);
-    addr_vec[0] = ctrl->channel->id;
-    addr_vec[1] = rank;
-    addr_vec[2] = bank;
-    addr_vec[3] = sa;
-    Request req(addr_vec, Request::Type::REFRESH, NULL);
-    bool res = ctrl->enqueue(req);
-    assert(res);
-  }
-
-  // Inject refresh at either rank or bank level
-  void inject_refresh(bool b_ref_rank) {
-    // Rank-level refresh
-    if (b_ref_rank) {
-      for (auto rank : ctrl->channel->children)
-        refresh_target(ctrl, rank->id, -1, -1);
-    }
-    // Bank-level refresh. Simultaneously issue to all ranks (better performance than staggered refreshes).
-    else {
-      for (auto rank : ctrl->channel->children)
-        refresh_target(ctrl, rank->id, bank_ref_counters[rank->id], -1);
-    }
-    refreshed = clk;
-  }
-
-  // DSARP
-  void early_inject_refresh();
-  void wrp();
-};
-
-// Declaration of specialized constructor and tick_ref, so the compiler knows
-// where to look for these definitions when controller calls them!
-template<> Refresh<DSARP>::Refresh(Controller<DSARP>* ctrl);
-template<> void Refresh<DSARP>::tick_ref();
-
-} /* namespace ramulator */
-
-#endif /* SRC_REFRESH_H_ */
diff --git a/ext/ramulator/Ramulator/src/Request.h b/ext/ramulator/Ramulator/src/Request.h
deleted file mode 100644
index da733961b..000000000
--- a/ext/ramulator/Ramulator/src/Request.h
+++ /dev/null
@@ -1,103 +0,0 @@
-#ifndef __REQUEST_H
-#define __REQUEST_H
-
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class Request
-{
-public:
-    bool is_first_command;
-    long addr;
-    // long addr_row;
-    vector<int> addr_vec;
-    // specify which core this request sent from, for virtual address translation
-    int coreid;
-
-    enum class Type
-    {
-        READ,
-        WRITE,
-        REFRESH,
-        POWERDOWN,
-        SELFREFRESH,
-        EXTENSION,
-        MAX
-    } type;
-
-    long arrive = -1;
-    long depart;
-    function<void(Request&)> callback; // call back with more info
-    // gagan : is prefetch
-    bool is_prefetch;
-
- Request(long addr, Type type, int coreid = 0)
-      : is_first_command(true), addr(addr), coreid(coreid), type(type), callback([](Request& req){}), is_prefetch(false) {}
-
- Request(long addr, Type type, function<void(Request&)> callback,  bool is_prefetch, int coreid = 0)
-   : is_first_command(true), addr(addr), coreid(coreid), type(type), callback(callback), is_prefetch(is_prefetch) {}
-
- Request(vector<int>& addr_vec, Type type, function<void(Request&)> callback, bool is_prefetch = false, int coreid = 0)
-      : is_first_command(true), addr_vec(addr_vec), coreid(coreid), type(type), callback(callback) {}
-
-    Request()
-        : is_first_command(true), coreid(0) {}
-
-    void print()
-    {
-      switch(type)
-	{
-	case Request::Type::READ:
-	  std::cout << "[READ] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::WRITE:
-	  assert(is_prefetch == false);
-	  std::cout << "[WRITE] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::REFRESH:
-	  assert(is_prefetch == false);
-	  std::cout << "[REFRESH] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::POWERDOWN:
-	  assert(is_prefetch == false);
-	  std::cout << "[POWERDOWN] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::SELFREFRESH:
-	  assert(is_prefetch == false);
-	  std::cout << "[SELFREFRESH] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::EXTENSION:
-	  assert(is_prefetch == false);
-	  std::cout << "[EXTENSION] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::MAX:
-	  assert(is_prefetch == false);
-	  std::cout << "[MAX] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	default:
-	  std::cout << "Invalid Request" << std::endl;
-	}
-    }
-
-    int getRank()
-    {
-      return addr_vec[1];
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__REQUEST_H*/
-
diff --git a/ext/ramulator/Ramulator/src/SALP.cpp b/ext/ramulator/Ramulator/src/SALP.cpp
deleted file mode 100644
index 843e5f6d8..000000000
--- a/ext/ramulator/Ramulator/src/SALP.cpp
+++ /dev/null
@@ -1,648 +0,0 @@
-#include "SALP.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace ramulator;
-
-string SALP::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Sa", "Ro", "Co"};
-
-map<string, enum SALP::Org> SALP::org_map = {
-    {"SALP_512Mb_x4", SALP::Org::SALP_512Mb_x4}, {"SALP_512Mb_x8", SALP::Org::SALP_512Mb_x8}, {"SALP_512Mb_x16", SALP::Org::SALP_512Mb_x16},
-    {"SALP_1Gb_x4", SALP::Org::SALP_1Gb_x4}, {"SALP_1Gb_x8", SALP::Org::SALP_1Gb_x8}, {"SALP_1Gb_x16", SALP::Org::SALP_1Gb_x16},
-    {"SALP_2Gb_x4", SALP::Org::SALP_2Gb_x4}, {"SALP_2Gb_x8", SALP::Org::SALP_2Gb_x8}, {"SALP_2Gb_x16", SALP::Org::SALP_2Gb_x16},
-    {"SALP_4Gb_x4", SALP::Org::SALP_4Gb_x4}, {"SALP_4Gb_x8", SALP::Org::SALP_4Gb_x8}, {"SALP_4Gb_x16", SALP::Org::SALP_4Gb_x16},
-    {"SALP_8Gb_x4", SALP::Org::SALP_8Gb_x4}, {"SALP_8Gb_x8", SALP::Org::SALP_8Gb_x8}, {"SALP_8Gb_x16", SALP::Org::SALP_8Gb_x16},
-};
-
-map<string, enum SALP::Speed> SALP::speed_map = {
-    {"SALP_800D", SALP::Speed::SALP_800D}, {"SALP_800E", SALP::Speed::SALP_800E},
-    {"SALP_1066E", SALP::Speed::SALP_1066E}, {"SALP_1066F", SALP::Speed::SALP_1066F}, {"SALP_1066G", SALP::Speed::SALP_1066G},
-    {"SALP_1333G", SALP::Speed::SALP_1333G}, {"SALP_1333H", SALP::Speed::SALP_1333H},
-    {"SALP_1600H", SALP::Speed::SALP_1600H}, {"SALP_1600J", SALP::Speed::SALP_1600J}, {"SALP_1600K", SALP::Speed::SALP_1600K},
-    {"SALP_1866K", SALP::Speed::SALP_1866K}, {"SALP_1866L", SALP::Speed::SALP_1866L},
-    {"SALP_2133L", SALP::Speed::SALP_2133L}, {"SALP_2133M", SALP::Speed::SALP_2133M},
-};
-
-map<string, enum SALP::Type> SALP::type_map = {
-    {"SALP-1", SALP::Type::SALP_1},
-    {"SALP-2", SALP::Type::SALP_2},
-    {"SALP-MASA", SALP::Type::MASA},
-};
-
-SALP::SALP(Org org, Speed speed, Type type, int n_sa) :
-    type(type),
-    n_sa(n_sa),
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    switch(int(type)){
-        case int(Type::SALP_1): standard_name = "SALP-1"; break;
-        case int(Type::SALP_2): standard_name = "SALP-2"; break;
-        case int(Type::MASA):   standard_name = "SALP-MASA"; break;
-    }
-    if (type == Type::SALP_1) {
-      scope[int(Command::PRE)] = Level::Bank;
-    }
-    assert(n_sa && n_sa <= 128 && (n_sa & (n_sa-1)) == 0); // is power of 2, within [1, 128]
-    org_entry.count[int(Level::SubArray)] = n_sa;
-    long tmp = long(org_entry.dq) * org_entry.count[int(Level::Bank)] * n_sa * org_entry.count[int(Level::Column)];
-    org_entry.count[int(Level::Row)] = long(org_entry.size) * (1<<20) / tmp;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-SALP::SALP(const string& org_str, const string& speed_str, const string& type_str, int n_sa) :
-    SALP(org_map[org_str], speed_map[speed_str], type_map[type_str], n_sa)
-{
-}
-
-void SALP::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void SALP::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void SALP::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void SALP::init_prereq()
-{
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-
-    switch(int(type)){
-        case int(Type::SALP_1):
-            prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return Command::ACT;
-                    case int(State::Opened):
-                        return Command::MAX;
-                    default: assert(false);}};
-            prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-              if (node->row_state.find(id) != node->row_state.end()) {
-                return cmd;
-              } else if (node->row_state.size()) {
-                return Command::PRE;
-              } else {
-                return Command::PRE_OTHER;
-              }
-            };
-            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                for (auto bank : node->children) {
-                    if (bank->state == State::Closed)
-                        continue;
-                    return Command::PRER;
-                }
-                return Command::REF;};
-            break;
-        case int(Type::SALP_2):
-            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return Command::ACT;
-                    case int(State::Opened):
-                        if (node->row_state.find(id) != node->row_state.end()) {
-                          for (auto sa : node->parent->children) {
-                              if (sa != node && sa->state == State::Opened) {
-                                  return Command::PRE_OTHER;
-                              }
-                          }
-                          return cmd;
-                        } else {
-                          // if this subarray has another row open, close it
-                          // first
-                          return Command::PRE;
-                        }
-                    default: assert(false);}};
-            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        if (sa->state == State::Closed)
-                            continue;
-                        return Command::PRER;
-                    }
-                return Command::REF;};
-            break;
-        case int(Type::MASA):
-            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return Command::ACT;
-                    case int(State::Opened):
-                        if (node->row_state.find(id) != node->row_state.end()) return Command::SASEL;
-                        else return Command::PRE;
-                    case int(State::Selected):
-                        if (node->row_state.find(id) != node->row_state.end()) return cmd;
-                        else return Command::PRE;
-                    default: assert(false);
-                }};
-            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children){
-                        if (sa->state == State::Closed)
-                            continue;
-                        return Command::PRER;
-                    }
-                return Command::REF;};
-            break;
-        default: assert(false);
-    }
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void SALP::init_rowhit()
-{
-    switch(int(type)) {
-        case int(Type::SALP_1):
-            // RD
-            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-              switch (int(node->state)) {
-                case int(State::Closed): return false;
-                case int(State::Opened):
-                  if (node->row_state.find(id) != node->row_state.end())  return true;
-                  else return false;
-                default: assert(false);
-              }
-            };
-            // WR
-            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-            break;
-        case int(Type::SALP_2):
-            // RD
-            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened):
-                        if (node->row_state.find(id) != node->row_state.end()) return true;
-                        else return false;
-                    default: assert(false);
-                }};
-            // WR
-            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-            break;
-        case int(Type::MASA):
-            // RD
-            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened):
-                        // opened but not selected still counts as a row hit
-                        if (node->row_state.find(id) != node->row_state.end()) return true;
-                        else return false;
-                    case int(State::Selected):
-                        if (node->row_state.find(id) != node->row_state.end()) return true;
-                        else return false;
-                    default: assert(false);
-                }};
-            // WR
-            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-            break;
-        default: assert(false);
-    }
-}
-
-void SALP::init_rowopen()
-{
-    switch(int(type)) {
-        case int(Type::SALP_1):
-            // RD
-            rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened): return true;
-                    default: assert(false);
-                }};
-            // WR
-            rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-            break;
-        case int(Type::SALP_2):
-            // RD
-            rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened): return true;
-                    default: assert(false);
-                }};
-            // WR
-            rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-            break;
-        case int(Type::MASA):
-            // RD
-            rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened): return true;
-                    case int(State::Selected): return true;
-                    default: assert(false);
-                }};
-            // WR
-            rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-            break;
-        default: assert(false);
-    }
-}
-
-void SALP::init_lambda()
-{
-    switch(int(type)){
-        case int(Type::SALP_1):
-            lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Opened;
-            };
-            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-              node->state = State::Opened;
-              node->row_state[id] = State::Opened;
-            };
-            lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                // For SALP_1, we stick to original design that allows
-                // only one row in a bank open, so here close subarray id
-                // is equivalent to close the whole bank
-                node->children[id]->state = State::Closed;
-                node->children[id]->row_state.clear();
-                };
-            lambda[int(Level::Bank)][int(Command::PRE_OTHER)] = lambda[int(Level::Bank)][int(Command::PRE)];
-            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children) {
-                    bank->state = State::Closed;
-                    for (auto sa : bank->children){
-                        sa->state = State::Closed;
-                        sa->row_state.clear();}}};
-            lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->children[id]->state = State::Closed;
-                node->children[id]->row_state.clear();};
-            lambda[int(Level::Bank)][int(Command::WRA)] = lambda[int(Level::Bank)][int(Command::RDA)];
-            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children) {
-                    if (bank->state == State::Closed)
-                        continue;
-                    node->state = State::ActPowerDown;
-                    return;
-                }
-                node->state = State::PrePowerDown;};
-            break;
-        case int(Type::SALP_2):
-            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Opened;
-                node->row_state[id] = State::Opened;};
-            lambda[int(Level::SubArray)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::SubArray)][int(Command::PRE_OTHER)] = lambda[int(Level::SubArray)][int(Command::PRE)];
-            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        sa->state = State::Closed;
-                        sa->row_state.clear();}};
-            lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        if (sa->state == State::Closed)
-                            continue;
-                        node->state = State::ActPowerDown;
-                        return;
-                    }
-                node->state = State::PrePowerDown;};
-            break;
-        case int(Type::MASA):
-            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Selected;
-                node->row_state[id] = State::Opened;
-                for (auto sa : node->parent->children)
-                    if (sa != node && sa->state == State::Selected) {
-                        sa->state = State::Opened;
-                        break;}};
-            lambda[int(Level::SubArray)][int(Command::SASEL)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Selected;
-                for (auto sa : node->parent->children)
-                    if (sa != node && sa->state == State::Selected) {
-                        sa->state = State::Opened;
-                        break;}};
-            lambda[int(Level::SubArray)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-
-            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        sa->state = State::Closed;
-                        sa->row_state.clear();}};
-            lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        if (sa->state == State::Closed)
-                            continue;
-                        node->state = State::ActPowerDown;
-                        return;
-                    }
-                node->state = State::PrePowerDown;};
-            break;
-        default: assert(false);
-    }
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<SALP>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<SALP>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<SALP>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-void SALP::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PRER
-    t[int(Command::RD)].push_back({Command::PRER, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRER, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> REF: none (all banks have to be precharged)
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-
-    t[int(Command::ACT)].push_back({Command::PRER, 1, s.nRAS});
-    t[int(Command::PRER)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PRER)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PRE_OTHER)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRER, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PRER)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PRE_OTHER)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    switch(int(type)) {
-        case int(Type::SALP_1):
-          // memory controller doesn't specify a row to precharge,
-          // all subarrays are precharged together, so we should check
-          // whether other activation/column access are still ongoing.
-          t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-          t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-          t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR,});
-          t[int(Command::ACT)].push_back({Command::PRE_OTHER, 1, s.nRAS});
-          t[int(Command::RD)].push_back({Command::PRE_OTHER, 1, s.nRTP});
-          t[int(Command::WR)].push_back({Command::PRE_OTHER, 1, s.nCWL + s.nBL + s.nWR,});
-        case int(Type::SALP_2):
-        case int(Type::MASA):
-        break;
-        default: assert(false);
-    }
-
-    /*** SubArray ***/
-    t = timing[int(Level::SubArray)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-
-    switch(int(type)) {
-        case int(Type::SALP_1):
-        case int(Type::SALP_2):
-        break;
-        case int(Type::MASA):
-          t[int(Command::SASEL)].push_back({Command::RD, 1, s.nSCD});
-          t[int(Command::SASEL)].push_back({Command::RDA, 1, s.nSCD});
-          t[int(Command::SASEL)].push_back({Command::WR, 1, s.nSCD});
-          t[int(Command::SASEL)].push_back({Command::WRA, 1, s.nSCD});
-        break;
-        default: assert(false);
-    }
-
-    // sibling subarray constraints
-    switch(int(type)) {
-        case int(Type::SALP_1):
-          t[int(Command::PRE)].push_back({Command::ACT, 1, s.nPA, true});
-          t[int(Command::PRE_OTHER)].push_back({Command::ACT, 1, s.nPA, true});
-          // for auto precharge command
-          t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC - s.nRP + s.nPA, true});
-          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nPA, true});
-          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nPA, true});
-        break;
-
-        case int(Type::SALP_2):
-          t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRCD + s.nRA, true});
-          t[int(Command::RD)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::ACT, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nWA, true});
-        break;
-        case int(Type::MASA):
-          t[int(Command::RD)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::ACT, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nWA, true});
-
-          t[int(Command::RD)].push_back({Command::SASEL, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::SASEL, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::SASEL, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::SASEL, 1, s.nWA, true});
-
-          t[int(Command::RD)].push_back({Command::RD, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::RDA, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::WR, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::WRA, 1, s.nWA, true});
-        break;
-        default: assert(false);
-    }
-    // between sibling subarrays
-}
diff --git a/ext/ramulator/Ramulator/src/SALP.h b/ext/ramulator/Ramulator/src/SALP.h
deleted file mode 100644
index 8eceb5a94..000000000
--- a/ext/ramulator/Ramulator/src/SALP.h
+++ /dev/null
@@ -1,231 +0,0 @@
-#ifndef __SALP_H
-#define __SALP_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class SALP
-{
-public:
-    string standard_name;
-    enum class Org;
-    enum class Speed;
-    enum class Type;
-    SALP(Org org, Speed speed, Type type = Type::MASA, int n_sa = 8);
-    SALP(const string& org_str, const string& speed_str, const string& type_str = "SALP-MASA", int n_sa = 8);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    static map<string, enum Type> type_map;
-
-    enum class Type : int
-    {
-        SALP_1, SALP_2, MASA, MAX
-    } type;
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, SubArray, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, SASEL, PRE, PRER, // precharge bank/bank/rank(SALP-1), subarray/bank/rank(SALP-2, MASA)
-        RD,  WR,    RDA, WRA, // auto-precharge: bank(SALP-1), subarray(SALP-2, MASA)
-        REF, PDE,   PDX, SRE, SRX, 
-        PRE_OTHER,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "SASEL", "PRE", "PRER",
-        "RD",  "WR",    "RDA", "WRA",
-        "REF", "PDE",   "PDX", "SRE", "SRX", "PRE_OTHER"
-    };
-
-    // The scope of each command
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::SubArray, Level::SubArray, Level::Rank,
-        Level::Column, Level::Column,   Level::Column,   Level::Column,
-        Level::Rank,   Level::Rank,     Level::Rank,     Level::Rank,   Level::Rank, Level::SubArray
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRER):
-            case int(Command::PRE_OTHER):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, Selected, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<SALP>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<SALP>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<SALP>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<SALP>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        SALP_512Mb_x4, SALP_512Mb_x8, SALP_512Mb_x16,
-        SALP_1Gb_x4,   SALP_1Gb_x8,   SALP_1Gb_x16,
-        SALP_2Gb_x4,   SALP_2Gb_x8,   SALP_2Gb_x16,
-        SALP_4Gb_x4,   SALP_4Gb_x8,   SALP_4Gb_x16,
-        SALP_8Gb_x4,   SALP_8Gb_x8,   SALP_8Gb_x16,
-        MAX
-    };
-
-    int n_sa; // number of subarrays per bank
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 0, 0, 1<<11}}, {  512,  8, {0, 0, 8, 0, 0, 1<<10}}, {  512, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {1<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {1<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {2<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {2<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {4<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {4<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 0, 0, 1<<12}}, {8<<10,  8, {0, 0, 8, 0, 0, 1<<11}}, {8<<10, 16, {0, 0, 8, 0, 0, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        SALP_800D,  SALP_800E,
-        SALP_1066E, SALP_1066F, SALP_1066G,
-        SALP_1333G, SALP_1333H,
-        SALP_1600H, SALP_1600J, SALP_1600K,
-        SALP_1866K, SALP_1866L,
-        SALP_2133L, SALP_2133M,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nPA, nCWL; // nRP for pre2act same sa, nPA for pre2act diff sa (1 cycle)
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR, nRA, nWA; // nRA = nCL/2, nWA = nCWL + nBL + nWR/2
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-        int nSCD;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5, 1,  5, 15, 20, 4, 4,  6, 3, 12, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512, 1},
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6, 1,  5, 15, 21, 4, 4,  6, 3, 12, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512, 1},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6, 1,  6, 20, 26, 4, 4,  8, 3, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7, 1,  6, 20, 27, 4, 4,  8, 4, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8, 1,  6, 20, 28, 4, 4,  8, 4, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8, 1,  7, 24, 32, 5, 5, 10, 4, 16, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512, 1},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9, 1,  7, 24, 33, 5, 5, 10, 5, 16, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512, 1},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9, 1,  8, 28, 37, 6, 6, 12, 5, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10, 1,  8, 28, 38, 6, 6, 12, 5, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11, 1,  8, 28, 39, 6, 6, 12, 6, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11, 1,  9, 32, 43, 7, 7, 14, 6, 20, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512, 1},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12, 1,  9, 32, 44, 7, 7, 14, 6, 20, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512, 1},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 1, 10, 36, 48, 8, 8, 16, 6, 22, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512, 1},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 1, 10, 36, 49, 8, 8, 16, 7, 22, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512, 1}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__SALP_H*/
diff --git a/ext/ramulator/Ramulator/src/STTMRAM.cpp b/ext/ramulator/Ramulator/src/STTMRAM.cpp
deleted file mode 100644
index 830867cfd..000000000
--- a/ext/ramulator/Ramulator/src/STTMRAM.cpp
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Kazi Asifuzzaman, Rommel Sanchez Verdejo, and Petar Radojkovic.2017.
-* Enabling a reliable STT-MRAM main memory simulation.
-* In Proceedings of the International Symposium on Memory Systems (MEMSYS '17).
-* Washington DC, USA, 283-292. DOI: https://doi.org/10.1145/3132402.3132416
-*
-*/
-#include "STTMRAM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-#include <math.h>
-
-using namespace std;
-using namespace ramulator;
-
-string STTMRAM::standard_name = "STTMRAM";
-string STTMRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum STTMRAM::Org> STTMRAM::org_map = {
-    {"STTMRAM_512Mb_x4", STTMRAM::Org::STTMRAM_512Mb_x4}, {"STTMRAM_512Mb_x8", STTMRAM::Org::STTMRAM_512Mb_x8}, {"STTMRAM_512Mb_x16", STTMRAM::Org::STTMRAM_512Mb_x16},
-    {"STTMRAM_1Gb_x4", STTMRAM::Org::STTMRAM_1Gb_x4}, {"STTMRAM_1Gb_x8", STTMRAM::Org::STTMRAM_1Gb_x8}, {"STTMRAM_1Gb_x16", STTMRAM::Org::STTMRAM_1Gb_x16},
-    {"STTMRAM_2Gb_x4", STTMRAM::Org::STTMRAM_2Gb_x4}, {"STTMRAM_2Gb_x8", STTMRAM::Org::STTMRAM_2Gb_x8}, {"STTMRAM_2Gb_x16", STTMRAM::Org::STTMRAM_2Gb_x16},
-    {"STTMRAM_4Gb_x4", STTMRAM::Org::STTMRAM_4Gb_x4}, {"STTMRAM_4Gb_x8", STTMRAM::Org::STTMRAM_4Gb_x8}, {"STTMRAM_4Gb_x16", STTMRAM::Org::STTMRAM_4Gb_x16},
-    {"STTMRAM_8Gb_x4", STTMRAM::Org::STTMRAM_8Gb_x4}, {"STTMRAM_8Gb_x8", STTMRAM::Org::STTMRAM_8Gb_x8}, {"STTMRAM_8Gb_x16", STTMRAM::Org::STTMRAM_8Gb_x16},
-};
-
-map<string, enum STTMRAM::Speed> STTMRAM::speed_map = {
-    {"STT_1600_1_2", STTMRAM::Speed::STT_1600_1_2}, {"STT_1600_1_5", STTMRAM::Speed::STT_1600_1_5}, {"STT_1600_2_0", STTMRAM::Speed::STT_1600_2_0},
-};
-
-
-STTMRAM::STTMRAM(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-STTMRAM::STTMRAM(const string& org_str, const string& speed_str) :
-    STTMRAM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void STTMRAM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void STTMRAM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void STTMRAM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-          case 1600: speed_entry.nRRD = ceil(speed_entry.nRRD  * ((page==1) ? 5 : 6) /10.0); speed_entry.nFAW = ceil(speed_entry.nFAW *((page==1) ? 24 : 32)/10.0); break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 1600: speed_entry.nRFC = 1; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-          case 1600: speed_entry.nXS  = ceil(speed_entry.nXS * ((chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288) /10.0); break;
-        default: assert(false);
-    }
-}
-
-
-void STTMRAM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void STTMRAM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void STTMRAM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void STTMRAM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<STTMRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<STTMRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<STTMRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<STTMRAM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void STTMRAM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/STTMRAM.h b/ext/ramulator/Ramulator/src/STTMRAM.h
deleted file mode 100644
index 1698b1a52..000000000
--- a/ext/ramulator/Ramulator/src/STTMRAM.h
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Kazi Asifuzzaman, Rommel Sanchez Verdejo, and Petar Radojkovic.2017.
-* Enabling a reliable STT-MRAM main memory simulation.
-* In Proceedings of the International Symposium on Memory Systems (MEMSYS '17).
-* Washington DC, USA, 283-292. DOI: https://doi.org/10.1145/3132402.3132416
-*
-*/
-#ifndef __STTMRAM_H
-#define __STTMRAM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class STTMRAM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    STTMRAM(Org org, Speed speed);
-    STTMRAM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<STTMRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<STTMRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<STTMRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<STTMRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        STTMRAM_512Mb_x4, STTMRAM_512Mb_x8, STTMRAM_512Mb_x16,
-        STTMRAM_1Gb_x4,   STTMRAM_1Gb_x8,   STTMRAM_1Gb_x16,
-        STTMRAM_2Gb_x4,   STTMRAM_2Gb_x8,   STTMRAM_2Gb_x16,
-        STTMRAM_4Gb_x4,   STTMRAM_4Gb_x8,   STTMRAM_4Gb_x16,
-        STTMRAM_8Gb_x4,   STTMRAM_8Gb_x8,   STTMRAM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        STT_1600_1_2, STT_1600_1_5, STT_1600_2_0,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 14,  14,  8,   20,   34,  6,    6,   12,  12,   12,   1,    6240, 4, 5, 20,        5,     0,   512}, //1.2x
-          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 17,  17,  8,   23,   40,  6,    6,   12,  15,   15,   1,    6240, 4, 5, 20,        5,     0,   512}, //1.5x
-          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 22,  22,  8,   28,   50,  6,    6,   12,  20,   20,   1,    6240, 4, 5, 20,        5,     0,   512}, //2.0x
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__STTMRAM_H*/
diff --git a/ext/ramulator/Ramulator/src/Scheduler.h b/ext/ramulator/Ramulator/src/Scheduler.h
deleted file mode 100644
index 0a328c3d9..000000000
--- a/ext/ramulator/Ramulator/src/Scheduler.h
+++ /dev/null
@@ -1,357 +0,0 @@
-#ifndef __SCHEDULER_H
-#define __SCHEDULER_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include "Controller.h"
-#include <vector>
-#include <map>
-#include <list>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class Controller;
-
-template <typename T>
-class Scheduler
-{
-public:
-    Controller<T>* ctrl;
-
-    enum class Type {
-      FCFS, FRFCFS, FRFCFS_Cap, FRFCFS_PriorHit, FRFCFS_DepPre, MAX
-    } type = Type::FRFCFS_PriorHit;
-    //} type = Type::FCFS;
-
-    long cap = 16;
-
-    Scheduler(Controller<T>* ctrl) : ctrl(ctrl) {}
-
-    list<Request>::iterator get_head(list<Request>& q)
-    {
-      // TODO make the decision at compile time
-      if (type != Type::FRFCFS_PriorHit) {
-        if (!q.size())
-            return q.end();
-
-        auto head = q.begin();
-        for (auto itr = next(q.begin(), 1); itr != q.end(); itr++)
-            head = compare[int(type)](head, itr);
-
-        return head;
-      } else {
-        if (!q.size())
-            return q.end();
-
-        auto head = q.begin();
-        for (auto itr = next(q.begin(), 1); itr != q.end(); itr++) {
-            head = compare[int(Type::FRFCFS_PriorHit)](head, itr);
-        }
-
-        if (this->ctrl->is_ready(head) && this->ctrl->is_row_hit(head)) {
-          return head;
-        }
-
-        // prepare a list of hit request
-        vector<vector<int>> hit_reqs;
-        for (auto itr = q.begin() ; itr != q.end() ; ++itr) {
-          if (this->ctrl->is_row_hit(itr)) {
-            auto begin = itr->addr_vec.begin();
-            // TODO Here it assumes all DRAM standards use PRE to close a row
-            // It's better to make it more general.
-            auto end = begin + int(ctrl->channel->spec->scope[int(T::Command::PRE)]) + 1;
-            vector<int> rowgroup(begin, end); // bank or subarray
-            hit_reqs.push_back(rowgroup);
-          }
-        }
-        // if we can't find proper request, we need to return q.end(),
-        // so that no command will be scheduled
-        head = q.end();
-        for (auto itr = q.begin(); itr != q.end(); itr++) {
-          bool violate_hit = false;
-          if ((!this->ctrl->is_row_hit(itr)) && this->ctrl->is_row_open(itr)) {
-            // so the next instruction to be scheduled is PRE, might violate hit
-            auto begin = itr->addr_vec.begin();
-            // TODO Here it assumes all DRAM standards use PRE to close a row
-            // It's better to make it more general.
-            auto end = begin + int(ctrl->channel->spec->scope[int(T::Command::PRE)]) + 1;
-            vector<int> rowgroup(begin, end); // bank or subarray
-            for (const auto& hit_req_rowgroup : hit_reqs) {
-              if (rowgroup == hit_req_rowgroup) {
-                  violate_hit = true;
-                  break;
-              }
-            }
-          }
-          if (violate_hit) {
-            continue;
-          }
-          // If it comes here, that means it won't violate any hit request
-          if (head == q.end()) {
-            head = itr;
-          } else {
-            head = compare[int(Type::FRFCFS)](head, itr);
-          }
-        }
-
-        return head;
-      }
-    }
-
-private:
-    typedef list<Request>::iterator ReqIter;
-    function<ReqIter(ReqIter, ReqIter)> compare[int(Type::MAX)] = {
-        // FCFS
-        [this] (ReqIter req1, ReqIter req2) {
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-        // FRFCFS
-        [this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1);
-            bool ready2 = this->ctrl->is_ready(req2);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-        // FRFCFS_CAP
-        [this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1);
-            bool ready2 = this->ctrl->is_ready(req2);
-
-            ready1 = ready1 && (this->ctrl->rowtable->get_hits(req1->addr_vec) <= this->cap);
-            ready2 = ready2 && (this->ctrl->rowtable->get_hits(req2->addr_vec) <= this->cap);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-	
-        // FRFCFS_PriorHit
-        [this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1) && this->ctrl->is_row_hit(req1);
-            bool ready2 = this->ctrl->is_ready(req2) && this->ctrl->is_row_hit(req2);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-	// gagan : FRFCFS_DepPre
-	[this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1);
-            bool ready2 = this->ctrl->is_ready(req2);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-	    if (req1->is_prefetch ^ req2->is_prefetch) {
-	      if (req1->is_prefetch) return req2;
-	      return req1;
-	    }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-    };
-};
-
-
-template <typename T>
-class RowPolicy
-{
-public:
-    Controller<T>* ctrl;
-
-    enum class Type {
-        Closed, ClosedAP, Opened, Timeout, MAX
-    } type = Type::Timeout;
-    // } type = Type::Closed;
-    // } type = Type::Opened;
-
-    int timeout = 200;
-
-    RowPolicy(Controller<T>* ctrl) : ctrl(ctrl) {}
-
-    vector<int> get_victim(typename T::Command cmd)
-    {
-        return policy[int(type)](cmd);
-    }
-
-private:
-    function<vector<int>(typename T::Command)> policy[int(Type::MAX)] = {
-        // Closed
-        [this] (typename T::Command cmd) -> vector<int> {
-            for (auto& kv : this->ctrl->rowtable->table) {
-                if (!this->ctrl->is_ready(cmd, kv.first))
-                    continue;
-                return kv.first;
-            }
-            return vector<int>();},
-
-        // ClosedAP
-        [this] (typename T::Command cmd) -> vector<int> {
-            for (auto& kv : this->ctrl->rowtable->table) {
-                if (!this->ctrl->is_ready(cmd, kv.first))
-                    continue;
-                return kv.first;
-            }
-            return vector<int>();},
-
-        // Opened
-        [this] (typename T::Command cmd) {
-            return vector<int>();},
-
-        // Timeout
-        [this] (typename T::Command cmd) -> vector<int> {
-            for (auto& kv : this->ctrl->rowtable->table) {
-                auto& entry = kv.second;
-                if (this->ctrl->clk - entry.timestamp < timeout)
-                    continue;
-                if (!this->ctrl->is_ready(cmd, kv.first))
-                    continue;
-                return kv.first;
-            }
-            return vector<int>();}
-    };
-
-};
-
-
-template <typename T>
-class RowTable
-{
-public:
-    Controller<T>* ctrl;
-
-    struct Entry {
-        int row;
-        int hits;
-        long timestamp;
-    };
-
-    map<vector<int>, Entry> table;
-
-    RowTable(Controller<T>* ctrl) : ctrl(ctrl) {}
-
-    // gagan : rowtable print
-    void print()
-    {
-      int ch = ctrl->channel->id;
-      std::cout << "Channel: " << ch << std::endl;
-      for(int ra = 0; ra < ctrl->channel->children.size(); ra++)
-	{
-	  for(int bg = 0; bg < 4; bg++)
-	    for(int ba = 0; ba < 4; ba++)
-	      {
-		auto found = table.find({ch, ra, bg, ba});
-		if(found != table.end())
-		  {
-		    std::cout << "[" << found->second.row << "] ";
-		  }
-		else
-		  {
-		    std::cout << "[Closed] ";
-		  }
-	      }
-	  std::cout << std::endl;
-	}
-    }
-
-    void update(typename T::Command cmd, const vector<int>& addr_vec, long clk)
-    {
-        auto begin = addr_vec.begin();
-        auto end = begin + int(T::Level::Row);
-        vector<int> rowgroup(begin, end); // bank or subarray
-        int row = *end;
-
-        T* spec = ctrl->channel->spec;
-
-        if (spec->is_opening(cmd))
-            table.insert({rowgroup, {row, 0, clk}});
-
-        if (spec->is_accessing(cmd)) {
-            // we are accessing a row -- update its entry
-            auto match = table.find(rowgroup);
-            assert(match != table.end());
-            assert(match->second.row == row);
-            match->second.hits++;
-            match->second.timestamp = clk;
-        } /* accessing */
-
-        if (spec->is_closing(cmd)) {
-          // we are closing one or more rows -- remove their entries
-          int n_rm = 0;
-          int scope;
-          if (spec->is_accessing(cmd))
-            scope = int(T::Level::Row) - 1; //special condition for RDA and WRA
-          else
-            scope = int(spec->scope[int(cmd)]);
-
-          for (auto it = table.begin(); it != table.end();) {
-            if (equal(begin, begin + scope + 1, it->first.begin())) {
-              n_rm++;
-              it = table.erase(it);
-            }
-            else
-              it++;
-          }
-
-          assert(n_rm > 0);
-        } /* closing */
-    }
-
-    int get_hits(const vector<int>& addr_vec, const bool to_opened_row = false)
-    {
-        auto begin = addr_vec.begin();
-        auto end = begin + int(T::Level::Row);
-
-        vector<int> rowgroup(begin, end);
-        int row = *end;
-
-        auto itr = table.find(rowgroup);
-        if (itr == table.end())
-            return 0;
-
-        if(!to_opened_row && (itr->second.row != row))
-            return 0;
-
-        return itr->second.hits;
-    }
-
-    int get_open_row(const vector<int>& addr_vec) {
-        auto begin = addr_vec.begin();
-        auto end = begin + int(T::Level::Row);
-
-        vector<int> rowgroup(begin, end);
-
-        auto itr = table.find(rowgroup);
-        if(itr == table.end())
-            return -1;
-
-        return itr->second.row;
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__SCHEDULER_H*/
diff --git a/ext/ramulator/Ramulator/src/SpeedyController.h b/ext/ramulator/Ramulator/src/SpeedyController.h
deleted file mode 100644
index f234633ff..000000000
--- a/ext/ramulator/Ramulator/src/SpeedyController.h
+++ /dev/null
@@ -1,304 +0,0 @@
-#ifndef __SPEEDYCONTROLLER_H
-#define __SPEEDYCONTROLLER_H
-
-#include "Config.h"
-#include "DRAM.h"
-#include "Request.h"
-#include "Statistics.h"
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <string>
-#include <algorithm>
-#include <cassert>
-#include <utility>
-#include <queue>
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class SpeedyController
-// A FR-FCFS Open Row Controller, optimized for simulation speed.
-// Not For SALP-2
-{
-protected:
-  ScalarStat row_hits;
-  ScalarStat row_misses;
-private:
-    class compair_depart_clk{
-    public:
-        bool operator()(const Request& lhs, const Request& rhs) {
-            return lhs.depart > rhs.depart;
-        }
-    };
-public:
-    /* Command trace for DRAMPower 3.1 */
-    string cmd_trace_prefix = "cmd-trace-";
-    vector<ofstream> cmd_trace_files;
-    bool record_cmd_trace = false;
-    /* Commands to stdout */
-    bool print_cmd_trace = false;
-    /* Member Variables */
-    const unsigned int queue_capacity = 32;
-    long clk = 0;
-    DRAM<T>* channel;
-
-    double write_hi = 0.875;
-    double write_low = 0.5;
-
-    // request, first command, earliest clk
-    typedef tuple<Request, typename T::Command, long> request_info;
-    typedef vector<request_info> request_queue;
-    request_queue readq;   // queue for read requests
-    request_queue writeq;  // queue for write requests
-    request_queue otherq;  // queue for all "other" requests (e.g., refresh)
-
-    // read requests that are about to receive data from DRAM
-    priority_queue<Request, vector<Request>, compair_depart_clk> pending;
-
-    bool write_mode = false;  // whether write requests should be prioritized over reads
-    long refreshed = 0;  // last time refresh requests were generated
-
-    /* Constructor */
-    SpeedyController(const Config& configs, DRAM<T>* channel) :
-        channel(channel)
-    {
-        record_cmd_trace = configs.record_cmd_trace();
-        print_cmd_trace = configs.print_cmd_trace();
-        if (record_cmd_trace){
-            string prefix = cmd_trace_prefix + "chan-" + to_string(channel->id) + "-rank-";
-            string suffix = ".cmdtrace";
-            for (unsigned int i = 0; i < channel->children.size(); i++)
-                cmd_trace_files.emplace_back(prefix + to_string(i) + suffix);
-        }
-        readq.reserve(queue_capacity);
-        writeq.reserve(queue_capacity);
-        otherq.reserve(queue_capacity);
-
-        // regStats
-
-        row_hits
-            .name("row_hits_channel_"+to_string(channel->id))
-            .desc("Number of row hits")
-            .precision(0)
-            ;
-        row_misses
-            .name("row_misses_channel_"+to_string(channel->id))
-            .desc("Number of row misses")
-            .precision(0)
-            ;
-    }
-
-    ~SpeedyController(){
-        delete channel;
-        for (auto& file : cmd_trace_files)
-            file.close();
-    }
-
-    /* Member Functions */
-
-    void finish(int read_req, int write_req, int dram_cycles) {
-      // call finish function of each channel
-      channel->finish(dram_cycles);
-    }
-
-    bool enqueue(Request& req)
-    {
-        request_queue& q =
-            req.type == Request::Type::READ? readq:
-            req.type == Request::Type::WRITE? writeq:
-                                             otherq;
-        if (queue_capacity == q.size())
-            return false;
-
-        req.arrive = clk;
-        if (req.type == Request::Type::READ){
-            for (auto& info : writeq)
-                if (req.addr == get<0>(info).addr){
-                    req.depart = clk + 1;
-                    pending.push(req);
-                    return true;
-                }
-        }
-        typename T::Command first_cmd = get_first_cmd(req);
-        long first_clk = channel->get_next(first_cmd, req.addr_vec.data());
-        q.emplace_back(req, first_cmd, first_clk);
-        push_heap(q.begin(), q.end(), compair_first_clk);;
-        return true;
-    }
-
-    void tick()
-    {
-        clk++;
-
-        /*** 1. Serve completed reads ***/
-        if (pending.size()) {
-            Request req = pending.top();
-            if (req.depart <= clk) {
-                req.depart = clk; // actual depart clk
-                req.callback(req);
-                pending.pop();
-            }
-        }
-
-        /*** 2. Should we schedule refreshes? ***/
-        int refresh_interval = channel->spec->speed_entry.nREFI;
-        if (clk - refreshed >= refresh_interval) {
-            auto req_type = Request::Type::REFRESH;
-            vector<int> addr_vec(int(T::Level::MAX), -1);
-            addr_vec[0] = channel->id;
-            for (auto child : channel->children) {
-                addr_vec[1] = child->id;
-                Request req(addr_vec, req_type, NULL);
-                bool res = enqueue(req);
-                assert(res);
-            }
-
-            refreshed = clk;
-        }
-
-        /*** 3. Should we schedule writes? ***/
-        if (!write_mode) {
-            // yes -- write queue is almost full or read queue is empty
-            if (writeq.size() >= (unsigned int)(write_hi * queue_capacity) || readq.size() == 0)
-                write_mode = true;
-        }
-        else {
-            // no -- write queue is almost empty and read queue is not empty
-            if (writeq.size() <= (unsigned int)(write_low * queue_capacity) && readq.size() != 0)
-                write_mode = false;
-        }
-
-        /*** 4. Find the best command to schedule, if any ***/
-        request_queue& q = otherq.size()? otherq: write_mode ? writeq : readq;
-
-        schedule(q);
-    }
-
-    bool is_row_hit(Request& req)
-    {
-        typename T::Command cmd = get_first_cmd(req);
-        return channel->check_row_hit(cmd, req.addr_vec.data());
-    }
-
-private:
-
-    static bool compair_first_clk(const request_info& lhs, const request_info& rhs) {
-        return (get<2>(lhs) > get<2>(rhs));
-    }
-
-    typename T::Command get_first_cmd(Request& req)
-    {
-        typename T::Command cmd = channel->spec->translate[int(req.type)];
-        switch (int(req.type)){
-            case int(Request::Type::READ):
-            case int(Request::Type::WRITE):{
-                auto node = channel;
-                for (int i = 1; i < int(T::Level::Row); i++)
-                    node = node->children[req.addr_vec[i]];
-                assert(int(node->level) == int(T::Level::Row) - 1);
-                if (node->state == T::State::Closed) return T::Command::ACT;
-                else if (node->row_state.find(req.addr_vec[int(T::Level::Row)]) != node->row_state.end()) return cmd;
-                else return T::Command::PRE;
-            }
-            case int(Request::Type::REFRESH):
-                return channel->decode(cmd, req.addr_vec.data());
-            default:
-                assert(false);
-        }
-        // return channel->decode(cmd, req.addr_vec.data());
-    }
-    void update(typename T::Command cmd, bool state_change, vector<int>::iterator& begin, vector<int>::iterator& end, request_queue& q){
-        if (q.empty()) return;
-
-        for (auto& info : q) {
-            bool addr_eq = equal(begin, end, get<0>(info).addr_vec.begin());
-            if (state_change && addr_eq)
-                get<1>(info) = get_first_cmd(get<0>(info));
-            if ((cmd == T::Command::RD || cmd == T::Command::WR)
-                && get<1>(info) == T::Command::ACT)
-                continue;
-            get<2>(info) = channel->get_next(get<1>(info), get<0>(info).addr_vec.data());
-        }
-        make_heap(q.begin(), q.end(), compair_first_clk);
-    }
-
-    void schedule(request_queue& q){
-        if (q.empty()) return;
-
-        Request& req = get<0>(q[0]);
-        typename T::Command& first_cmd = get<1>(q[0]);
-        long first_clk = get<2>(q[0]);
-
-        if (first_clk > clk) return;
-
-        if (req.is_first_command) {
-            req.is_first_command = false;
-            if (req.type == Request::Type::READ || req.type == Request::Type::WRITE) {
-                if (is_row_hit(req))
-                    ++row_hits;
-                else
-                    ++row_misses;
-            }
-        }
-
-        issue_cmd(first_cmd, req.addr_vec.data());
-
-        if (first_cmd == channel->spec->translate[int(req.type)]){
-            if (req.type == Request::Type::READ) {
-                req.depart = clk + channel->spec->read_latency;
-                pending.push(req);
-            }
-            pop_heap(q.begin(), q.end(), compair_first_clk);
-            q.pop_back();
-        }
-
-        bool state_change = channel->spec->is_opening(first_cmd)
-                        || channel->spec->is_closing(first_cmd)
-                        || channel->spec->is_refreshing(first_cmd);
-
-        auto begin = req.addr_vec.begin();
-        auto end = begin + 1;
-        for (; end < begin + int(T::Level::Row) && *end >= 0; end++);
-
-        update(first_cmd, state_change, begin, end, readq);
-        update(first_cmd, state_change, begin, end, writeq);
-        update(first_cmd, state_change, begin, end, otherq);
-    }
-
-    void issue_cmd(typename T::Command cmd, int* addr_vec)
-    {
-        // assert(channel->check(cmd, addr_vec, clk));
-        channel->update(cmd, addr_vec, clk);
-
-        if (record_cmd_trace){
-            // select rank
-            auto& file = cmd_trace_files[addr_vec[1]];
-            string& cmd_name = channel->spec->command_name[int(cmd)];
-            file<<clk<<','<<cmd_name;
-            // TODO bad coding here
-            if (cmd_name == "PREA" || cmd_name == "REF")
-                file<<endl;
-            else {
-                int bank_id = addr_vec[int(T::Level::Bank)];
-                if (channel->spec->standard_name == "DDR4" || channel->spec->standard_name == "GDDR5")
-                    bank_id += addr_vec[int(T::Level::Bank) - 1] *
-                        channel->spec->org_entry.count[int(T::Level::Bank)];
-                file<<','<<bank_id<<endl;
-            }
-        }
-        if (print_cmd_trace){
-            printf("%5s %10ld:", channel->spec->command_name[int(cmd)].c_str(), clk);
-            for (int lev = 0; lev < int(T::Level::MAX); lev++)
-                printf(" %5d", addr_vec[lev]);
-            printf("\n");
-        }
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__SPEEDYCONTROLLER_H*/
diff --git a/ext/ramulator/Ramulator/src/StatType.cpp b/ext/ramulator/Ramulator/src/StatType.cpp
deleted file mode 100644
index 17b25357f..000000000
--- a/ext/ramulator/Ramulator/src/StatType.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-#include "StatType.h"
-
-namespace Stats {
-
-// Statistics list
-StatList statlist;
-
-// The smallest timing granularity.
-Tick curTick = 0;
-
-std::vector<StatBase*> all_stats;
-void reset_stats() {
-    for(auto s : all_stats)
-        s->reset();
-}
-
-void
-Histogram::grow_out()
-{
-    int size = cvec.size();
-    int zero = size / 2; // round down!
-    int top_half = zero + (size - zero + 1) / 2; // round up!
-    int bottom_half = (size - zero) / 2; // round down!
-
-    // grow down
-    int low_pair = zero - 1;
-    for (int i = zero - 1; i >= bottom_half; i--) {
-        cvec[i] = cvec[low_pair];
-        if (low_pair - 1 >= 0)
-            cvec[i] += cvec[low_pair - 1];
-        low_pair -= 2;
-    }
-    assert(low_pair == 0 || low_pair == -1 || low_pair == -2);
-
-    for (int i = bottom_half - 1; i >= 0; i--)
-        cvec[i] = Counter();
-
-    // grow up
-    int high_pair = zero;
-    for (int i = zero; i < top_half; i++) {
-        cvec[i] = cvec[high_pair];
-        if (high_pair + 1 < size)
-            cvec[i] += cvec[high_pair + 1];
-        high_pair += 2;
-    }
-    assert(high_pair == size || high_pair == size + 1);
-
-    for (int i = top_half; i < size; i++)
-        cvec[i] = Counter();
-
-    max_bucket *= 2;
-    min_bucket *= 2;
-    bucket_size *= 2;
-}
-
-void
-Histogram::grow_convert()
-{
-    int size = cvec.size();
-    int half = (size + 1) / 2; // round up!
-    //bool even = (size & 1) == 0;
-
-    int pair = size - 1;
-    for (int i = size - 1; i >= half; --i) {
-        cvec[i] = cvec[pair];
-        if (pair - 1 >= 0)
-            cvec[i] += cvec[pair - 1];
-        pair -= 2;
-    }
-
-    for (int i = half - 1; i >= 0; i--)
-        cvec[i] = Counter();
-
-    min_bucket = -max_bucket;// - (even ? bucket_size : 0);
-    bucket_size *= 2;
-}
-
-void
-Histogram::grow_up()
-{
-    int size = cvec.size();
-    int half = (size + 1) / 2; // round up!
-
-    int pair = 0;
-    for (int i = 0; i < half; i++) {
-        cvec[i] = cvec[pair];
-        if (pair + 1 < size)
-            cvec[i] += cvec[pair + 1];
-        pair += 2;
-    }
-    assert(pair == size || pair == size + 1);
-
-    for (int i = half; i < size; i++)
-        cvec[i] = Counter();
-
-    max_bucket *= 2;
-    bucket_size *= 2;
-}
-
-void
-Histogram::add(Histogram &hs)
-{
-    size_type b_size = hs.size();
-    assert(size() == b_size);
-    assert(min_bucket == hs.min_bucket);
-
-    sum += hs.sum;
-    logs += hs.logs;
-    squares += hs.squares;
-    samples += hs.samples;
-
-    while(bucket_size > hs.bucket_size)
-        hs.grow_up();
-    while(bucket_size < hs.bucket_size)
-        grow_up();
-
-    for (uint32_t i = 0; i < b_size; i++)
-        cvec[i] += hs.cvec[i];
-}
-
-void
-Histogram::sample(Counter val, int number)
-{
-    assert(min_bucket < max_bucket);
-    if (val < min_bucket) {
-        if (min_bucket == 0)
-            grow_convert();
-
-        while (val < min_bucket)
-            grow_out();
-    } else if (val >= max_bucket + bucket_size) {
-        if (min_bucket == 0) {
-            while (val >= max_bucket + bucket_size)
-                grow_up();
-        } else {
-            while (val >= max_bucket + bucket_size)
-                grow_out();
-        }
-    }
-
-    size_type index =
-        (int64_t)std::floor((val - min_bucket) / bucket_size);
-
-    assert(index >= 0 && index < size());
-    cvec[index] += number;
-
-    sum += val * number;
-    squares += val * val * number;
-    logs += log(val) * number;
-    samples += number;
-}
-
-} /* namespace Stats */
diff --git a/ext/ramulator/Ramulator/src/StatType.h b/ext/ramulator/Ramulator/src/StatType.h
deleted file mode 100644
index c1e4dd344..000000000
--- a/ext/ramulator/Ramulator/src/StatType.h
+++ /dev/null
@@ -1,669 +0,0 @@
-#ifndef __STATTYPE_H
-#define __STATTYPE_H
-
-#include <limits>
-#include <fstream>
-#include <string>
-#include <vector>
-
-#include <cassert>
-#include <cmath>
-#include <cstdlib>
-
-namespace ramulator {
-
-class ScalarStat;
-class AverageStat;
-class VectorStat;
-class AverageVectorStat;
-} // namespace ramulator
-
-namespace Stats {
-
-const double eps = 1e-8;
-
-typedef unsigned int size_type;
-typedef unsigned int off_type;
-typedef double Counter;
-typedef double Result;
-typedef uint64_t Tick;
-typedef std::vector<Counter> VCounter;
-typedef std::vector<Result> VResult;
-typedef std::numeric_limits<Counter> CounterLimits;
-
-class StatBase;
-extern std::vector<StatBase*> all_stats;
-void reset_stats();
-
-// Flags
-const uint16_t init      = 0x00000001;
-const uint16_t display   = 0x00000002;
-const uint16_t total     = 0x00000010;
-const uint16_t pdf       = 0x00000020;
-const uint16_t cdf       = 0x00000040;
-const uint16_t dist      = 0x00000080;
-const uint16_t nozero    = 0x00000100;
-const uint16_t nonan     = 0x00000200;
-
-class Flags {
- protected:
-  uint16_t flags;
- public:
-  Flags(){}
-  Flags(uint16_t flags):flags(flags){}
-  void operator=(uint16_t _flags){flags = _flags;}
-  bool is_total() const {return flags & total;}
-  bool is_pdf() const {return flags & pdf;}
-  bool is_nozero() const {return flags & nozero;}
-  bool is_nonan() const {return flags & nonan;}
-  bool is_cdf() const {return flags & cdf;}
-  bool is_display() const {return flags & display;}
-};
-
-class StatBase {
- public:
-    StatBase() {
-        all_stats.push_back(this);
-    }
-
-
-  // TODO implement print for Distribution, Histogram,
-  // AverageDeviation, StandardDeviation
-  virtual void print(std::ofstream& file) = 0;
-
-  virtual size_type size() const = 0;
-  virtual bool zero() const = 0;
-  virtual void prepare() = 0;
-  virtual void reset() = 0;
-
-  virtual VResult vresult() const { return VResult(); };
-  virtual Result total() const { return Result(); };
-
-  virtual bool is_display() const  = 0;
-  virtual bool is_nozero() const = 0;
-};
-
-class StatList {
- protected:
-  std::vector<StatBase*> list;
-  std::ofstream stat_output;
- public:
-  void add(StatBase* stat) {
-    list.push_back(stat);
-  }
-  void output(std::string filename) {
-    stat_output.open(filename.c_str(), std::ios_base::out);
-    if (!stat_output.good()) {
-      assert(false && "!stat_output.good()");
-    }
-  }
-  void printall() {
-    for(off_type i = 0 ; i < list.size() ; ++i) {
-      if (!list[i]) {
-        continue;
-      }
-      if (list[i]->is_nozero() && list[i]->zero()) {
-        continue;
-      }
-      if (list[i]->is_display()) {
-        list[i]->prepare();
-        list[i]->print(stat_output);
-      }
-    }
-  }
-  ~StatList() {
-    stat_output.close();
-  }
-};
-
-extern StatList statlist;
-
-template<class Derived>
-class Stat : public StatBase {
- protected:
-  std::string _name;
-  std::string _desc;
-  int _precision = 1;
-  Flags _flags = display;
-  std::string separatorString;
- public:
-  Stat() {
-    statlist.add(selfptr());
-  }
-  Derived &self() {return *static_cast<Derived*>(this);}
-  Derived *selfptr() {return static_cast<Derived*>(this);}
-  Derived &name(const std::string &__name) {
-    _name = __name;
-    return self();
-  };
-  Derived &desc(const std::string &__desc) {
-    _desc = __desc;
-    return self();
-  };
-  Derived &precision(int __precision) {
-    _precision = __precision;
-    return self();
-  };
-  Derived &flags(Flags __flags) {
-    _flags = __flags;
-    return self();
-  };
-
-  template <class GenericStat>
-  Derived &prereq(const GenericStat & prereq) {
-    // TODO deal with prereq;
-    // only print the stat if the prereq is not zero.
-    return self();
-  }
-
-  Derived &setSeparator(std::string str) {
-    separatorString = str;
-    return self();
-  }
-  const std::string& setSeparator() const {return separatorString;}
-
-  size_type size() const { return 0; }
-
-  virtual void print(std::ofstream& file) {};
-  virtual void printname(std::ofstream& file) {
-    file.width(40);
-    file << _name;
-  }
-
-  virtual void printdesc(std::ofstream& file) {
-    file.width(40);
-    file << "# " << _desc << std::endl;
-  }
-
-  virtual bool is_display() const {
-    return _flags.is_display();
-  }
-
-  virtual bool is_nozero() const {
-    return _flags.is_nozero();
-  }
-};
-
-template <class ScalarType>
-class ScalarBase: public Stat<ScalarType> {
- public:
-  virtual Counter value() const = 0;
-  virtual Result result() const = 0;
-  virtual Result total() const = 0;
-
-  size_type size() const {return 1;}
-  VResult vresult() const {return VResult(1, result());}
-
-  virtual void print(std::ofstream& file) {
-    Stat<ScalarType>::printname(file);
-    // TODO deal with flag
-    file.precision(Stat<ScalarType>::_precision);
-    file.width(20);
-    Result res = Stat<ScalarType>::self().result();
-    file << std::fixed << res;
-    Stat<ScalarType>::printdesc(file);
-  }
-};
-
-class ConstValue: public ScalarBase<ConstValue> {
- private:
-  Counter _value;
- public:
-  ConstValue(Counter __value):_value(__value){}
-
-  void operator ++ () { ++_value; }
-  void operator -- () { --_value; }
-  void operator ++ (int) { _value++; }
-  void operator -- (int) { _value--; }
-
-  template <typename U>
-  void operator = (const U &v) { _value = v; }
-
-  template <typename U>
-  void operator += (const U &v) { _value += v;}
-
-  template <typename U>
-  void operator -= (const U &v) { _value -= v;}
-
-
-  Counter value() const {return _value;}
-  Result result() const {return (Result)_value;}
-  Result total() const {return result();}
-  bool zero() const {return (fabs(_value) < eps);}
-  void prepare() {}
-  void reset() {}
-};
-
-class Scalar: public ScalarBase<Scalar> {
- private:
-  Counter _value;
- public:
-  Scalar():_value(0) {}
-  Counter value() const {return _value;}
-  Result result() const {return (Result)_value;}
-  Result total() const {return (Result)_value;}
-
-  void operator ++ () { ++_value; }
-  void operator -- () { --_value; }
-  void operator ++ (int) { _value++; }
-  void operator -- (int) { _value--; }
-
-  template <typename U>
-  void operator = (const U &v) { _value = v; }
-
-  template <typename U>
-  void operator += (const U &v) { _value += v;}
-
-  template <typename U>
-  void operator -= (const U &v) { _value -= v;}
-
-
-  virtual bool zero() const {return (fabs(_value) < eps);}
-  void prepare() {}
-  void reset() {_value = Counter();}
-
-};
-
-extern Tick curTick;
-
-class Average: public ScalarBase<Average> {
- private:
-  Counter current;
-  Tick lastReset;
-  Result total_val;
-  Tick last;
- public:
-  Average():current(0), lastReset(0), total_val(0), last(0){}
-
-  void set(Counter val) {
-    total_val += current * (curTick - last);
-    last = curTick;
-    current = val;
-  }
-  void inc(Counter val) {
-    set(current + val);
-  }
-  void dec(Counter val) {
-    set(current - val);
-  }
-  void operator ++ () { inc(1); }
-  void operator -- () { dec(1); }
-  void operator ++ (int) { inc(1); }
-  void operator -- (int) { dec(1); }
-
-  template <typename U>
-  void operator = (const U &v) { set(v); }
-
-  template <typename U>
-  void operator += (const U &v) { inc(v);}
-
-  template <typename U>
-  void operator -= (const U &v) { dec(v);}
-
-
-  bool zero() const { return (fabs(total_val) < eps); }
-  void prepare() {
-    total_val += current * (curTick - last);
-    last = curTick;
-  }
-  void reset() {
-    total_val = 0.0;
-    last = curTick;
-    lastReset = curTick;
-  }
-
-  Counter value() const { return current; }
-  Result result() const {
-    assert(last == curTick);
-    return (Result)(total_val + current)/ (Result)(curTick - lastReset + 1);
-  }
-  Result total() const {return result();}
-};
-
-template<class Derived, class Element>
-class VectorBase: public Stat<Derived> {
- private:
-  size_type _size = 0;
-  std::vector<Element> data;
-
- public:
-  void init(size_type __size) {
-    _size = __size;
-    data.resize(size());
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].flags(0)
-             .name("[" + std::string(1, char(i + '0')) + "]");
-    }
-  }
-  size_type size() const {return _size;}
-  // Copy the values to a local vector and return a reference to it.
-  void value(VCounter& vec) const {
-    vec.resize(size());
-    for (off_type i = 0 ; i < size() ; ++i) {
-      vec[i] = data[i].value();
-    }
-  }
-  // Copy the results to a local vector and return a reference to it.
-  void result(VResult& vec) const {
-    vec.resize(size());
-    for (off_type i = 0 ; i < size() ; ++i) {
-      vec[i] = data[i].result();
-    }
-  }
-
-  Result total() const {
-    Result sum = 0.0;
-    for (off_type i = 0 ; i < size() ; ++i) {
-      sum += data[i].result();
-    }
-    return sum;
-  }
-
-  VResult vresult() const {
-    VResult vres;
-    for (off_type i = 0 ; i < size() ; ++i) {
-      vres[i] = data[i].result();
-    }
-    return vres;
-  }
-
-  bool check() const {
-    // We don't separate storage and access as gem5 does.
-    // So here is always true.
-    return true;
-  }
-
-  Element &operator[](off_type index) {
-    assert(index >= 0 && index < size());
-    return data[index];
-  }
-
-  bool zero() const {
-    return (fabs(total()) < eps);
-  }
-
-  void prepare() {
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].prepare();
-    }
-  }
-  void reset() {
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].reset();
-    }
-  }
-  void print(std::ofstream& file) {
-    Stat<Derived>::printname(file);
-    file.precision(Stat<Derived>::_precision);
-    file.width(20);
-    file << std::fixed << total();
-    Stat<Derived>::printdesc(file);
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].print(file);
-    }
-  }
-};
-
-class Vector: public VectorBase<Vector, Scalar> {
-};
-
-class AverageVector: public VectorBase<AverageVector, Average> {
-};
-
-class Distribution: public Stat<Distribution> {
- private:
-  // Parameter part:
-  Counter param_min;
-  Counter param_max;
-  Counter param_bucket_size;
-  Counter param_buckets;
-
-  // The minimum value to track
-  Counter min_track;
-  // The maximum value to track
-  Counter max_track;
-  // The number of entries in each bucket
-  Counter bucket_size;
-
-  Counter min_val;
-  Counter max_val;
-  // The number of values sampled less than min
-  Counter underflow;
-  // The number of values sampled more than max
-  Counter overflow;
-  // The current sum
-  Counter sum;
-  // The sum of squares
-  Counter squares;
-  // The number of samples
-  Counter samples;
-  // Counter for each bucket
-  VCounter cvec;
-
- public:
-  Distribution():param_min(Counter()), param_max(Counter()),
-      param_bucket_size(Counter()) { reset(); }
-  void init(Counter min, Counter max, Counter bkt) {
-    param_min = min;
-    param_max = max;
-    param_bucket_size = bkt;
-    param_buckets = (size_type)ceil((max - min + 1.0) / bkt);
-    cvec.resize(param_buckets);
-
-    reset();
-  }
-  void sample(Counter val, int number) {
-    if (val < min_track)
-      underflow += number;
-    else if (val > max_track)
-      overflow += number;
-    else {
-      size_type index =
-          (size_type)std::floor((val - min_track) / bucket_size);
-      assert(index < size());
-      cvec[index] += number;
-    }
-
-    if (val < min_val)
-      min_val = val;
-
-    if (val > max_val)
-      max_val = val;
-
-    sum += val * number;
-    squares += val * val * number;
-    samples += number;
-  }
-
-  size_type size() const {return cvec.size();}
-  bool zero() const {
-    return (fabs(samples) < eps);
-  }
-  void prepare() {};
-  void reset() {
-    min_track = param_min;
-    max_track = param_max;
-    bucket_size = param_bucket_size;
-
-    min_val = CounterLimits::max();
-    max_val = CounterLimits::min();
-    underflow = Counter();
-    overflow = Counter();
-
-    size_type _size = cvec.size();
-    for (off_type i = 0 ; i < _size ; ++i) {
-      cvec[i] = Counter();
-    }
-
-    sum = Counter();
-    squares = Counter();
-    samples = Counter();
-  };
-  void add(Distribution &d) {
-    size_type d_size = d.size();
-    assert(size() == d_size);
-    assert(min_track == d.min_track);
-    assert(max_track == d.max_track);
-
-    underflow += d.underflow;
-    overflow += d.overflow;
-
-    sum += d.sum;
-    squares += d.squares;
-    samples += d.samples;
-
-    if (d.min_val < min_val) {
-      min_val = d.min_val;
-    }
-
-    if (d.max_val > max_val) {
-      max_val = d.max_val;
-    }
-
-    for (off_type i = 0 ; i < d_size ; ++i) {
-      cvec[i] += d.cvec[i];
-    }
-  }
-};
-
-class Histogram: public Stat<Histogram> {
- private:
-  size_type param_buckets;
-
-  Counter min_bucket;
-  Counter max_bucket;
-  Counter bucket_size;
-
-  Counter sum;
-  Counter logs;
-  Counter squares;
-  Counter samples;
-  VCounter cvec;
-
- public:
-  Histogram():param_buckets(0) { reset(); }
-  Histogram(size_type __buckets):cvec(__buckets) {
-    init(__buckets);
-  }
-  void init(size_type __buckets) {
-    cvec.resize(__buckets);
-    param_buckets = __buckets;
-    reset();
-  }
-
-  void grow_up();
-  void grow_out();
-  void grow_convert();
-  void add(Histogram& hs);
-  void sample(Counter val, int number);
-
-  bool zero() const {
-    return (fabs(samples) < eps);
-  }
-  void prepare() {}
-  void reset() {
-    min_bucket = 0;
-    max_bucket = param_buckets - 1;
-    bucket_size = 1;
-
-    size_type size = param_buckets;
-    for (off_type i = 0 ; i < size ; ++i) {
-      cvec[i] = Counter();
-    }
-
-    sum = Counter();
-    squares = Counter();
-    samples = Counter();
-    logs = Counter();
-  }
-
-  size_type size() const {return param_buckets;}
-};
-
-class StandardDeviation: public Stat<StandardDeviation> {
- private:
-  Counter sum;
-  Counter squares;
-  Counter samples;
-
- public:
-  StandardDeviation():sum(Counter()), squares(Counter()),
-      samples(Counter()) {}
-  void sample(Counter val, int number) {
-    Counter value = val * number;
-    sum += value;
-    squares += value * value;
-    samples += number;
-  }
-  size_type size() const {return 1;}
-  bool zero() const {return (fabs(samples) < eps);}
-  void prepare() {}
-  void reset() {
-    sum = Counter();
-    squares = Counter();
-    samples = Counter();
-  }
-  void add(StandardDeviation& sd) {
-    sum += sd.sum;
-    squares += sd.squares;
-    samples += sd.samples;
-  }
-};
-
-class AverageDeviation: public Stat<AverageDeviation> {
- private:
-  Counter sum;
-  Counter squares;
-
- public:
-  AverageDeviation():sum(Counter()), squares(Counter()) {}
-  void sample(Counter val, int number) {
-    Counter value = val * number;
-    sum += value;
-    squares += value * value;
-  }
-  size_type size() const {return 1;}
-  bool zero() const {return (fabs(sum) < eps);}
-  void prepare() {}
-  void reset() {
-    sum = Counter();
-    squares = Counter();
-  }
-  void add(AverageDeviation& ad) {
-    sum += ad.sum;
-    squares += ad.squares;
-  }
-};
-
-class Op {
- private:
-  std::string opstring;
- public:
-  Op() {}
-  Op(std::string __opstring):opstring(__opstring){}
-  Result operator() (Result r) const {
-    if (opstring == "-") {
-      return -r;
-    } else {
-      assert("Unary operation can only be unary negation." && false);
-    }
-  }
-  Result operator() (Result l, Result r) const {
-    if (opstring == "+") {
-      return l + r;
-    } else if (opstring == "-") {
-      return l - r;
-    } else if (opstring == "*") {
-      return l * r;
-    } else if (opstring == "/") {
-      assert(fabs(r) > 1e-8 || "divide zero error");
-      return l / r;
-    } else {
-      assert("invalid binary opstring " && false);
-    }
-  }
-};
-
-} // namespace Stats
-
-#endif
diff --git a/ext/ramulator/Ramulator/src/Statistics.h b/ext/ramulator/Ramulator/src/Statistics.h
deleted file mode 100644
index b9f7489fe..000000000
--- a/ext/ramulator/Ramulator/src/Statistics.h
+++ /dev/null
@@ -1,246 +0,0 @@
-#ifndef __STATISTICS_H
-#define __STATISTICS_H
-
-#include <string>
-
-// FIXME Find better way to decide where does it come from
-#if !defined(RAMULATOR)
-#define INTEGRATED_WITH_GEM5
-#endif
-
-#ifdef INTEGRATED_WITH_GEM5
-#include "base/statistics.hh"
-#else
-#include "StatType.h"
-#endif
-
-/*
-  IMPORTANT NOTE - Read this first!
-
-  This version of the file provides wrappers to the gem5 statistics classes.
-  Feel free to go through this file, though it can be difficult to follow
-  with the degree of abstraction going on. In short, this file currently
-  provides the following mapping of stat classes. In almost all cases, the
-  wrapper provides identical and complete functionality to the gem5 stat
-  classes. All of our classes are defined in the ramulator namespace.
-
-  GEM5 CLASS --> RAMULATOR CLASS
-  ==============================
-  Stats::Scalar --> ScalarStat
-  Stats::Average --> AverageStat
-  Stats::Vector --> VectorStat
-  Stats::AverageVector --> AverageVectorStat
-  Stats::Distribution --> DistributionStat
-  Stats::Histogram --> HistogramStat
-  Stats::StandardDeviation --> StandardDeviationStat
-  Stats::AverageDeviation --> AverageDeviationStat
-
-  All of the stats that you create will be named "ramulator.<your name>"
-  automatically, and will be dumped at the end of simulation into the gem5
-  stats file.
-*/
-
-namespace ramulator {
-
-template<class StatType>
-class StatBase { // wrapper for Stats::DataWrap
-  protected:
-    StatType stat;
-    std::string statName;
-
-    StatBase<StatType> & self() { return *this; }
-  public:
-    StatBase() {}
-
-#ifndef INTEGRATED_WITH_GEM5
-    const StatType* get_stat() const {
-      return &stat;
-    }
-#endif
-
-    StatBase(std::string _name) {
-      name(_name);
-    }
-
-    StatBase(std::string _name, std::string _desc) {
-      name(_name);
-      desc(_desc);
-    }
-
-    StatBase<StatType> & name(std::string _name) {
-      statName = _name;
-      stat.name("ramulator." + _name);
-
-      return self();
-    }
-
-    const std::string &name(void) const { return statName; }
-
-    StatBase<StatType> & setSeparator(const std::string & _sep) {
-      stat.setSeparator(_sep);
-      return self();
-    }
-
-    const std::string &setSeparator() const { return stat.setSeparator(); }
-
-    StatBase<StatType> & desc(std::string _desc) {
-      stat.desc(_desc);
-      return self();
-    }
-
-    StatBase<StatType> & precision(int _precision) {
-      stat.precision(_precision);
-      return self();
-    }
-
-    StatBase<StatType> & flags(Stats::Flags _flags) {
-      stat.flags(_flags);
-      return self();
-    }
-
-    template <class Stat>
-    StatBase<StatType> & prereq(const Stat & _prereq) {
-      stat.prereq(_prereq);
-      return self();
-    }
-
-    Stats::size_type size(void) const { return stat.size(); }
-    bool zero(void) const { return stat.zero(); }
-    void prepare(void) { stat.prepare(); }
-    void reset(void) { stat.reset(); }
-};
-
-template<class StatType>
-class StatBaseVec : public StatBase<StatType> { // wrapper for Stats::DataWrapVec
-  protected:
-    StatBaseVec<StatType> & self() { return *this; }
-
-  public:
-    StatBaseVec<StatType> & subname(Stats::off_type index, const std::string & name) {
-      StatBase<StatType>::stat.subname(index, name);
-      return self();
-    }
-
-    StatBaseVec<StatType> & subdesc(Stats::off_type index, const std::string & desc) {
-      StatBase<StatType>::stat.subdesc(index, desc);
-      return self();
-    }
-};
-
-template<class StatType>
-class ScalarStatBase : public StatBase<StatType> { // wrapper for Stats::ScalarBase
-  public:
-    Stats::Counter value() const { return StatBase<StatType>::stat.value(); };
-    void operator++() { ++StatBase<StatType>::stat; }
-    void operator--() { --StatBase<StatType>::stat; }
-
-    void operator++(int) { StatBase<StatType>::stat++; }
-    void operator--(int) { StatBase<StatType>::stat--; }
-
-    template <typename U>
-    void operator=(const U &v) { StatBase<StatType>::stat = v; }
-
-    template <typename U>
-    void operator+=(const U &v) { StatBase<StatType>::stat += v; }
-
-    template <typename U>
-    void operator-=(const U &v) { StatBase<StatType>::stat -= v; }
-};
-
-template<class StatType, class Element>
-class VectorStatBase : public StatBaseVec<StatType> { // wrapper for Stats::VectorBase
-  protected:
-    VectorStatBase<StatType, Element> & self() { return *this; }
-
-  public:
-    void value(Stats::VCounter & vec) const { StatBase<StatType>::stat.value(vec); }
-    void result(Stats::VResult & vec) const { StatBase<StatType>::stat.result(vec); }
-    Stats::Result total(void) const { return StatBase<StatType>::stat.total(); }
-
-    bool check(void) const { return StatBase<StatType>::stat.check(); }
-
-    VectorStatBase<StatType, Element> & init(Stats::size_type size) {
-      StatBase<StatType>::stat.init(size);
-      return self();
-    }
-
-#ifdef INTEGRATED_WITH_GEM5
-    Stats::ScalarProxy<StatType> operator[](Stats::off_type index) { return StatBase<StatType>::stat[index]; }
-#else
-    Element &operator[](Stats::off_type index) { return StatBase<StatType>::stat[index]; }
-#endif
-};
-
-
-template<class StatType>
-class DistStatBase : public StatBase<StatType> { // wrapper for Stats::DistBase
-  public:
-    template<typename U>
-    void sample(const U &v, int n = 1) { StatBase<StatType>::stat.sample(v, n); }
-
-    void add(DistStatBase & d) { StatBase<StatType>::stat.add(d.StatBase<StatType>::stat); }
-};
-
-
-/*
-  nice wrappers for the gem5 stats classes used throughout the rest of the code
-*/
-
-class ScalarStat : public ScalarStatBase<Stats::Scalar> {
-  public:
-    using ScalarStatBase<Stats::Scalar>::operator=;
-};
-
-class AverageStat : public ScalarStatBase<Stats::Average> {
-  public:
-    using ScalarStatBase<Stats::Average>::operator=;
-};
-
-class VectorStat : public VectorStatBase<Stats::Vector, Stats::Scalar> {
-};
-
-class AverageVectorStat : public VectorStatBase<Stats::AverageVector, Stats::Average> {
-};
-
-class DistributionStat : public DistStatBase<Stats::Distribution> {
-  protected:
-    DistributionStat & self() { return *this; }
-
-  public:
-    DistributionStat & init(Stats::Counter min, Stats::Counter max, Stats::Counter bkt) {
-      StatBase<Stats::Distribution>::stat.init(min, max, bkt);
-      return self();
-    }
-
-};
-
-class HistogramStat : public DistStatBase<Stats::Histogram> {
-  protected:
-    HistogramStat & self() { return *this; }
-
-  public:
-    HistogramStat & init(Stats::size_type size) {
-      StatBase<Stats::Histogram>::stat.init(size);
-      return self();
-    }
-};
-
-class StandardDeviationStat : public DistStatBase<Stats::StandardDeviation> {
-};
-
-class AverageDeviationStat : public DistStatBase<Stats::AverageDeviation> {
-};
-
-/*
-  Stats TODO
-  * Formula
-  * VectorDistribution
-  * VectorStandardDeviation
-  * VectorAverageDeviation
-  * Vector2d
-  * SparseHistogram
-*/
-
-} /* namespace ramulator */
-
-#endif
diff --git a/ext/ramulator/Ramulator/src/TLDRAM.cpp b/ext/ramulator/Ramulator/src/TLDRAM.cpp
deleted file mode 100644
index c9b3052f4..000000000
--- a/ext/ramulator/Ramulator/src/TLDRAM.cpp
+++ /dev/null
@@ -1,567 +0,0 @@
-#include "TLDRAM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-#include <iostream>
-
-using namespace std;
-using namespace ramulator;
-
-string TLDRAM::standard_name = "TLDRAM";
-string TLDRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum TLDRAM::Org> TLDRAM::org_map = {
-    {"TLDRAM_512Mb_x4", TLDRAM::Org::TLDRAM_512Mb_x4},
-    {"TLDRAM_512Mb_x8", TLDRAM::Org::TLDRAM_512Mb_x8},
-    {"TLDRAM_512Mb_x16", TLDRAM::Org::TLDRAM_512Mb_x16},
-    {"TLDRAM_1Gb_x4", TLDRAM::Org::TLDRAM_1Gb_x4},
-    {"TLDRAM_1Gb_x8", TLDRAM::Org::TLDRAM_1Gb_x8},
-    {"TLDRAM_1Gb_x16", TLDRAM::Org::TLDRAM_1Gb_x16},
-    {"TLDRAM_2Gb_x4", TLDRAM::Org::TLDRAM_2Gb_x4},
-    {"TLDRAM_2Gb_x8", TLDRAM::Org::TLDRAM_2Gb_x8},
-    {"TLDRAM_2Gb_x16", TLDRAM::Org::TLDRAM_2Gb_x16},
-    {"TLDRAM_4Gb_x4", TLDRAM::Org::TLDRAM_4Gb_x4},
-    {"TLDRAM_4Gb_x8", TLDRAM::Org::TLDRAM_4Gb_x8},
-    {"TLDRAM_4Gb_x16", TLDRAM::Org::TLDRAM_4Gb_x16},
-    {"TLDRAM_8Gb_x4", TLDRAM::Org::TLDRAM_8Gb_x4},
-    {"TLDRAM_8Gb_x8", TLDRAM::Org::TLDRAM_8Gb_x8},
-    {"TLDRAM_8Gb_x16", TLDRAM::Org::TLDRAM_8Gb_x16},
-};
-
-map<string, enum TLDRAM::Speed> TLDRAM::speed_map = {
-    {"TLDRAM_800D", TLDRAM::Speed::TLDRAM_800D},
-    {"TLDRAM_800E", TLDRAM::Speed::TLDRAM_800E},
-    {"TLDRAM_1066E", TLDRAM::Speed::TLDRAM_1066E},
-    {"TLDRAM_1066F", TLDRAM::Speed::TLDRAM_1066F},
-    {"TLDRAM_1066G", TLDRAM::Speed::TLDRAM_1066G},
-    {"TLDRAM_1333G", TLDRAM::Speed::TLDRAM_1333G},
-    {"TLDRAM_1333H", TLDRAM::Speed::TLDRAM_1333H},
-    {"TLDRAM_1600H", TLDRAM::Speed::TLDRAM_1600H},
-    {"TLDRAM_1600J", TLDRAM::Speed::TLDRAM_1600J},
-    {"TLDRAM_1600K", TLDRAM::Speed::TLDRAM_1600K},
-    {"TLDRAM_1866K", TLDRAM::Speed::TLDRAM_1866K},
-    {"TLDRAM_1866L", TLDRAM::Speed::TLDRAM_1866L},
-    {"TLDRAM_2133L", TLDRAM::Speed::TLDRAM_2133L},
-    {"TLDRAM_2133M", TLDRAM::Speed::TLDRAM_2133M},
-};
-
-
-TLDRAM::TLDRAM(Org org, Speed speed, int segment_ratio) :
-    segment_ratio(segment_ratio),
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    this->segment_ratio = segment_ratio;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-TLDRAM::TLDRAM(const string& org_str, const string& speed_str, int segment_ratio) :
-    TLDRAM(org_map[org_str], speed_map[speed_str], segment_ratio)
-{
-    this->segment_ratio = segment_ratio;
-}
-
-void TLDRAM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void TLDRAM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void TLDRAM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4;
-          speed_entry.nFAW = (page==1) ? 16 : 20;
-          break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6;
-          speed_entry.nFAW = (page==1) ? 20 : 27;
-          break;
-        case 1333:
-          speed_entry.nRRD = (page==1) ? 4 : 5;
-          speed_entry.nFAW = (page==1) ? 20 : 30;
-          break;
-        case 1600:
-          speed_entry.nRRD = (page==1) ? 5 : 6;
-          speed_entry.nFAW = (page==1) ? 24 : 32;
-          break;
-        case 1866:
-          speed_entry.nRRD = (page==1) ? 5 : 6;
-          speed_entry.nFAW = (page==1) ? 26 : 33;
-          break;
-        case 2133:
-          speed_entry.nRRD = (page==1) ? 5 : 6;
-          speed_entry.nFAW = (page==1) ? 27 : 34;
-          break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44
-          : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59
-          : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74
-          : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88
-          : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103
-          : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118
-          : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48
-          : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64
-          : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80
-          : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96
-          : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112
-          : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128
-          : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void TLDRAM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }
-    };
-    prereq[int(Level::Rank)][int(Command::MIG)] = prereq[int(Level::Rank)][int(Command::RD)];
-
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed):
-                if (id % node->spec->segment_ratio)
-                    return Command::ACT;
-                else
-                    return Command::ACTF;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                if (id % node->spec->segment_ratio)
-                    return Command::PRE;
-                else
-                    return Command::PREF;
-            default: assert(false);
-        }
-    };
-    prereq[int(Level::Bank)][int(Command::MIG)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed):
-                return Command::ACTM;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PREM;
-            default: assert(false);
-        }
-    };
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            if (id % node->spec->segment_ratio)
-                return Command::PREA;
-            else
-                return Command::PREAF;
-        }
-        return Command::REF;
-    };
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }
-    };
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }
-    };
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void TLDRAM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void TLDRAM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void TLDRAM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;
-    };
-    lambda[int(Level::Bank)][int(Command::ACTF)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;
-    };
-    lambda[int(Level::Bank)][int(Command::ACTM)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;
-    };
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();
-    };
-    lambda[int(Level::Bank)][int(Command::PREF)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();
-    };
-    lambda[int(Level::Bank)][int(Command::PREM)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();
-    };
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();
-        }
-    };
-    lambda[int(Level::Rank)][int(Command::PREAF)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();
-        }
-    };
-    lambda[int(Level::Rank)][int(Command::PREAM)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();
-        }
-    };
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::MIG)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;
-    };
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::PowerUp;
-    };
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::SelfRefresh;
-    };
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::PowerUp;
-    };
-}
-
-
-void TLDRAM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::MIG, 1, s.nBL});
-    t[int(Command::MIG)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::MIG, 1, s.nCCD});
-    t[int(Command::MIG)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nCCD});
-
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::MIG)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::MIG, 1, s.nCWL + s.nBL + s.nWTR});
-
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::MIG, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREAF, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREAM, 1, s.nRTP});
-
-    t[int(Command::MIG)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::MIG)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::MIG)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::MIG)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREAF, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREAM, 1, s.nRTP});
-
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::MIG, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WR)].push_back({Command::PREAF, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WR)].push_back({Command::PREAM, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::MIG)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::MIG, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::ACTF, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACTF, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::ACTM, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACTM, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREF, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREAF, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREM, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREAM, 1, s.nRAS});
-
-    t[int(Command::ACTF)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACTF)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACTF)].push_back({Command::ACTF, 1, s.nRRD});
-    t[int(Command::ACTF)].push_back({Command::ACTF, 4, s.nFAW});
-    t[int(Command::ACTF)].push_back({Command::ACTM, 1, s.nRRD});
-    t[int(Command::ACTF)].push_back({Command::ACTM, 4, s.nFAW});
-    t[int(Command::ACTF)].push_back({Command::PRE, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREA, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREF, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREAF, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREM, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREAM, 1, s.nRASF});
-
-    t[int(Command::ACTM)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACTM)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACTM)].push_back({Command::ACTF, 1, s.nRRD});
-    t[int(Command::ACTM)].push_back({Command::ACTF, 4, s.nFAW});
-    t[int(Command::ACTM)].push_back({Command::ACTM, 1, s.nRRD});
-    t[int(Command::ACTM)].push_back({Command::ACTM, 4, s.nFAW});
-    t[int(Command::ACTM)].push_back({Command::PRE, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREA, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREF, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREAF, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREM, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREAM, 1, s.nRASM});
-
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTF, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTM, 1, s.nRP});
-
-    t[int(Command::PREF)].push_back({Command::ACT, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTF, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTM, 1, s.nRPF});
-
-    t[int(Command::PREM)].push_back({Command::ACT, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTF, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTM, 1, s.nRPM});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREF)].push_back({Command::REF, 1, s.nRPF});
-    t[int(Command::PREM)].push_back({Command::REF, 1, s.nRPM});
-
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREAF)].push_back({Command::REF, 1, s.nRPF});
-    t[int(Command::PREAM)].push_back({Command::REF, 1, s.nRPM});
-
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-    t[int(Command::REF)].push_back({Command::ACTF, 1, s.nRFC});
-    t[int(Command::REF)].push_back({Command::ACTM, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::ACTF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::ACTM)].push_back({Command::PDE, 1, 1});
-
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::ACTF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::ACTM, 1, s.nXP});
-
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREM, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREF)].push_back({Command::SRE, 1, s.nRPF});
-    t[int(Command::PREM)].push_back({Command::SRE, 1, s.nRPM});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREAF)].push_back({Command::SRE, 1, s.nRPF});
-    t[int(Command::PREAM)].push_back({Command::SRE, 1, s.nRPM});
-
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-    t[int(Command::SRX)].push_back({Command::ACTF, 1, s.nXS});
-    t[int(Command::SRX)].push_back({Command::ACTM, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACTF)].push_back({Command::RD, 1, s.nRCDF});    // Fast Segment
-    t[int(Command::ACTM)].push_back({Command::RD, 1, s.nRCDM});    // Fast Segment
-
-    t[int(Command::ACT)].push_back({Command::MIG, 1, s.nRCD});
-    t[int(Command::ACTF)].push_back({Command::MIG, 1, s.nRCDF});  // Fast Segment
-    t[int(Command::ACTM)].push_back({Command::MIG, 1, s.nRCDM});  // Fast Segment
-
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACTF)].push_back({Command::WR, 1, s.nRCDF});    // Fast Segment
-    t[int(Command::ACTM)].push_back({Command::WR, 1, s.nRCDM});    // Fast Segment
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREF, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREM, 1, s.nRTP});
-
-    t[int(Command::MIG)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREF, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREM, 1, s.nRTP});
-
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WR)].push_back({Command::PREF, 1, s.nCWL + s.nBL + s.nWR});
-
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::ACTF, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::ACTM, 1, s.nRC});
-    t[int(Command::ACTF)].push_back({Command::ACT, 1, s.nRCF});
-    t[int(Command::ACTF)].push_back({Command::ACTF, 1, s.nRCF});
-    t[int(Command::ACTF)].push_back({Command::ACTM, 1, s.nRCF});
-    t[int(Command::ACTM)].push_back({Command::ACT, 1, s.nRCM});
-    t[int(Command::ACTM)].push_back({Command::ACTF, 1, s.nRCM});
-    t[int(Command::ACTM)].push_back({Command::ACTM, 1, s.nRCM});
-
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREF, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREM, 1, s.nRAS});
-    t[int(Command::ACTF)].push_back({Command::PRE, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREF, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREM, 1, s.nRASF});
-    t[int(Command::ACTM)].push_back({Command::PRE, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREF, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREM, 1, s.nRASM});
-
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTF, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTM, 1, s.nRP});
-    t[int(Command::PREF)].push_back({Command::ACT, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTF, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTM, 1, s.nRPF});
-    t[int(Command::PREM)].push_back({Command::ACT, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTF, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTM, 1, s.nRPM});
-
-}
diff --git a/ext/ramulator/Ramulator/src/TLDRAM.h b/ext/ramulator/Ramulator/src/TLDRAM.h
deleted file mode 100644
index deced4239..000000000
--- a/ext/ramulator/Ramulator/src/TLDRAM.h
+++ /dev/null
@@ -1,261 +0,0 @@
-#ifndef __TLDRAM_H
-#define __TLDRAM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class TLDRAM
-{
-public:
-    int segment_ratio = 16;
-
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    TLDRAM(Org org, Speed speed, int segment_ratio);
-    TLDRAM(const string& org_str, const string& speed_str, int segment_ratio);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD, WR,
-        REF, PDE, PDX, SRE, SRX,
-        ACTF, PREF, PREAF,
-        MIG,
-        ACTM, PREM, PREAM,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD", "WR",
-        "REF", "PDE", "PDX", "SRE", "SRX",
-        "ACTF", "PREF", "PREAF",
-        "MIG",
-        "ACTM", "PREM", "PREAM"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row, Level::Bank, Level::Rank,
-        Level::Column, Level::Column,
-        Level::Rank, Level::Rank, Level::Rank, Level::Rank, Level::Rank,
-        Level::Row, Level::Bank, Level::Rank,
-        Level::Column,
-        Level::Row, Level::Bank, Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-            case int(Command::ACTF):
-            case int(Command::ACTM):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::MIG):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::PRE):
-            case int(Command::PREF):
-            case int(Command::PREM):
-            case int(Command::PREA):
-            case int(Command::PREAF):
-            case int(Command::PREAM):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE,
-        Command::MIG
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<TLDRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<TLDRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<TLDRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<TLDRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        TLDRAM_512Mb_x4, TLDRAM_512Mb_x8, TLDRAM_512Mb_x16,
-        TLDRAM_1Gb_x4,   TLDRAM_1Gb_x8,   TLDRAM_1Gb_x16,
-        TLDRAM_2Gb_x4,   TLDRAM_2Gb_x8,   TLDRAM_2Gb_x16,
-        TLDRAM_4Gb_x4,   TLDRAM_4Gb_x8,   TLDRAM_4Gb_x16,
-        TLDRAM_8Gb_x4,   TLDRAM_8Gb_x8,   TLDRAM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}},
-        {  512,  8, {0, 0, 8, 1<<13, 1<<10}},
-        {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}},
-        {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}},
-        {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}},
-        {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}},
-        {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}},
-        {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}},
-        {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}},
-        {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}},
-        {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        TLDRAM_800D,  TLDRAM_800E,
-        TLDRAM_1066E, TLDRAM_1066F, TLDRAM_1066G,
-        TLDRAM_1333G, TLDRAM_1333H,
-        TLDRAM_1600H, TLDRAM_1600J, TLDRAM_1600K,
-        TLDRAM_1866K, TLDRAM_1866L,
-        TLDRAM_2133L, TLDRAM_2133M,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-        int nRCDF, nRPF, nRASF, nRCF;
-        int nRCDM, nRPM, nRASM, nRCM;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0,
-          3120, 3, 3, 10, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0,
-          3120, 3, 3, 10, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0,
-          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0,
-          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0,
-          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0,
-          5200, 4, 4, 16, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0,
-          5200, 4, 4, 16, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0,
-          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0,
-          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0,
-          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0,
-          7280, 5, 6, 23, 6, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0,
-          7280, 5, 6, 23, 6, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0,
-          8320, 6, 7, 26, 7, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0,
-          8320, 6, 7, 26, 7, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__TLDRAM_H*/
diff --git a/ext/ramulator/Ramulator/src/WideIO.cpp b/ext/ramulator/Ramulator/src/WideIO.cpp
deleted file mode 100644
index 987193f89..000000000
--- a/ext/ramulator/Ramulator/src/WideIO.cpp
+++ /dev/null
@@ -1,326 +0,0 @@
-#include "WideIO.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string WideIO::standard_name = "WideIO";
-string WideIO::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum WideIO::Org> WideIO::org_map = {
-    {"WideIO_1Gb", WideIO::Org::WideIO_1Gb},
-    {"WideIO_2Gb", WideIO::Org::WideIO_2Gb},
-    {"WideIO_4Gb", WideIO::Org::WideIO_4Gb},
-    {"WideIO_8Gb", WideIO::Org::WideIO_8Gb},
-};
-
-map<string, enum WideIO::Speed> WideIO::speed_map = {
-    {"WideIO_200", WideIO::Speed::WideIO_200}, 
-    {"WideIO_266", WideIO::Speed::WideIO_266},
-};
-
-WideIO::WideIO(Org org, Speed speed) : 
-    org_entry(org_table[int(org)]), 
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-WideIO::WideIO(const string& org_str, const string& speed_str) :
-    WideIO(org_map[org_str], speed_map[speed_str]) 
-{
-}
-
-void WideIO::set_channel_number(int channel) {
-  assert((channel == 4) && "The Wide I/O interface supports 4 physical and 4 logical channels.");
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void WideIO::set_rank_number(int rank) {
-  assert((rank == 1) && "WideIO rank number is fixed to 1.");
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void WideIO::init_speed()
-{
-    const static int RFC_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {18, 26, 26, 42},
-        {24, 35, 35, 56}
-    };
-    const static int REFI_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {3120, 1560, 780, 780},
-        {4160, 2080, 1040, 520}
-    };
-    int speed = 0, density = 0;
-    switch(speed_entry.rate){
-        case 200: speed = 0; break;
-        case 266: speed = 1; break;
-        default: assert(false);
-    }
-    switch(org_entry.size >> 8){
-        case 1: density = 0; break;
-        case 2: density = 1; break;
-        case 4: density = 2; break;
-        case 8: density = 3; break;
-        default: assert(false);
-    }
-    speed_entry.nRFC = RFC_TABLE[speed][density];
-    speed_entry.nREFI = REFI_TABLE[speed][density];
-}
-
-
-void WideIO::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PRA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PD;
-            case int(State::ActPowerDown): return Command::PD;
-            case int(State::PrePowerDown): return Command::PD;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void WideIO::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<WideIO>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<WideIO>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void WideIO::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nRTW});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nRTW});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nRTW});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nRTW});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> PRA
-    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 2, s.nTAW});
-    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRP});
-    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRP});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    
-    // PD <-> PD
-    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-    
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/WideIO.h b/ext/ramulator/Ramulator/src/WideIO.h
deleted file mode 100644
index 4cdbc7646..000000000
--- a/ext/ramulator/Ramulator/src/WideIO.h
+++ /dev/null
@@ -1,203 +0,0 @@
-#ifndef __WIDEIO_H
-#define __WIDEIO_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class WideIO
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    WideIO(Org org, Speed speed);
-    WideIO(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE, PRA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PD,  PDX,  SREF, SREFX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PRA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PD", "PDX",  "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PD, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<WideIO>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<WideIO>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<WideIO>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<WideIO>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        WideIO_1Gb,
-        WideIO_2Gb,
-        WideIO_4Gb,
-        WideIO_8Gb,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        // fixed to have 1 rank
-        { 256, 128, {0, 1, 4, 1<<12, 1<<7}},
-        { 512, 128, {0, 1, 4, 1<<13, 1<<7}},
-        {1024, 128, {0, 1, 4, 1<<14, 1<<7}},
-        {2048, 128, {0, 1, 4, 1<<15, 1<<7}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        WideIO_200,
-        WideIO_266,
-        MAX
-    };
-    
-    int prefetch_size = 4; // 4n prefetch SDR
-    int channel_width = 128;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nDQSCK;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nRTW, nWTR, nWR;
-        int nRRD, nTAW;
-        int nRFC, nREFI;
-        int nCKE, nXP;
-        int nCKESR, nXSR; // tXSR = tRFC+10
-    } speed_table[int(Speed::MAX)] = {
-        {200, 200.0/3*3, 5.0*3/3, 4, 4, 1, 3, 4, 4, 1,  9, 12, 4, 8, 3, 3, 2, 10, 0, 0, 3, 2, 3, 0},
-        {266, 200.0/3*4, 5.0*3/4, 4, 4, 1, 3, 5, 5, 1, 12, 16, 4, 8, 4, 4, 3, 14, 0, 0, 3, 3, 4, 0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__WIDEIO_H*/
diff --git a/ext/ramulator/Ramulator/src/WideIO2.cpp b/ext/ramulator/Ramulator/src/WideIO2.cpp
deleted file mode 100644
index c4517382e..000000000
--- a/ext/ramulator/Ramulator/src/WideIO2.cpp
+++ /dev/null
@@ -1,339 +0,0 @@
-#include "WideIO2.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string WideIO2::standard_name = "WideIO2";
-string WideIO2::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum WideIO2::Org> WideIO2::org_map = {
-    {"WideIO2_8Gb", WideIO2::Org::WideIO2_8Gb},
-};
-
-map<string, enum WideIO2::Speed> WideIO2::speed_map = {
-    {"WideIO2_800", WideIO2::Speed::WideIO2_800}, 
-    {"WideIO2_1066", WideIO2::Speed::WideIO2_1066},
-};
-
-WideIO2::WideIO2(Org org, Speed speed, int channels) :  
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    switch(int(org)){
-        case int(Org::WideIO2_8Gb):
-            org_entry.size = (8<<10) / channels;
-            org_entry.dq = 64;
-            if (channels == 4) {
-                org_entry.size = 2<<10;
-                org_entry.count[int(Level::Channel)] = channels;
-                org_entry.count[int(Level::Rank)] = 0;
-                org_entry.count[int(Level::Bank)] = 8;
-                org_entry.count[int(Level::Row)] = 1<<13;
-                org_entry.count[int(Level::Column)] = 1<<9;
-            } else if (channels == 8) {
-                org_entry.size = 1<<10;
-                org_entry.count[int(Level::Channel)] = channels;
-                org_entry.count[int(Level::Rank)] = 0;
-                org_entry.count[int(Level::Bank)] = 4;
-                org_entry.count[int(Level::Row)] = 1<<14;
-                org_entry.count[int(Level::Column)] = 1<<8;
-            } else assert(false && "The WideIO2 interface supports 4 or 8 physical channels.");
-            break;
-        default: assert(false);
-    }
-    speed_entry.nRPab = (channels == 4)? speed_entry.nRP8b: speed_entry.nRPpb;
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_lambda();
-    init_timing();
-}
-
-WideIO2::WideIO2(const string& org_str, const string& speed_str, int channels) :
-    WideIO2(org_map[org_str], speed_map[speed_str], channels)
-{
-}
-
-void WideIO2::set_channel_number(int channel) {
-  assert((channel == org_entry.count[int(Level::Channel)]) && "channel number must be consistent with spec initializaiton configuration.");
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void WideIO2::set_rank_number(int rank) {
-  assert(((rank == 1) || (rank == 2)) && "WideIO2 supports single and dual rank configurations.");
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void WideIO2::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PRA;
-        }
-        return Command::REF;};
-    // PD
-    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PD;
-            case int(State::ActPowerDown): return Command::PD;
-            case int(State::PrePowerDown): return Command::PD;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void WideIO2::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO2::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO2::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<WideIO2>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO2>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void WideIO2::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PRA
-    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + 1 + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nDQSCK + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nDQSCK + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + 1 + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + 1 + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRPab});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRPab});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRPab});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-    t[int(Command::REFPB)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-
-    // PD <-> PD
-    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-    
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + 1 + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + 1 + s.nBL + s.nWR + s.nRPpb});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-    // between different banks
-    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-    // REFPB
-    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-}
diff --git a/ext/ramulator/Ramulator/src/WideIO2.h b/ext/ramulator/Ramulator/src/WideIO2.h
deleted file mode 100644
index 36ee794ff..000000000
--- a/ext/ramulator/Ramulator/src/WideIO2.h
+++ /dev/null
@@ -1,199 +0,0 @@
-#ifndef __WIDEIO2_H
-#define __WIDEIO2_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class WideIO2
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    WideIO2(Org org, Speed speed, int channels = 4);
-    WideIO2(const string& org_str, const string& speed_str, int channels = 4);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE,   PRA, 
-        RD,  WR,    RDA,  WRA, 
-        REF, REFPB, PD,  PDX,  SREF, SREFX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE",   "PRA", 
-        "RD",  "WR",    "RDA", "WRA", 
-        "REF", "REFPB", "PD",  "PDX",  "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PD, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<WideIO2>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<WideIO2>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<WideIO2>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<WideIO2>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        // per-die density
-        WideIO2_8Gb,
-        // WideIO2_12Gb, tRFC TBD
-        // WideIO2_16Gb, tRFC TBD
-        // WideIO2_24Gb, TBD
-        // WideIO2_32Gb, TBD
-        MAX
-    };
-
-    struct OrgEntry {
-        int size; // per-channel density
-        int dq;
-        int count[int(Level::MAX)];
-    } org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        WideIO2_800,
-        WideIO2_1066,
-        MAX
-    };
-    // WideIO2 specified /4, /2, x1, x2, x4 refresh rates. x1 is used here
-
-    int prefetch_size = 4;
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nDQSCK, nRTRS; // 4n prefetch, DDR (although 8n is allowed?)
-        int nCL, nRCD, nRPpb, nRP8b, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI;
-        int nCKE, nXP;
-        int nCKESR, nXSR;
-    } speed_table[int(Speed::MAX)] = {
-        { 800, 800.0/3*3, 2.5*3/3, 2, 2, 1, 2, 7,  8,  8,  9, 0, 5, 17, 25, 3, 4,  8, 4, 24, 72, 36, 1560, 3, 3, 6,  76},
-        {1066, 800.0/3*4, 2.5*3/4, 2, 2, 1, 2, 9, 10, 10, 12, 0, 7, 23, 33, 4, 6, 11, 6, 32, 96, 48, 2080, 3, 4, 8, 102}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__WIDEIO2_H*/
diff --git a/ext/ramulator/Ramulator/src/temp.txt b/ext/ramulator/Ramulator/src/temp.txt
deleted file mode 100644
index 2e4899223..000000000
--- a/ext/ramulator/Ramulator/src/temp.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-
-
-#include "ALDRAM.h"
-#include "TLDRAM.h"
-
-
-    ALDRAM* aldram = new ALDRAM(ALDRAM::Org::ALDRAM_4Gb_x8, ALDRAM::Speed::ALDRAM_1600K);
-    IPC = run_simulation(aldram, argv[1], 1, 1, 4);
-    printf("ALDRAM:   %.5lf %.5lf\n", IPC, IPC / baseIPC);
-
-    TLDRAM* tldram = new TLDRAM(TLDRAM::Org::TLDRAM_4Gb_x8, TLDRAM::Speed::TLDRAM_1600K, 16);
-    IPC = run_simulation(tldram, argv[1], 1, 1, 4);
-    printf("TLDRAM:   %.5lf %.5lf\n", IPC, IPC / baseIPC);
-
-
-            // ALDRAM: update timing parameters based on temperatures
-            ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-            update_temp(current_temperature);
-
-
-    void update_temp(ALDRAM::Temp current_temperature)
-    {
-    }
-
-
-template <>
-void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature){
-    channel->spec->aldram_timing(current_temperature);
-}
-
-
-template <>
-void Controller<TLDRAM>::tick(){
-    clk++;
-
-    /*** 1. Serve completed reads ***/
-    if (pending.size()) {
-        Request& req = pending[0];
-        if (req.depart <= clk) {
-            req.callback(req);
-            pending.pop_front();
-        }
-    }
-
-    /*** 2. Should we schedule refreshes? ***/
-    int refresh_interval = channel->spec->speed_entry.nREFI;
-    if (clk - refreshed >= refresh_interval) {
-        auto req_type = Request::Type::REFRESH;
-
-        vector<int> addr_vec(int(TLDRAM::Level::MAX), -1);
-        addr_vec[0] = channel->id;
-        for (auto child : channel->children) {
-            addr_vec[1] = child->id;
-            Request req(addr_vec, req_type, NULL);
-            bool res = enqueue(req);
-            assert(res);
-        }
-        refreshed = clk;
-    }
-
-    /*** 3. Should we schedule writes? ***/
-    if (!write_mode) {
-        // yes -- write queue is almost full or read queue is empty
-        if (writeq.size() >= int(0.8 * writeq.max) || readq.size() == 0)
-            write_mode = true;
-    }
-    else {
-        // no -- write queue is almost empty and read queue is not empty
-        if (writeq.size() <= int(0.2 * writeq.max) && readq.size() != 0)
-            write_mode = false;
-    }
-
-    /*** 4. Find the best command to schedule, if any ***/
-    Queue* queue = !write_mode ? &readq : &writeq;
-    if (otherq.size())
-        queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-
-    auto req = scheduler->get_head(queue->q);
-    if (req == queue->q.end() || !is_ready(req)) {
-        // we couldn't find a command to schedule -- let's try to be speculative
-        auto cmd = TLDRAM::Command::PRE;
-        vector<int> victim = rowpolicy->get_victim(cmd);
-        if (!victim.empty()){
-            issue_cmd(cmd, victim);
-        }
-        return;  // nothing more to be done this cycle
-    }
-
-    /*** 5. Change a read request to a migration request ***/
-    if (req->type == Request::Type::READ) {
-        req->type = Request::Type::EXTENSION;
-    }
-
-    // issue command on behalf of request
-    auto cmd = get_first_cmd(req);
-    issue_cmd(cmd, get_addr_vec(cmd, req));
-
-    // check whether this is the last command (which finishes the request)
-    if (cmd != channel->spec->translate[int(req->type)])
-        return;
-
-    // set a future completion time for read requests
-    if (req->type == Request::Type::READ || req->type == Request::Type::EXTENSION) {
-        req->depart = clk + channel->spec->read_latency;
-        pending.push_back(*req);
-    }
-
-    // remove request from queue
-    queue->q.erase(req);
-}
-
-
-        EXTENSION,  // DHL: supporting extended functionality
diff --git a/ext/ramulator/SConscript b/ext/ramulator/SConscript
deleted file mode 100644
index 270903473..000000000
--- a/ext/ramulator/SConscript
+++ /dev/null
@@ -1,49 +0,0 @@
-# -*- mode:python -*-
-
-import os
-
-Import('main')
-
-if not os.path.exists(Dir('.').srcnode().abspath + '/Ramulator'):
-    main['HAVE_RAMULATOR'] = False
-    Return()
-
-# We have got the folder, so add the library and build the wrappers
-main['HAVE_RAMULATOR'] = True
-
-# Add the appropriate files. We leave out the trace driven simulator
-dram_files = []
-
-def DRAMFile(filename):
-    dram_files.append(File('Ramulator/src/' + filename))
-
-DRAMFile('Config.cpp')
-DRAMFile('Controller.cpp')
-DRAMFile('DDR3.cpp')
-DRAMFile('DDR4.cpp')
-DRAMFile('GDDR5.cpp')
-DRAMFile('Gem5Wrapper.cpp')
-DRAMFile('HBM.cpp')
-DRAMFile('LPDDR3.cpp')
-DRAMFile('LPDDR4.cpp')
-DRAMFile('MemoryFactory.cpp')
-DRAMFile('SALP.cpp')
-DRAMFile('WideIO.cpp')
-DRAMFile('WideIO2.cpp')
-DRAMFile('TLDRAM.cpp')
-DRAMFile('ALDRAM.cpp')
-
-dramenv = main.Clone()
-dramenv.Append(CXXFLAGS=['-g'])
-dramenv.Append(CXXFLAGS=['-Wno-missing-field-initializers'])
-dramenv.Append(CXXFLAGS=['-Wno-unused-variable'])
-dramenv.Append(CXXFLAGS=['-Wno-reorder'])
-
-# added support to hook in gem5 headers
-dramenv.Append(CPPPATH = Dir('./../../src/'))
-
-dramenv.Library('ramulator', [dramenv.SharedObject(f) for f in dram_files])
-
-main.Prepend(CPPPATH=Dir('.'))
-main.Append(LIBS=['ramulator'])
-main.Prepend(LIBPATH=[Dir('.')])
diff --git a/src/base/enums/ByteOrder.hh b/src/base/enums/ByteOrder.hh
deleted file mode 100644
index 58d6c37eb..000000000
--- a/src/base/enums/ByteOrder.hh
+++ /dev/null
@@ -1,11 +0,0 @@
-#ifndef __ENUM__None__ByteOrder__
-#define __ENUM__None__ByteOrder__
-
-enum class ByteOrder {
-    big = 0,
-    little = 1,
-    Num_ByteOrder = 2
-};
-extern const char *ByteOrderStrings[static_cast<int>(ByteOrder::Num_ByteOrder)];
-
-#endif // __ENUM__None__ByteOrder__
diff --git a/src/mem/Ramulator.py b/src/mem/Ramulator.py
deleted file mode 100644
index 08a1d46ab..000000000
--- a/src/mem/Ramulator.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# -*- mode:python -*-
-from m5.params import *
-from m5.objects.AbstractMemory import *
-
-# A wrapper for Ramulator multi-channel memory controller
-class Ramulator(AbstractMemory):
-    type = 'Ramulator'
-    cxx_header = "mem/ramulator.hh"
-
-    # A single port for now
-    port = SlavePort("Slave port")
-
-    config_file = Param.String("", "configuration file")
-    num_cpus = Param.Unsigned(1, "Number of cpu")
-    
-    # gagan
-    real_warm_up = Param.UInt64(100, "specify the real warm up time")
-    output_dir = Param.String("", "Ramulator trace output")
diff --git a/src/mem/SConscript b/src/mem/SConscript
index 63b82d6da..cf7adc866 100644
--- a/src/mem/SConscript
+++ b/src/mem/SConscript
@@ -100,11 +100,6 @@ if env['HAVE_DRAMSIM3']:
     Source('dramsim3_wrapper.cc')
     Source('dramsim3.cc')
 
-if env['HAVE_RAMULATOR']:
-    SimObject("Ramulator.py")
-    Source('ramulator.cc')
-    DebugFlag("Ramulator")
-
 SimObject('MemChecker.py')
 Source('mem_checker.cc')
 Source('mem_checker_monitor.cc')
diff --git a/src/mem/SConscript.orig b/src/mem/SConscript.orig
deleted file mode 100644
index cf7adc866..000000000
--- a/src/mem/SConscript.orig
+++ /dev/null
@@ -1,137 +0,0 @@
-# -*- mode:python -*-
-#
-# Copyright (c) 2018-2020 ARM Limited
-# All rights reserved
-#
-# The license below extends only to copyright in the software and shall
-# not be construed as granting a license to any other intellectual
-# property including but not limited to intellectual property relating
-# to a hardware implementation of the functionality of the software
-# licensed hereunder.  You may use the software subject to the license
-# terms below provided that you ensure that this notice is replicated
-# unmodified and in its entirety in all distributions of the software,
-# modified or unmodified, in source code or in binary form.
-#
-# Copyright (c) 2006 The Regents of The University of Michigan
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met: redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer;
-# redistributions in binary form must reproduce the above copyright
-# notice, this list of conditions and the following disclaimer in the
-# documentation and/or other materials provided with the distribution;
-# neither the name of the copyright holders nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-Import('*')
-
-SimObject('CommMonitor.py')
-Source('comm_monitor.cc')
-
-SimObject('AbstractMemory.py')
-SimObject('AddrMapper.py')
-SimObject('Bridge.py')
-SimObject('MemCtrl.py')
-SimObject('MemInterface.py')
-SimObject('DRAMInterface.py')
-SimObject('NVMInterface.py')
-SimObject('ExternalMaster.py')
-SimObject('ExternalSlave.py')
-SimObject('MemObject.py')
-SimObject('SimpleMemory.py')
-SimObject('XBar.py')
-SimObject('HMCController.py')
-SimObject('SerialLink.py')
-SimObject('MemDelay.py')
-
-Source('abstract_mem.cc')
-Source('addr_mapper.cc')
-Source('bridge.cc')
-Source('coherent_xbar.cc')
-Source('drampower.cc')
-Source('external_master.cc')
-Source('external_slave.cc')
-Source('mem_ctrl.cc')
-Source('mem_interface.cc')
-Source('noncoherent_xbar.cc')
-Source('packet.cc')
-Source('port.cc')
-Source('packet_queue.cc')
-Source('port_proxy.cc')
-Source('physical.cc')
-Source('simple_mem.cc')
-Source('snoop_filter.cc')
-Source('stack_dist_calc.cc')
-Source('token_port.cc')
-Source('tport.cc')
-Source('xbar.cc')
-Source('hmc_controller.cc')
-Source('htm.cc')
-Source('serial_link.cc')
-Source('mem_delay.cc')
-
-if env['TARGET_ISA'] != 'null':
-    Source('translating_port_proxy.cc')
-    Source('se_translating_port_proxy.cc')
-    Source('page_table.cc')
-
-if env['HAVE_DRAMSIM']:
-    SimObject('DRAMSim2.py')
-    Source('dramsim2_wrapper.cc')
-    Source('dramsim2.cc')
-
-if env['HAVE_DRAMSIM3']:
-    SimObject('DRAMsim3.py')
-    Source('dramsim3_wrapper.cc')
-    Source('dramsim3.cc')
-
-SimObject('MemChecker.py')
-Source('mem_checker.cc')
-Source('mem_checker_monitor.cc')
-
-DebugFlag('AddrRanges')
-DebugFlag('BaseXBar')
-DebugFlag('CoherentXBar')
-DebugFlag('NoncoherentXBar')
-DebugFlag('SnoopFilter')
-CompoundFlag('XBar', ['BaseXBar', 'CoherentXBar', 'NoncoherentXBar',
-                      'SnoopFilter'])
-
-DebugFlag('Bridge')
-DebugFlag('CommMonitor')
-DebugFlag('DRAM')
-DebugFlag('DRAMPower')
-DebugFlag('DRAMState')
-DebugFlag('NVM')
-DebugFlag('ExternalPort')
-DebugFlag('HtmMem', 'Hardware Transactional Memory (Mem side)')
-DebugFlag('LLSC')
-DebugFlag('MemCtrl')
-DebugFlag('MMU')
-DebugFlag('MemoryAccess')
-DebugFlag('PacketQueue')
-DebugFlag('StackDist')
-DebugFlag("DRAMSim2")
-DebugFlag("DRAMsim3")
-DebugFlag('HMCController')
-DebugFlag('SerialLink')
-DebugFlag('TokenPort')
-
-DebugFlag("MemChecker")
-DebugFlag("MemCheckerMonitor")
-DebugFlag("QOS")
diff --git a/src/mem/ramulator.cc b/src/mem/ramulator.cc
deleted file mode 100644
index 3618c3baa..000000000
--- a/src/mem/ramulator.cc
+++ /dev/null
@@ -1,283 +0,0 @@
-#include "base/callback.hh"
-#include "mem/ramulator.hh"
-#include "Ramulator/src/Gem5Wrapper.h"
-#include "Ramulator/src/Request.h"
-#include "sim/system.hh"
-#include "debug/Ramulator.hh"
-
-// daz3
-ramulator::Gem5Wrapper* wrapper1 = NULL;
-bool del_wrapper = false;
-Tick begin_tick = 0;
-Tick print_interval = 200000000;//0.2ms
-unsigned long my_read_cnt = 0;
-unsigned long my_write_cnt = 0;
-unsigned long my_total_cnt = 0;
-
-Ramulator::Ramulator(const Params *p):
-    AbstractMemory(p),
-    port(name() + ".port", *this),
-    requestsInFlight(0),
-    drain_manager(NULL),
-    config_file(p->config_file),
-    configs(p->config_file),
-    wrapper(NULL),
-    read_cb_func(std::bind(&Ramulator::readComplete, this, std::placeholders::_1)),
-    write_cb_func(std::bind(&Ramulator::writeComplete, this, std::placeholders::_1)),
-    ticks_per_clk(0),
-    resp_stall(false),
-    req_stall(false),
-    send_resp_event(this),
-    tick_event(this) 
-{
-  warmuptime = p->real_warm_up;
-
-  configs.set_core_num(p->num_cpus);
-  configs.set_tracefile_directory(p->output_dir);
-}
-Ramulator::~Ramulator()
-{
-    // delete wrapper;
-    // daz3
-    if(del_wrapper == false)
-    {
-        delete wrapper;
-        del_wrapper = true;
-    }
-}
-
-void Ramulator::init() {
-    if (!port.isConnected()){ 
-        fatal("Ramulator port not connected\n");
-    } else { 
-        port.sendRangeChange(); 
-    }
-
-    if (wrapper1 != NULL)
-    {
-        wrapper = wrapper1;
-    }
-    else
-    {
-        wrapper = new ramulator::Gem5Wrapper(configs, system()->cacheLineSize());
-        wrapper1 = wrapper;
-    }
-    // daz3
-    // wrapper = new ramulator::Gem5Wrapper(configs, system()->cacheLineSize());
-    ticks_per_clk = Tick(wrapper->tCK * SimClock::Float::ns);
-
-    DPRINTF(Ramulator, "Instantiated Ramulator with config file '%s' (tCK=%lf, %d ticks per clk)\n", 
-        config_file.c_str(), wrapper->tCK, ticks_per_clk);
-    //Callback* cb = new MakeCallback<ramulator::Gem5Wrapper, &ramulator::Gem5Wrapper::finish>(wrapper);
-    //registerExitCallback(cb);
-    //**** ramulator integration ******
-    registerExitCallback([this]() { wrapper->finish(); });
-}
-
-void Ramulator::startup() {
-    schedule(tick_event, clockEdge());
-}
-
-unsigned int Ramulator::drain(DrainManager* dm) {
-    // DPRINTF(Ramulator, "Requested to drain\n");
-    // // updated to include all in-flight requests
-    // // if (resp_queue.size()) {
-    // if (numOutstanding()) {
-    //     setDrainState(Drainable::Draining);
-    //     drain_manager = dm;
-    //     return 1;
-    // } else {
-    //     setDrainState(Drainable::Drained);
-    //     return 0;
-    // }
-    return 0;
-}
-
-Port& Ramulator::getPort(const std::string& if_name, PortID idx) {
-    if (if_name != "port") {
-        return AbstractMemory::getPort(if_name, idx);
-    } else {
-        return port;
-    }
-}
-
-void Ramulator::sendResponse() {
-    assert(!resp_stall);
-    assert(!resp_queue.empty());
-
-    DPRINTF(Ramulator, "Attempting to send response\n");
-
-    long addr = resp_queue.front()->getAddr();
-    if(addr){/*DO NOTHING. For avoid error unused-variable*/}
-    if (port.sendTimingResp(resp_queue.front())){
-        DPRINTF(Ramulator, "Response to %ld sent.\n", addr);
-        resp_queue.pop_front();
-        if (resp_queue.size() && !send_resp_event.scheduled())
-            schedule(send_resp_event, curTick());
-
-        // check if we were asked to drain and if we are now done
-        if (drain_manager && numOutstanding() == 0) {
-            drain_manager->signalDrainDone();
-            drain_manager = NULL;
-        }
-    } else 
-        resp_stall = true;
-}
-    
-void Ramulator::tick() {
-    wrapper->tick();
-    if (req_stall){
-        req_stall = false;
-        port.sendRetryReq();
-    }
-    //AbstractMemory::occupancyL3Cache = L3->occupancy();
-    schedule(tick_event, curTick() + ticks_per_clk);
-}
-
-// added an atomic packet response function to enable fast forwarding
-Tick Ramulator::recvAtomic(PacketPtr pkt) {
-    access(pkt);
-    //L3->call(pkt->getAddr());
-    // set an fixed arbitrary 50ns response time for atomic requests
-    return pkt->cacheResponding() ? 0 : 50000;
-}
-
-void Ramulator::recvFunctional(PacketPtr pkt) {
-    pkt->pushLabel(name());
-    functionalAccess(pkt);
-    for (auto i = resp_queue.begin(); i != resp_queue.end(); ++i)
-        pkt->trySatisfyFunctional(*i);
-    pkt->popLabel();
-}
-
-bool Ramulator::recvTimingReq(PacketPtr pkt) {
-    // we should never see a new request while in retry
-    assert(!req_stall);
-
-    for (PacketPtr pendPkt: pending_del)
-        delete pendPkt;
-    pending_del.clear();
-
-    // daz3
-    if (begin_tick == 0) {
-        begin_tick = curTick();
-    }
-
-    if (pkt->cacheResponding()) {
-        // snooper will supply based on copy of packet
-        // still target's responsibility to delete packet
-        pending_del.push_back(pkt);
-        return true;
-    }
-
-    // daz3
-    if (curTick()<=(begin_tick + warmuptime))
-      {
-        my_total_cnt++;
-        accessAndRespond(pkt);
-        return true;
-      }
-    
-    bool accepted = true;
-    if (pkt->isRead()) {
-      //DPRINTF(Ramulator, "context id: %d, thread id: %d\n", pkt->req->contextId(),
-      //    pkt->req->threadId());
-      ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::READ, read_cb_func, pkt->req->isPrefetch(), 0);
-        //daz3
-        // ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::READ, read_cb_func, 0);
-        accepted = wrapper->send(req);
-        if (accepted){
-            reads[req.addr].push_back(pkt);
-            DPRINTF(Ramulator, "Read to %ld accepted.\n", req.addr);
-
-            // added counter to track requests in flight
-            ++requestsInFlight;
-            // daz3
-            my_read_cnt++;
-            my_total_cnt++;
-        } else {
-            req_stall = true;
-        }
-    } else if (pkt->isWrite()) {
-        // Detailed CPU model always comes along with cache model enabled and
-        // write requests are caused by cache eviction, so it shouldn't be
-        // tallied for any core/thread
-        ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::WRITE, write_cb_func, false, 0);
-        accepted = wrapper->send(req);
-        if (accepted){
-            accessAndRespond(pkt);
-            DPRINTF(Ramulator, "Write to %ld accepted and served.\n", req.addr);
-
-            // added counter to track requests in flight
-            ++requestsInFlight;
-            // daz3
-            my_write_cnt++;
-            my_total_cnt++;
-        } else {
-            req_stall = true;
-        }
-    } else {
-        // keep it simple and just respond if necessary
-        accessAndRespond(pkt);
-        // daz3
-        my_total_cnt++;
-    }
-    return accepted;
-}
-
-void Ramulator::recvRespRetry() {
-    DPRINTF(Ramulator, "Retrying\n");
-
-    assert(resp_stall);
-    resp_stall = false;
-    sendResponse();
-}
-
-void Ramulator::accessAndRespond(PacketPtr pkt) {
-    bool need_resp = pkt->needsResponse();
-    access(pkt);
-    if (need_resp) {
-        assert(pkt->isResponse());
-        pkt->headerDelay = pkt->payloadDelay = 0;
-
-        DPRINTF(Ramulator, "Queuing response for address %lld\n",
-                pkt->getAddr());
-
-        resp_queue.push_back(pkt);
-	// gagan : added 18 ns latency for the L3 cache
-        if (!resp_stall && !send_resp_event.scheduled())
-            schedule(send_resp_event, curTick());
-    } else 
-        pending_del.push_back(pkt);
-}
-
-void Ramulator::readComplete(ramulator::Request& req){
-    DPRINTF(Ramulator, "Read to %ld completed.\n", req.addr);
-    auto& pkt_q = reads.find(req.addr)->second;
-    PacketPtr pkt = pkt_q.front();
-    pkt_q.pop_front();
-    if (!pkt_q.size())
-        reads.erase(req.addr);
-
-    // added counter to track requests in flight
-    --requestsInFlight;
-
-    accessAndRespond(pkt);
-}
-
-void Ramulator::writeComplete(ramulator::Request& req){
-    DPRINTF(Ramulator, "Write to %ld completed.\n", req.addr);
-
-    // added counter to track requests in flight
-    --requestsInFlight;
-
-    // check if we were asked to drain and if we are now done
-    if (drain_manager && numOutstanding() == 0) {
-        drain_manager->signalDrainDone();
-        drain_manager = NULL;
-    }
-}
-
-Ramulator *RamulatorParams::create(){
-    return new Ramulator(this);
-}
diff --git a/src/mem/ramulator.hh b/src/mem/ramulator.hh
deleted file mode 100644
index 1a3529b5e..000000000
--- a/src/mem/ramulator.hh
+++ /dev/null
@@ -1,97 +0,0 @@
-#ifndef __RAMULATOR_HH__
-#define __RAMULATOR_HH__
-
-#include <deque>
-#include <tuple>
-#include <map>
-
-#include "mem/abstract_mem.hh"
-#include "params/Ramulator.hh"
-#include "Ramulator/src/Config.h"
-
-namespace ramulator{
-    class Request;
-    class Gem5Wrapper;
-}
-
-class Ramulator : public AbstractMemory {
-private:
-
-    class MemoryPort: public SlavePort {
-    private:
-        Ramulator& mem;
-    public:
-        MemoryPort(const std::string& _name, Ramulator& _mem): SlavePort(_name, &_mem), mem(_mem) {}
-    protected:
-        Tick recvAtomic(PacketPtr pkt) {
-            // modified to perform a fixed latency return for atomic packets to enable fast forwarding
-            // assert(false && "only accepts functional or timing packets");
-            return mem.recvAtomic(pkt);
-        }
-        
-        void recvFunctional(PacketPtr pkt) {
-            mem.recvFunctional(pkt);
-        }
-
-        bool recvTimingReq(PacketPtr pkt) {
-            return mem.recvTimingReq(pkt);
-        }
-
-        void recvRespRetry() {
-            mem.recvRespRetry();
-        }
-
-        AddrRangeList getAddrRanges() const {
-            AddrRangeList ranges;
-            ranges.push_back(mem.getAddrRange());
-            return ranges;
-        }
-    } port;
-
-    unsigned int requestsInFlight;
-    std::map<long, std::deque<PacketPtr> > reads;
-    std::map<long, std::deque<PacketPtr> > writes;
-    std::deque<PacketPtr> resp_queue;
-    std::deque<PacketPtr> pending_del;
-    DrainManager *drain_manager;
-
-    std::string config_file;
-    ramulator::Config configs;
-    ramulator::Gem5Wrapper *wrapper;
-    std::function<void(ramulator::Request&)> read_cb_func;
-    std::function<void(ramulator::Request&)> write_cb_func;
-    Tick ticks_per_clk;
-    bool resp_stall;
-    bool req_stall;
-    // gagan :
-    Tick warmuptime;
-
-    unsigned int numOutstanding() const { return requestsInFlight + resp_queue.size(); }
-    
-    void sendResponse();
-    void tick();
-    
-    EventWrapper<Ramulator, &Ramulator::sendResponse> send_resp_event;
-    EventWrapper<Ramulator, &Ramulator::tick> tick_event;
-
-public:
-    typedef RamulatorParams Params;
-    Ramulator(const Params *p);
-    virtual void init();
-    virtual void startup();
-    unsigned int drain(DrainManager* dm);
-    virtual Port& getPort(const std::string& if_name, 
-        PortID idx = InvalidPortID);
-    ~Ramulator();
-
-protected:
-    Tick recvAtomic(PacketPtr pkt);
-    void recvFunctional(PacketPtr pkt);
-    bool recvTimingReq(PacketPtr pkt);
-    void recvRespRetry();
-    void accessAndRespond(PacketPtr pkt);
-    void readComplete(ramulator::Request& req);
-    void writeComplete(ramulator::Request& req);
-};
-
-#endif // __RAMULATOR_HH__
diff --git a/src/python/m5/params.py b/src/python/m5/params.py
index 5bbafdf98..45082d7ac 100644
--- a/src/python/m5/params.py
+++ b/src/python/m5/params.py
@@ -222,7 +222,7 @@ class ParamDesc(object):
         return self.ptype(value).pretty_print(value)
 
     def cxx_predecls(self, code):
-        code('#include <stddef.h>')
+        code('#include <cstddef>')
         self.ptype.cxx_predecls(code)
 
     def pybind_predecls(self, code):
diff --git a/src/python/m5/params.py.orig b/src/python/m5/params.py.orig
deleted file mode 100644
index 45082d7ac..000000000
--- a/src/python/m5/params.py.orig
+++ /dev/null
@@ -1,2257 +0,0 @@
-# Copyright (c) 2012-2014, 2017-2019 ARM Limited
-# All rights reserved.
-#
-# The license below extends only to copyright in the software and shall
-# not be construed as granting a license to any other intellectual
-# property including but not limited to intellectual property relating
-# to a hardware implementation of the functionality of the software
-# licensed hereunder.  You may use the software subject to the license
-# terms below provided that you ensure that this notice is replicated
-# unmodified and in its entirety in all distributions of the software,
-# modified or unmodified, in source code or in binary form.
-#
-# Copyright (c) 2004-2006 The Regents of The University of Michigan
-# Copyright (c) 2010-2011 Advanced Micro Devices, Inc.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met: redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer;
-# redistributions in binary form must reproduce the above copyright
-# notice, this list of conditions and the following disclaimer in the
-# documentation and/or other materials provided with the distribution;
-# neither the name of the copyright holders nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#####################################################################
-#
-# Parameter description classes
-#
-# The _params dictionary in each class maps parameter names to either
-# a Param or a VectorParam object.  These objects contain the
-# parameter description string, the parameter type, and the default
-# value (if any).  The convert() method on these objects is used to
-# force whatever value is assigned to the parameter to the appropriate
-# type.
-#
-# Note that the default values are loaded into the class's attribute
-# space when the parameter dictionary is initialized (in
-# MetaSimObject._new_param()); after that point they aren't used.
-#
-#####################################################################
-
-from __future__ import print_function
-from six import with_metaclass
-import six
-if six.PY3:
-    long = int
-
-import copy
-import datetime
-import re
-import sys
-import time
-import math
-
-from . import proxy
-from . import ticks
-from .util import *
-
-def isSimObject(*args, **kwargs):
-    from . import SimObject
-    return SimObject.isSimObject(*args, **kwargs)
-
-def isSimObjectSequence(*args, **kwargs):
-    from . import SimObject
-    return SimObject.isSimObjectSequence(*args, **kwargs)
-
-def isSimObjectClass(*args, **kwargs):
-    from . import SimObject
-    return SimObject.isSimObjectClass(*args, **kwargs)
-
-allParams = {}
-
-class MetaParamValue(type):
-    def __new__(mcls, name, bases, dct):
-        cls = super(MetaParamValue, mcls).__new__(mcls, name, bases, dct)
-        if name in allParams:
-            warn("%s already exists in allParams. This may be caused by the " \
-                 "Python 2.7 compatibility layer." % (name, ))
-        allParams[name] = cls
-        return cls
-
-
-# Dummy base class to identify types that are legitimate for SimObject
-# parameters.
-class ParamValue(with_metaclass(MetaParamValue, object)):
-    cmd_line_settable = False
-
-    # Generate the code needed as a prerequisite for declaring a C++
-    # object of this type.  Typically generates one or more #include
-    # statements.  Used when declaring parameters of this type.
-    @classmethod
-    def cxx_predecls(cls, code):
-        pass
-
-    @classmethod
-    def pybind_predecls(cls, code):
-        cls.cxx_predecls(code)
-
-    # default for printing to .ini file is regular string conversion.
-    # will be overridden in some cases
-    def ini_str(self):
-        return str(self)
-
-    # default for printing to .json file is regular string conversion.
-    # will be overridden in some cases, mostly to use native Python
-    # types where there are similar JSON types
-    def config_value(self):
-        return str(self)
-
-    # Prerequisites for .ini parsing with cxx_ini_parse
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        pass
-
-    # parse a .ini file entry for this param from string expression
-    # src into lvalue dest (of the param's C++ type)
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('// Unhandled param type: %s' % cls.__name__)
-        code('%s false;' % ret)
-
-    # allows us to blithely call unproxy() on things without checking
-    # if they're really proxies or not
-    def unproxy(self, base):
-        return self
-
-    # Produce a human readable version of the stored value
-    def pretty_print(self, value):
-        return str(value)
-
-# Regular parameter description.
-class ParamDesc(object):
-    def __init__(self, ptype_str, ptype, *args, **kwargs):
-        self.ptype_str = ptype_str
-        # remember ptype only if it is provided
-        if ptype != None:
-            self.ptype = ptype
-
-        if args:
-            if len(args) == 1:
-                self.desc = args[0]
-            elif len(args) == 2:
-                self.default = args[0]
-                self.desc = args[1]
-            else:
-                raise TypeError('too many arguments')
-
-        if 'desc' in kwargs:
-            assert(not hasattr(self, 'desc'))
-            self.desc = kwargs['desc']
-            del kwargs['desc']
-
-        if 'default' in kwargs:
-            assert(not hasattr(self, 'default'))
-            self.default = kwargs['default']
-            del kwargs['default']
-
-        if kwargs:
-            raise TypeError('extra unknown kwargs %s' % kwargs)
-
-        if not hasattr(self, 'desc'):
-            raise TypeError('desc attribute missing')
-
-    def __getattr__(self, attr):
-        if attr == 'ptype':
-            from . import SimObject
-            ptype = SimObject.allClasses[self.ptype_str]
-            assert isSimObjectClass(ptype)
-            self.ptype = ptype
-            return ptype
-
-        raise AttributeError("'%s' object has no attribute '%s'" % \
-              (type(self).__name__, attr))
-
-    def example_str(self):
-        if hasattr(self.ptype, "ex_str"):
-            return self.ptype.ex_str
-        else:
-            return self.ptype_str
-
-    # Is the param available to be exposed on the command line
-    def isCmdLineSettable(self):
-        if hasattr(self.ptype, "cmd_line_settable"):
-            return self.ptype.cmd_line_settable
-        else:
-            return False
-
-    def convert(self, value):
-        if isinstance(value, proxy.BaseProxy):
-            value.set_param_desc(self)
-            return value
-        if 'ptype' not in self.__dict__ and isNullPointer(value):
-            # deferred evaluation of SimObject; continue to defer if
-            # we're just assigning a null pointer
-            return value
-        if isinstance(value, self.ptype):
-            return value
-        if isNullPointer(value) and isSimObjectClass(self.ptype):
-            return value
-        return self.ptype(value)
-
-    def pretty_print(self, value):
-        if isinstance(value, proxy.BaseProxy):
-           return str(value)
-        if isNullPointer(value):
-           return NULL
-        return self.ptype(value).pretty_print(value)
-
-    def cxx_predecls(self, code):
-        code('#include <cstddef>')
-        self.ptype.cxx_predecls(code)
-
-    def pybind_predecls(self, code):
-        self.ptype.pybind_predecls(code)
-
-    def cxx_decl(self, code):
-        code('${{self.ptype.cxx_type}} ${{self.name}};')
-
-# Vector-valued parameter description.  Just like ParamDesc, except
-# that the value is a vector (list) of the specified type instead of a
-# single value.
-
-class VectorParamValue(with_metaclass(MetaParamValue, list)):
-    def __setattr__(self, attr, value):
-        raise AttributeError("Not allowed to set %s on '%s'" % \
-                             (attr, type(self).__name__))
-
-    def config_value(self):
-        return [v.config_value() for v in self]
-
-    def ini_str(self):
-        return ' '.join([v.ini_str() for v in self])
-
-    def getValue(self):
-        return [ v.getValue() for v in self ]
-
-    def unproxy(self, base):
-        if len(self) == 1 and isinstance(self[0], proxy.BaseProxy):
-            # The value is a proxy (e.g. Parent.any, Parent.all or
-            # Parent.x) therefore try resolve it
-            return self[0].unproxy(base)
-        else:
-            return [v.unproxy(base) for v in self]
-
-class SimObjectVector(VectorParamValue):
-    # support clone operation
-    def __call__(self, **kwargs):
-        return SimObjectVector([v(**kwargs) for v in self])
-
-    def clear_parent(self, old_parent):
-        for v in self:
-            v.clear_parent(old_parent)
-
-    def set_parent(self, parent, name):
-        if len(self) == 1:
-            self[0].set_parent(parent, name)
-        else:
-            width = int(math.ceil(math.log(len(self))/math.log(10)))
-            for i,v in enumerate(self):
-                v.set_parent(parent, "%s%0*d" % (name, width, i))
-
-    def has_parent(self):
-        return any([e.has_parent() for e in self if not isNullPointer(e)])
-
-    # return 'cpu0 cpu1' etc. for print_ini()
-    def get_name(self):
-        return ' '.join([v._name for v in self])
-
-    # By iterating through the constituent members of the vector here
-    # we can nicely handle iterating over all a SimObject's children
-    # without having to provide lots of special functions on
-    # SimObjectVector directly.
-    def descendants(self):
-        for v in self:
-            for obj in v.descendants():
-                yield obj
-
-    def get_config_as_dict(self):
-        a = []
-        for v in self:
-            a.append(v.get_config_as_dict())
-        return a
-
-    # If we are replacing an item in the vector, make sure to set the
-    # parent reference of the new SimObject to be the same as the parent
-    # of the SimObject being replaced. Useful to have if we created
-    # a SimObjectVector of temporary objects that will be modified later in
-    # configuration scripts.
-    def __setitem__(self, key, value):
-        val = self[key]
-        if value.has_parent():
-            warn("SimObject %s already has a parent" % value.get_name() +\
-                 " that is being overwritten by a SimObjectVector")
-        value.set_parent(val.get_parent(), val._name)
-        super(SimObjectVector, self).__setitem__(key, value)
-
-    # Enumerate the params of each member of the SimObject vector. Creates
-    # strings that will allow indexing into the vector by the python code and
-    # allow it to be specified on the command line.
-    def enumerateParams(self, flags_dict = {},
-                        cmd_line_str = "",
-                        access_str = ""):
-        if hasattr(self, "_paramEnumed"):
-            print("Cycle detected enumerating params at %s?!" % (cmd_line_str))
-        else:
-            x = 0
-            for vals in self:
-                # Each entry in the SimObjectVector should be an
-                # instance of a SimObject
-                flags_dict = vals.enumerateParams(flags_dict,
-                                                  cmd_line_str + "%d." % x,
-                                                  access_str + "[%d]." % x)
-                x = x + 1
-
-        return flags_dict
-
-class VectorParamDesc(ParamDesc):
-    # Convert assigned value to appropriate type.  If the RHS is not a
-    # list or tuple, it generates a single-element list.
-    def convert(self, value):
-        if isinstance(value, (list, tuple)):
-            # list: coerce each element into new list
-            tmp_list = [ ParamDesc.convert(self, v) for v in value ]
-        elif isinstance(value, str):
-            # If input is a csv string
-            tmp_list = [ ParamDesc.convert(self, v) \
-                         for v in value.strip('[').strip(']').split(',') ]
-        else:
-            # singleton: coerce to a single-element list
-            tmp_list = [ ParamDesc.convert(self, value) ]
-
-        if isSimObjectSequence(tmp_list):
-            return SimObjectVector(tmp_list)
-        else:
-            return VectorParamValue(tmp_list)
-
-    # Produce a human readable example string that describes
-    # how to set this vector parameter in the absence of a default
-    # value.
-    def example_str(self):
-        s = super(VectorParamDesc, self).example_str()
-        help_str = "[" + s + "," + s + ", ...]"
-        return help_str
-
-    # Produce a human readable representation of the value of this vector param.
-    def pretty_print(self, value):
-        if isinstance(value, (list, tuple)):
-            tmp_list = [ ParamDesc.pretty_print(self, v) for v in value ]
-        elif isinstance(value, str):
-            tmp_list = [ ParamDesc.pretty_print(self, v) for v in value.split(',') ]
-        else:
-            tmp_list = [ ParamDesc.pretty_print(self, value) ]
-
-        return tmp_list
-
-    # This is a helper function for the new config system
-    def __call__(self, value):
-        if isinstance(value, (list, tuple)):
-            # list: coerce each element into new list
-            tmp_list = [ ParamDesc.convert(self, v) for v in value ]
-        elif isinstance(value, str):
-            # If input is a csv string
-            tmp_list = [ ParamDesc.convert(self, v) \
-                         for v in value.strip('[').strip(']').split(',') ]
-        else:
-            # singleton: coerce to a single-element list
-            tmp_list = [ ParamDesc.convert(self, value) ]
-
-        return VectorParamValue(tmp_list)
-
-    def cxx_predecls(self, code):
-        code('#include <vector>')
-        self.ptype.cxx_predecls(code)
-
-    def pybind_predecls(self, code):
-        code('#include <vector>')
-        self.ptype.pybind_predecls(code)
-
-    def cxx_decl(self, code):
-        code('std::vector< ${{self.ptype.cxx_type}} > ${{self.name}};')
-
-class ParamFactory(object):
-    def __init__(self, param_desc_class, ptype_str = None):
-        self.param_desc_class = param_desc_class
-        self.ptype_str = ptype_str
-
-    def __getattr__(self, attr):
-        if self.ptype_str:
-            attr = self.ptype_str + '.' + attr
-        return ParamFactory(self.param_desc_class, attr)
-
-    # E.g., Param.Int(5, "number of widgets")
-    def __call__(self, *args, **kwargs):
-        ptype = None
-        try:
-            ptype = allParams[self.ptype_str]
-        except KeyError:
-            # if name isn't defined yet, assume it's a SimObject, and
-            # try to resolve it later
-            pass
-        return self.param_desc_class(self.ptype_str, ptype, *args, **kwargs)
-
-Param = ParamFactory(ParamDesc)
-VectorParam = ParamFactory(VectorParamDesc)
-
-#####################################################################
-#
-# Parameter Types
-#
-# Though native Python types could be used to specify parameter types
-# (the 'ptype' field of the Param and VectorParam classes), it's more
-# flexible to define our own set of types.  This gives us more control
-# over how Python expressions are converted to values (via the
-# __init__() constructor) and how these values are printed out (via
-# the __str__() conversion method).
-#
-#####################################################################
-
-# String-valued parameter.  Just mixin the ParamValue class with the
-# built-in str class.
-class String(ParamValue,str):
-    cxx_type = 'std::string'
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(self, code):
-        code('#include <string>')
-
-    def __call__(self, value):
-        self = value
-        return value
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s = %s;' % (dest, src))
-        code('%s true;' % ret)
-
-    def getValue(self):
-        return self
-
-# superclass for "numeric" parameter values, to emulate math
-# operations in a type-safe way.  e.g., a Latency times an int returns
-# a new Latency object.
-class NumericParamValue(ParamValue):
-    @staticmethod
-    def unwrap(v):
-        return v.value if isinstance(v, NumericParamValue) else v
-
-    def __str__(self):
-        return str(self.value)
-
-    def __float__(self):
-        return float(self.value)
-
-    def __long__(self):
-        return long(self.value)
-
-    def __int__(self):
-        return int(self.value)
-
-    # hook for bounds checking
-    def _check(self):
-        return
-
-    def __mul__(self, other):
-        newobj = self.__class__(self)
-        newobj.value *= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    __rmul__ = __mul__
-
-    def __truediv__(self, other):
-        newobj = self.__class__(self)
-        newobj.value /= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    def __floordiv__(self, other):
-        newobj = self.__class__(self)
-        newobj.value //= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-
-    def __add__(self, other):
-        newobj = self.__class__(self)
-        newobj.value += NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    def __sub__(self, other):
-        newobj = self.__class__(self)
-        newobj.value -= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    def __iadd__(self, other):
-        self.value += NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __isub__(self, other):
-        self.value -= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __imul__(self, other):
-        self.value *= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __itruediv__(self, other):
-        self.value /= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __ifloordiv__(self, other):
-        self.value //= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __lt__(self, other):
-        return self.value < NumericParamValue.unwrap(other)
-
-    # Python 2.7 pre __future__.division operators
-    # TODO: Remove these when after "import division from __future__"
-    __div__ =  __truediv__
-    __idiv__ = __itruediv__
-
-    def config_value(self):
-        return self.value
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        # Assume that base/str.hh will be included anyway
-        # code('#include "base/str.hh"')
-        pass
-
-    # The default for parsing PODs from an .ini entry is to extract from an
-    # istringstream and let overloading choose the right type according to
-    # the dest type.
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s to_number(%s, %s);' % (ret, src, dest))
-
-# Metaclass for bounds-checked integer parameters.  See CheckedInt.
-class CheckedIntType(MetaParamValue):
-    def __init__(cls, name, bases, dict):
-        super(CheckedIntType, cls).__init__(name, bases, dict)
-
-        # CheckedInt is an abstract base class, so we actually don't
-        # want to do any processing on it... the rest of this code is
-        # just for classes that derive from CheckedInt.
-        if name == 'CheckedInt':
-            return
-
-        if not (hasattr(cls, 'min') and hasattr(cls, 'max')):
-            if not (hasattr(cls, 'size') and hasattr(cls, 'unsigned')):
-                panic("CheckedInt subclass %s must define either\n" \
-                      "    'min' and 'max' or 'size' and 'unsigned'\n",
-                      name);
-            if cls.unsigned:
-                cls.min = 0
-                cls.max = 2 ** cls.size - 1
-            else:
-                cls.min = -(2 ** (cls.size - 1))
-                cls.max = (2 ** (cls.size - 1)) - 1
-
-# Abstract superclass for bounds-checked integer parameters.  This
-# class is subclassed to generate parameter classes with specific
-# bounds.  Initialization of the min and max bounds is done in the
-# metaclass CheckedIntType.__init__.
-class CheckedInt(with_metaclass(CheckedIntType, NumericParamValue)):
-    cmd_line_settable = True
-
-    def _check(self):
-        if not self.min <= self.value <= self.max:
-            raise TypeError('Integer param out of bounds %d < %d < %d' % \
-                  (self.min, self.value, self.max))
-
-    def __init__(self, value):
-        if isinstance(value, str):
-            self.value = convert.toInteger(value)
-        elif isinstance(value, (int, long, float, NumericParamValue)):
-            self.value = long(value)
-        else:
-            raise TypeError("Can't convert object of type %s to CheckedInt" \
-                  % type(value).__name__)
-        self._check()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __index__(self):
-        return int(self.value)
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        # most derived types require this, so we just do it here once
-        code('#include "base/types.hh"')
-
-    def getValue(self):
-        return long(self.value)
-
-class Int(CheckedInt):      cxx_type = 'int';      size = 32; unsigned = False
-class Unsigned(CheckedInt): cxx_type = 'unsigned'; size = 32; unsigned = True
-
-class Int8(CheckedInt):     cxx_type =   'int8_t'; size =  8; unsigned = False
-class UInt8(CheckedInt):    cxx_type =  'uint8_t'; size =  8; unsigned = True
-class Int16(CheckedInt):    cxx_type =  'int16_t'; size = 16; unsigned = False
-class UInt16(CheckedInt):   cxx_type = 'uint16_t'; size = 16; unsigned = True
-class Int32(CheckedInt):    cxx_type =  'int32_t'; size = 32; unsigned = False
-class UInt32(CheckedInt):   cxx_type = 'uint32_t'; size = 32; unsigned = True
-class Int64(CheckedInt):    cxx_type =  'int64_t'; size = 64; unsigned = False
-class UInt64(CheckedInt):   cxx_type = 'uint64_t'; size = 64; unsigned = True
-
-class Counter(CheckedInt):  cxx_type = 'Counter';  size = 64; unsigned = True
-class Tick(CheckedInt):     cxx_type = 'Tick';     size = 64; unsigned = True
-class TcpPort(CheckedInt):  cxx_type = 'uint16_t'; size = 16; unsigned = True
-class UdpPort(CheckedInt):  cxx_type = 'uint16_t'; size = 16; unsigned = True
-
-class Percent(CheckedInt):  cxx_type = 'int'; min = 0; max = 100
-
-class Cycles(CheckedInt):
-    cxx_type = 'Cycles'
-    size = 64
-    unsigned = True
-
-    def getValue(self):
-        from _m5.core import Cycles
-        return Cycles(self.value)
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        # Assume that base/str.hh will be included anyway
-        # code('#include "base/str.hh"')
-        pass
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('uint64_t _temp;')
-        code('bool _ret = to_number(%s, _temp);' % src)
-        code('if (_ret)')
-        code('    %s = Cycles(_temp);' % dest)
-        code('%s _ret;' % ret)
-
-class Float(ParamValue, float):
-    cxx_type = 'double'
-    cmd_line_settable = True
-
-    def __init__(self, value):
-        if isinstance(value, (int, long, float, NumericParamValue, Float, str)):
-            self.value = float(value)
-        else:
-            raise TypeError("Can't convert object of type %s to Float" \
-                  % type(value).__name__)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        return float(self.value)
-
-    def config_value(self):
-        return self
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s (std::istringstream(%s) >> %s).eof();' % (ret, src, dest))
-
-class MemorySize(CheckedInt):
-    cxx_type = 'uint64_t'
-    ex_str = '512MB'
-    size = 64
-    unsigned = True
-    def __init__(self, value):
-        if isinstance(value, MemorySize):
-            self.value = value.value
-        else:
-            self.value = convert.toMemorySize(value)
-        self._check()
-
-class MemorySize32(CheckedInt):
-    cxx_type = 'uint32_t'
-    ex_str = '512MB'
-    size = 32
-    unsigned = True
-    def __init__(self, value):
-        if isinstance(value, MemorySize):
-            self.value = value.value
-        else:
-            self.value = convert.toMemorySize(value)
-        self._check()
-
-class Addr(CheckedInt):
-    cxx_type = 'Addr'
-    size = 64
-    unsigned = True
-    def __init__(self, value):
-        if isinstance(value, Addr):
-            self.value = value.value
-        else:
-            try:
-                # Often addresses are referred to with sizes. Ex: A device
-                # base address is at "512MB".  Use toMemorySize() to convert
-                # these into addresses. If the address is not specified with a
-                # "size", an exception will occur and numeric translation will
-                # proceed below.
-                self.value = convert.toMemorySize(value)
-            except (TypeError, ValueError):
-                # Convert number to string and use long() to do automatic
-                # base conversion (requires base=0 for auto-conversion)
-                self.value = long(str(value), base=0)
-
-        self._check()
-    def __add__(self, other):
-        if isinstance(other, Addr):
-            return self.value + other.value
-        else:
-            return self.value + other
-    def pretty_print(self, value):
-        try:
-            val = convert.toMemorySize(value)
-        except TypeError:
-            val = long(value)
-        return "0x%x" % long(val)
-
-class AddrRange(ParamValue):
-    cxx_type = 'AddrRange'
-
-    def __init__(self, *args, **kwargs):
-        # Disable interleaving and hashing by default
-        self.intlvBits = 0
-        self.intlvMatch = 0
-        self.masks = []
-
-        def handle_kwargs(self, kwargs):
-            # An address range needs to have an upper limit, specified
-            # either explicitly with an end, or as an offset using the
-            # size keyword.
-            if 'end' in kwargs:
-                self.end = Addr(kwargs.pop('end'))
-            elif 'size' in kwargs:
-                self.end = self.start + Addr(kwargs.pop('size'))
-            else:
-                raise TypeError("Either end or size must be specified")
-
-            # Now on to the optional bit
-            if 'intlvMatch' in kwargs:
-                self.intlvMatch = int(kwargs.pop('intlvMatch'))
-
-            if 'masks' in kwargs:
-                self.masks = [ long(x) for x in list(kwargs.pop('masks')) ]
-                self.intlvBits = len(self.masks)
-            else:
-                if 'intlvBits' in kwargs:
-                    self.intlvBits = int(kwargs.pop('intlvBits'))
-                    self.masks = [0] * self.intlvBits
-                    if 'intlvHighBit' not in kwargs:
-                        raise TypeError("No interleave bits specified")
-                    intlv_high_bit = int(kwargs.pop('intlvHighBit'))
-                    xor_high_bit = 0
-                    if 'xorHighBit' in kwargs:
-                        xor_high_bit = int(kwargs.pop('xorHighBit'))
-                    for i in range(0, self.intlvBits):
-                        bit1 = intlv_high_bit - i
-                        mask = 1 << bit1
-                        if xor_high_bit != 0:
-                            bit2 = xor_high_bit - i
-                            mask |= 1 << bit2
-                        self.masks[self.intlvBits - i - 1] = mask
-
-        if len(args) == 0:
-            self.start = Addr(kwargs.pop('start'))
-            handle_kwargs(self, kwargs)
-
-        elif len(args) == 1:
-            if kwargs:
-                self.start = Addr(args[0])
-                handle_kwargs(self, kwargs)
-            elif isinstance(args[0], (list, tuple)):
-                self.start = Addr(args[0][0])
-                self.end = Addr(args[0][1])
-            else:
-                self.start = Addr(0)
-                self.end = Addr(args[0])
-
-        elif len(args) == 2:
-            self.start = Addr(args[0])
-            self.end = Addr(args[1])
-        else:
-            raise TypeError("Too many arguments specified")
-
-        if kwargs:
-            raise TypeError("Too many keywords: %s" % list(kwargs.keys()))
-
-    def __str__(self):
-        if len(self.masks) == 0:
-            return '%s:%s' % (self.start, self.end)
-        else:
-            return '%s:%s:%s:%s' % (self.start, self.end, self.intlvMatch,
-                                    ':'.join(str(m) for m in self.masks))
-
-    def size(self):
-        # Divide the size by the size of the interleaving slice
-        return (long(self.end) - long(self.start)) >> self.intlvBits
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        Addr.cxx_predecls(code)
-        code('#include "base/addr_range.hh"')
-
-    @classmethod
-    def pybind_predecls(cls, code):
-        Addr.pybind_predecls(code)
-        code('#include "base/addr_range.hh"')
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-        code('#include <vector>')
-        code('#include "base/types.hh"')
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('bool _ret = true;')
-        code('uint64_t _start, _end, _intlvMatch = 0;')
-        code('std::vector<Addr> _masks;')
-        code('char _sep;')
-        code('std::istringstream _stream(${src});')
-        code('_stream >> _start;')
-        code('_stream.get(_sep);')
-        code('_ret = _sep == \':\';')
-        code('_stream >> _end;')
-        code('if (!_stream.fail() && !_stream.eof()) {')
-        code('    _stream.get(_sep);')
-        code('    _ret = ret && _sep == \':\';')
-        code('    _stream >> _intlvMatch;')
-        code('    while (!_stream.fail() && !_stream.eof()) {')
-        code('        _stream.get(_sep);')
-        code('        _ret = ret && _sep == \':\';')
-        code('        Addr mask;')
-        code('        _stream >> mask;')
-        code('        _masks.push_back(mask);')
-        code('    }')
-        code('}')
-        code('_ret = _ret && !_stream.fail() && _stream.eof();')
-        code('if (_ret)')
-        code('   ${dest} = AddrRange(_start, _end, _masks, _intlvMatch);')
-        code('${ret} _ret;')
-
-    def getValue(self):
-        # Go from the Python class to the wrapped C++ class
-        from _m5.range import AddrRange
-
-        return AddrRange(long(self.start), long(self.end),
-                         self.masks, int(self.intlvMatch))
-
-# Boolean parameter type.  Python doesn't let you subclass bool, since
-# it doesn't want to let you create multiple instances of True and
-# False.  Thus this is a little more complicated than String.
-class Bool(ParamValue):
-    cxx_type = 'bool'
-    cmd_line_settable = True
-
-    def __init__(self, value):
-        try:
-            self.value = convert.toBool(value)
-        except TypeError:
-            self.value = bool(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        return bool(self.value)
-
-    def __str__(self):
-        return str(self.value)
-
-    # implement truth value testing for Bool parameters so that these params
-    # evaluate correctly during the python configuration phase
-    def __bool__(self):
-        return bool(self.value)
-
-    # Python 2.7 uses __nonzero__ instead of __bool__
-    __nonzero__ = __bool__
-
-    def ini_str(self):
-        if self.value:
-            return 'true'
-        return 'false'
-
-    def config_value(self):
-        return self.value
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        # Assume that base/str.hh will be included anyway
-        # code('#include "base/str.hh"')
-        pass
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('%s to_bool(%s, %s);' % (ret, src, dest))
-
-def IncEthernetAddr(addr, val = 1):
-    bytes = [ int(x, 16) for x in addr.split(':') ]
-    bytes[5] += val
-    for i in (5, 4, 3, 2, 1):
-        val,rem = divmod(bytes[i], 256)
-        bytes[i] = rem
-        if val == 0:
-            break
-        bytes[i - 1] += val
-    assert(bytes[0] <= 255)
-    return ':'.join(map(lambda x: '%02x' % x, bytes))
-
-_NextEthernetAddr = "00:90:00:00:00:01"
-def NextEthernetAddr():
-    global _NextEthernetAddr
-
-    value = _NextEthernetAddr
-    _NextEthernetAddr = IncEthernetAddr(_NextEthernetAddr, 1)
-    return value
-
-class EthernetAddr(ParamValue):
-    cxx_type = 'Net::EthAddr'
-    ex_str = "00:90:00:00:00:01"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, value):
-        if value == NextEthernetAddr:
-            self.value = value
-            return
-
-        if not isinstance(value, str):
-            raise TypeError("expected an ethernet address and didn't get one")
-
-        bytes = value.split(':')
-        if len(bytes) != 6:
-            raise TypeError('invalid ethernet address %s' % value)
-
-        for byte in bytes:
-            if not 0 <= int(byte, base=16) <= 0xff:
-                raise TypeError('invalid ethernet address %s' % value)
-
-        self.value = value
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def unproxy(self, base):
-        if self.value == NextEthernetAddr:
-            return EthernetAddr(self.value())
-        return self
-
-    def getValue(self):
-        from _m5.net import EthAddr
-        return EthAddr(self.value)
-
-    def __str__(self):
-        return self.value
-
-    def ini_str(self):
-        return self.value
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s = Net::EthAddr(%s);' % (dest, src))
-        code('%s true;' % ret)
-
-# When initializing an IpAddress, pass in an existing IpAddress, a string of
-# the form "a.b.c.d", or an integer representing an IP.
-class IpAddress(ParamValue):
-    cxx_type = 'Net::IpAddress'
-    ex_str = "127.0.0.1"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, value):
-        if isinstance(value, IpAddress):
-            self.ip = value.ip
-        else:
-            try:
-                self.ip = convert.toIpAddress(value)
-            except TypeError:
-                self.ip = long(value)
-        self.verifyIp()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        tup = [(self.ip >> i)  & 0xff for i in (24, 16, 8, 0)]
-        return '%d.%d.%d.%d' % tuple(tup)
-
-    def __eq__(self, other):
-        if isinstance(other, IpAddress):
-            return self.ip == other.ip
-        elif isinstance(other, str):
-            try:
-                return self.ip == convert.toIpAddress(other)
-            except:
-                return False
-        else:
-            return self.ip == other
-
-    def __ne__(self, other):
-        return not (self == other)
-
-    def verifyIp(self):
-        if self.ip < 0 or self.ip >= (1 << 32):
-            raise TypeError("invalid ip address %#08x" % self.ip)
-
-    def getValue(self):
-        from _m5.net import IpAddress
-        return IpAddress(self.ip)
-
-# When initializing an IpNetmask, pass in an existing IpNetmask, a string of
-# the form "a.b.c.d/n" or "a.b.c.d/e.f.g.h", or an ip and netmask as
-# positional or keyword arguments.
-class IpNetmask(IpAddress):
-    cxx_type = 'Net::IpNetmask'
-    ex_str = "127.0.0.0/24"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, *args, **kwargs):
-        def handle_kwarg(self, kwargs, key, elseVal = None):
-            if key in kwargs:
-                setattr(self, key, kwargs.pop(key))
-            elif elseVal:
-                setattr(self, key, elseVal)
-            else:
-                raise TypeError("No value set for %s" % key)
-
-        if len(args) == 0:
-            handle_kwarg(self, kwargs, 'ip')
-            handle_kwarg(self, kwargs, 'netmask')
-
-        elif len(args) == 1:
-            if kwargs:
-                if not 'ip' in kwargs and not 'netmask' in kwargs:
-                    raise TypeError("Invalid arguments")
-                handle_kwarg(self, kwargs, 'ip', args[0])
-                handle_kwarg(self, kwargs, 'netmask', args[0])
-            elif isinstance(args[0], IpNetmask):
-                self.ip = args[0].ip
-                self.netmask = args[0].netmask
-            else:
-                (self.ip, self.netmask) = convert.toIpNetmask(args[0])
-
-        elif len(args) == 2:
-            self.ip = args[0]
-            self.netmask = args[1]
-        else:
-            raise TypeError("Too many arguments specified")
-
-        if kwargs:
-            raise TypeError("Too many keywords: %s" % list(kwargs.keys()))
-
-        self.verify()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        return "%s/%d" % (super(IpNetmask, self).__str__(), self.netmask)
-
-    def __eq__(self, other):
-        if isinstance(other, IpNetmask):
-            return self.ip == other.ip and self.netmask == other.netmask
-        elif isinstance(other, str):
-            try:
-                return (self.ip, self.netmask) == convert.toIpNetmask(other)
-            except:
-                return False
-        else:
-            return False
-
-    def verify(self):
-        self.verifyIp()
-        if self.netmask < 0 or self.netmask > 32:
-            raise TypeError("invalid netmask %d" % netmask)
-
-    def getValue(self):
-        from _m5.net import IpNetmask
-        return IpNetmask(self.ip, self.netmask)
-
-# When initializing an IpWithPort, pass in an existing IpWithPort, a string of
-# the form "a.b.c.d:p", or an ip and port as positional or keyword arguments.
-class IpWithPort(IpAddress):
-    cxx_type = 'Net::IpWithPort'
-    ex_str = "127.0.0.1:80"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, *args, **kwargs):
-        def handle_kwarg(self, kwargs, key, elseVal = None):
-            if key in kwargs:
-                setattr(self, key, kwargs.pop(key))
-            elif elseVal:
-                setattr(self, key, elseVal)
-            else:
-                raise TypeError("No value set for %s" % key)
-
-        if len(args) == 0:
-            handle_kwarg(self, kwargs, 'ip')
-            handle_kwarg(self, kwargs, 'port')
-
-        elif len(args) == 1:
-            if kwargs:
-                if not 'ip' in kwargs and not 'port' in kwargs:
-                    raise TypeError("Invalid arguments")
-                handle_kwarg(self, kwargs, 'ip', args[0])
-                handle_kwarg(self, kwargs, 'port', args[0])
-            elif isinstance(args[0], IpWithPort):
-                self.ip = args[0].ip
-                self.port = args[0].port
-            else:
-                (self.ip, self.port) = convert.toIpWithPort(args[0])
-
-        elif len(args) == 2:
-            self.ip = args[0]
-            self.port = args[1]
-        else:
-            raise TypeError("Too many arguments specified")
-
-        if kwargs:
-            raise TypeError("Too many keywords: %s" % list(kwargs.keys()))
-
-        self.verify()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        return "%s:%d" % (super(IpWithPort, self).__str__(), self.port)
-
-    def __eq__(self, other):
-        if isinstance(other, IpWithPort):
-            return self.ip == other.ip and self.port == other.port
-        elif isinstance(other, str):
-            try:
-                return (self.ip, self.port) == convert.toIpWithPort(other)
-            except:
-                return False
-        else:
-            return False
-
-    def verify(self):
-        self.verifyIp()
-        if self.port < 0 or self.port > 0xffff:
-            raise TypeError("invalid port %d" % self.port)
-
-    def getValue(self):
-        from _m5.net import IpWithPort
-        return IpWithPort(self.ip, self.port)
-
-time_formats = [ "%a %b %d %H:%M:%S %Z %Y",
-                 "%a %b %d %H:%M:%S %Y",
-                 "%Y/%m/%d %H:%M:%S",
-                 "%Y/%m/%d %H:%M",
-                 "%Y/%m/%d",
-                 "%m/%d/%Y %H:%M:%S",
-                 "%m/%d/%Y %H:%M",
-                 "%m/%d/%Y",
-                 "%m/%d/%y %H:%M:%S",
-                 "%m/%d/%y %H:%M",
-                 "%m/%d/%y"]
-
-
-def parse_time(value):
-    from time import gmtime, strptime, struct_time, time
-    from datetime import datetime, date
-
-    if isinstance(value, struct_time):
-        return value
-
-    if isinstance(value, (int, long)):
-        return gmtime(value)
-
-    if isinstance(value, (datetime, date)):
-        return value.timetuple()
-
-    if isinstance(value, str):
-        if value in ('Now', 'Today'):
-            return time.gmtime(time.time())
-
-        for format in time_formats:
-            try:
-                return strptime(value, format)
-            except ValueError:
-                pass
-
-    raise ValueError("Could not parse '%s' as a time" % value)
-
-class Time(ParamValue):
-    cxx_type = 'tm'
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include <time.h>')
-
-    def __init__(self, value):
-        self.value = parse_time(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        from _m5.core import tm
-        import calendar
-
-        return tm.gmtime(calendar.timegm(self.value))
-
-    def __str__(self):
-        return time.asctime(self.value)
-
-    def ini_str(self):
-        return str(self)
-
-    def get_config_as_dict(self):
-        assert false
-        return str(self)
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <time.h>')
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('char *_parse_ret = strptime((${src}).c_str(),')
-        code('    "%a %b %d %H:%M:%S %Y", &(${dest}));')
-        code('${ret} _parse_ret && *_parse_ret == \'\\0\';');
-
-# Enumerated types are a little more complex.  The user specifies the
-# type as Enum(foo) where foo is either a list or dictionary of
-# alternatives (typically strings, but not necessarily so).  (In the
-# long run, the integer value of the parameter will be the list index
-# or the corresponding dictionary value.  For now, since we only check
-# that the alternative is valid and then spit it into a .ini file,
-# there's not much point in using the dictionary.)
-
-# What Enum() must do is generate a new type encapsulating the
-# provided list/dictionary so that specific values of the parameter
-# can be instances of that type.  We define two hidden internal
-# classes (_ListEnum and _DictEnum) to serve as base classes, then
-# derive the new type from the appropriate base class on the fly.
-
-allEnums = {}
-# Metaclass for Enum types
-class MetaEnum(MetaParamValue):
-    def __new__(mcls, name, bases, dict):
-
-        cls = super(MetaEnum, mcls).__new__(mcls, name, bases, dict)
-        allEnums[name] = cls
-        return cls
-
-    def __init__(cls, name, bases, init_dict):
-        if 'map' in init_dict:
-            if not isinstance(cls.map, dict):
-                raise TypeError("Enum-derived class attribute 'map' " \
-                      "must be of type dict")
-            # build list of value strings from map
-            cls.vals = list(cls.map.keys())
-            cls.vals.sort()
-        elif 'vals' in init_dict:
-            if not isinstance(cls.vals, list):
-                raise TypeError("Enum-derived class attribute 'vals' " \
-                      "must be of type list")
-            # build string->value map from vals sequence
-            cls.map = {}
-            for idx,val in enumerate(cls.vals):
-                cls.map[val] = idx
-        else:
-            raise TypeError("Enum-derived class must define "\
-                  "attribute 'map' or 'vals'")
-
-        if cls.is_class:
-            cls.cxx_type = '%s' % name
-        else:
-            cls.cxx_type = 'Enums::%s' % name
-
-        super(MetaEnum, cls).__init__(name, bases, init_dict)
-
-    # Generate C++ class declaration for this enum type.
-    # Note that we wrap the enum in a class/struct to act as a namespace,
-    # so that the enum strings can be brief w/o worrying about collisions.
-    def cxx_decl(cls, code):
-        wrapper_name = cls.wrapper_name
-        wrapper = 'struct' if cls.wrapper_is_struct else 'namespace'
-        name = cls.__name__ if cls.enum_name is None else cls.enum_name
-        idem_macro = '__ENUM__%s__%s__' % (wrapper_name, name)
-
-        code('''\
-#ifndef $idem_macro
-#define $idem_macro
-
-''')
-        if cls.is_class:
-            code('''\
-enum class $name {
-''')
-        else:
-            code('''\
-$wrapper $wrapper_name {
-    enum $name {
-''')
-            code.indent(1)
-        code.indent(1)
-        for val in cls.vals:
-            code('$val = ${{cls.map[val]}},')
-        code('Num_$name = ${{len(cls.vals)}}')
-        code.dedent(1)
-        code('};')
-
-        if cls.is_class:
-            code('''\
-extern const char *${name}Strings[static_cast<int>(${name}::Num_${name})];
-''')
-        elif cls.wrapper_is_struct:
-            code('static const char *${name}Strings[Num_${name}];')
-        else:
-            code('extern const char *${name}Strings[Num_${name}];')
-
-        if not cls.is_class:
-            code.dedent(1)
-            code('};')
-
-        code()
-        code('#endif // $idem_macro')
-
-    def cxx_def(cls, code):
-        wrapper_name = cls.wrapper_name
-        file_name = cls.__name__
-        name = cls.__name__ if cls.enum_name is None else cls.enum_name
-
-        code('#include "enums/$file_name.hh"')
-        if cls.wrapper_is_struct:
-            code('const char *${wrapper_name}::${name}Strings'
-                '[Num_${name}] =')
-        else:
-            if cls.is_class:
-                code('''\
-const char *${name}Strings[static_cast<int>(${name}::Num_${name})] =
-''')
-            else:
-                code('namespace Enums {')
-                code.indent(1)
-                code('const char *${name}Strings[Num_${name}] =')
-
-        code('{')
-        code.indent(1)
-        for val in cls.vals:
-            code('"$val",')
-        code.dedent(1)
-        code('};')
-
-        if not cls.wrapper_is_struct and not cls.is_class:
-            code.dedent(1)
-            code('} // namespace $wrapper_name')
-
-
-    def pybind_def(cls, code):
-        name = cls.__name__
-        enum_name = cls.__name__ if cls.enum_name is None else cls.enum_name
-        wrapper_name = enum_name if cls.is_class else cls.wrapper_name
-
-        code('''#include "pybind11/pybind11.h"
-#include "pybind11/stl.h"
-
-#include <sim/init.hh>
-
-namespace py = pybind11;
-
-static void
-module_init(py::module &m_internal)
-{
-    py::module m = m_internal.def_submodule("enum_${name}");
-
-''')
-        if cls.is_class:
-            code('py::enum_<${enum_name}>(m, "enum_${name}")')
-        else:
-            code('py::enum_<${wrapper_name}::${enum_name}>(m, "enum_${name}")')
-
-        code.indent()
-        code.indent()
-        for val in cls.vals:
-            code('.value("${val}", ${wrapper_name}::${val})')
-        code('.value("Num_${name}", ${wrapper_name}::Num_${enum_name})')
-        if not cls.is_class:
-            code('.export_values()')
-        code(';')
-        code.dedent()
-
-        code('}')
-        code.dedent()
-        code()
-        code('static EmbeddedPyBind embed_enum("enum_${name}", module_init);')
-
-
-# Base class for enum types.
-class Enum(with_metaclass(MetaEnum, ParamValue)):
-    vals = []
-    cmd_line_settable = True
-
-    # The name of the wrapping namespace or struct
-    wrapper_name = 'Enums'
-
-    # If true, the enum is wrapped in a struct rather than a namespace
-    wrapper_is_struct = False
-
-    is_class = False
-
-    # If not None, use this as the enum name rather than this class name
-    enum_name = None
-
-    def __init__(self, value):
-        if value not in self.map:
-            raise TypeError("Enum param got bad value '%s' (not in %s)" \
-                  % (value, self.vals))
-        self.value = value
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "enums/$0.hh"', cls.__name__)
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('if (false) {')
-        for elem_name in cls.map.keys():
-            code('} else if (%s == "%s") {' % (src, elem_name))
-            code.indent()
-            name = cls.__name__ if cls.enum_name is None else cls.enum_name
-            code('%s = %s::%s;' % (dest, name if cls.is_class else 'Enums',
-                                   elem_name))
-            code('%s true;' % ret)
-            code.dedent()
-        code('} else {')
-        code('    %s false;' % ret)
-        code('}')
-
-    def getValue(self):
-        import m5.internal.params
-        e = getattr(m5.internal.params, "enum_%s" % self.__class__.__name__)
-        return e(self.map[self.value])
-
-    def __str__(self):
-        return self.value
-
-# This param will generate a scoped c++ enum and its python bindings.
-class ScopedEnum(Enum):
-    vals = []
-    cmd_line_settable = True
-
-    # The name of the wrapping namespace or struct
-    wrapper_name = None
-
-    # If true, the enum is wrapped in a struct rather than a namespace
-    wrapper_is_struct = False
-
-    # If true, the generated enum is a scoped enum
-    is_class = True
-
-    # If not None, use this as the enum name rather than this class name
-    enum_name = None
-
-class ByteOrder(ScopedEnum):
-    """Enum representing component's byte order (endianness)"""
-
-    vals = [
-        'big',
-        'little',
-    ]
-
-# how big does a rounding error need to be before we warn about it?
-frequency_tolerance = 0.001  # 0.1%
-
-class TickParamValue(NumericParamValue):
-    cxx_type = 'Tick'
-    ex_str = "1MHz"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/types.hh"')
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        return long(self.value)
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    # Ticks are expressed in seconds in JSON files and in plain
-    # Ticks in .ini files.  Switch based on a config flag
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('${ret} to_number(${src}, ${dest});')
-
-class Latency(TickParamValue):
-    ex_str = "100ns"
-
-    def __init__(self, value):
-        if isinstance(value, (Latency, Clock)):
-            self.ticks = value.ticks
-            self.value = value.value
-        elif isinstance(value, Frequency):
-            self.ticks = value.ticks
-            self.value = 1.0 / value.value
-        elif value.endswith('t'):
-            self.ticks = True
-            self.value = int(value[:-1])
-        else:
-            self.ticks = False
-            self.value = convert.toLatency(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __getattr__(self, attr):
-        if attr in ('latency', 'period'):
-            return self
-        if attr == 'frequency':
-            return Frequency(self)
-        raise AttributeError("Latency object has no attribute '%s'" % attr)
-
-    def getValue(self):
-        if self.ticks or self.value == 0:
-            value = self.value
-        else:
-            value = ticks.fromSeconds(self.value)
-        return long(value)
-
-    def config_value(self):
-        return self.getValue()
-
-    # convert latency to ticks
-    def ini_str(self):
-        return '%d' % self.getValue()
-
-class Frequency(TickParamValue):
-    ex_str = "1GHz"
-
-    def __init__(self, value):
-        if isinstance(value, (Latency, Clock)):
-            if value.value == 0:
-                self.value = 0
-            else:
-                self.value = 1.0 / value.value
-            self.ticks = value.ticks
-        elif isinstance(value, Frequency):
-            self.value = value.value
-            self.ticks = value.ticks
-        else:
-            self.ticks = False
-            self.value = convert.toFrequency(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __getattr__(self, attr):
-        if attr == 'frequency':
-            return self
-        if attr in ('latency', 'period'):
-            return Latency(self)
-        raise AttributeError("Frequency object has no attribute '%s'" % attr)
-
-    # convert latency to ticks
-    def getValue(self):
-        if self.ticks or self.value == 0:
-            value = self.value
-        else:
-            value = ticks.fromSeconds(1.0 / self.value)
-        return long(value)
-
-    def config_value(self):
-        return self.getValue()
-
-    def ini_str(self):
-        return '%d' % self.getValue()
-
-# A generic Frequency and/or Latency value. Value is stored as a
-# latency, just like Latency and Frequency.
-class Clock(TickParamValue):
-    def __init__(self, value):
-        if isinstance(value, (Latency, Clock)):
-            self.ticks = value.ticks
-            self.value = value.value
-        elif isinstance(value, Frequency):
-            self.ticks = value.ticks
-            self.value = 1.0 / value.value
-        elif value.endswith('t'):
-            self.ticks = True
-            self.value = int(value[:-1])
-        else:
-            self.ticks = False
-            self.value = convert.anyToLatency(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        return "%s" % Latency(self)
-
-    def __getattr__(self, attr):
-        if attr == 'frequency':
-            return Frequency(self)
-        if attr in ('latency', 'period'):
-            return Latency(self)
-        raise AttributeError("Frequency object has no attribute '%s'" % attr)
-
-    def getValue(self):
-        return self.period.getValue()
-
-    def config_value(self):
-        return self.period.config_value()
-
-    def ini_str(self):
-        return self.period.ini_str()
-
-class Voltage(Float):
-    ex_str = "1V"
-
-    def __new__(cls, value):
-        value = convert.toVoltage(value)
-        return super(cls, Voltage).__new__(cls, value)
-
-    def __init__(self, value):
-        value = convert.toVoltage(value)
-        super(Voltage, self).__init__(value)
-
-class Current(Float):
-    ex_str = "1mA"
-
-    def __new__(cls, value):
-        value = convert.toCurrent(value)
-        return super(cls, Current).__new__(cls, value)
-
-    def __init__(self, value):
-        value = convert.toCurrent(value)
-        super(Current, self).__init__(value)
-
-class Energy(Float):
-    ex_str = "1pJ"
-
-    def __new__(cls, value):
-        value = convert.toEnergy(value)
-        return super(cls, Energy).__new__(cls, value)
-
-    def __init__(self, value):
-        value = convert.toEnergy(value)
-        super(Energy, self).__init__(value)
-
-class NetworkBandwidth(float,ParamValue):
-    cxx_type = 'float'
-    ex_str = "1Gbps"
-    cmd_line_settable = True
-
-    def __new__(cls, value):
-        # convert to bits per second
-        val = convert.toNetworkBandwidth(value)
-        return super(cls, NetworkBandwidth).__new__(cls, val)
-
-    def __str__(self):
-        return str(self.val)
-
-    def __call__(self, value):
-        val = convert.toNetworkBandwidth(value)
-        self.__init__(val)
-        return value
-
-    def getValue(self):
-        # convert to seconds per byte
-        value = 8.0 / float(self)
-        # convert to ticks per byte
-        value = ticks.fromSeconds(value)
-        return float(value)
-
-    def ini_str(self):
-        return '%f' % self.getValue()
-
-    def config_value(self):
-        return '%f' % self.getValue()
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s (std::istringstream(%s) >> %s).eof();' % (ret, src, dest))
-
-class MemoryBandwidth(float,ParamValue):
-    cxx_type = 'float'
-    ex_str = "1GB/s"
-    cmd_line_settable = True
-
-    def __new__(cls, value):
-        # convert to bytes per second
-        val = convert.toMemoryBandwidth(value)
-        return super(cls, MemoryBandwidth).__new__(cls, val)
-
-    def __call__(self, value):
-        val = convert.toMemoryBandwidth(value)
-        self.__init__(val)
-        return value
-
-    def getValue(self):
-        # convert to seconds per byte
-        value = float(self)
-        if value:
-            value = 1.0 / float(self)
-        # convert to ticks per byte
-        value = ticks.fromSeconds(value)
-        return float(value)
-
-    def ini_str(self):
-        return '%f' % self.getValue()
-
-    def config_value(self):
-        return '%f' % self.getValue()
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s (std::istringstream(%s) >> %s).eof();' % (ret, src, dest))
-
-#
-# "Constants"... handy aliases for various values.
-#
-
-# Special class for NULL pointers.  Note the special check in
-# make_param_value() above that lets these be assigned where a
-# SimObject is required.
-# only one copy of a particular node
-class NullSimObject(with_metaclass(Singleton, object)):
-    _name = 'Null'
-
-    def __call__(cls):
-        return cls
-
-    def _instantiate(self, parent = None, path = ''):
-        pass
-
-    def ini_str(self):
-        return 'Null'
-
-    def unproxy(self, base):
-        return self
-
-    def set_path(self, parent, name):
-        pass
-
-    def set_parent(self, parent, name):
-        pass
-
-    def clear_parent(self, old_parent):
-        pass
-
-    def descendants(self):
-        return
-        yield None
-
-    def get_config_as_dict(self):
-        return {}
-
-    def __str__(self):
-        return self._name
-
-    def config_value(self):
-        return None
-
-    def getValue(self):
-        return None
-
-# The only instance you'll ever need...
-NULL = NullSimObject()
-
-def isNullPointer(value):
-    return isinstance(value, NullSimObject)
-
-# Some memory range specifications use this as a default upper bound.
-MaxAddr = Addr.max
-MaxTick = Tick.max
-AllMemory = AddrRange(0, MaxAddr)
-
-
-#####################################################################
-#
-# Port objects
-#
-# Ports are used to interconnect objects in the memory system.
-#
-#####################################################################
-
-# Port reference: encapsulates a reference to a particular port on a
-# particular SimObject.
-class PortRef(object):
-    def __init__(self, simobj, name, role, is_source):
-        assert(isSimObject(simobj) or isSimObjectClass(simobj))
-        self.simobj = simobj
-        self.name = name
-        self.role = role
-        self.is_source = is_source
-        self.peer = None   # not associated with another port yet
-        self.ccConnected = False # C++ port connection done?
-        self.index = -1  # always -1 for non-vector ports
-
-    def __str__(self):
-        return '%s.%s' % (self.simobj, self.name)
-
-    def __len__(self):
-        # Return the number of connected ports, i.e. 0 is we have no
-        # peer and 1 if we do.
-        return int(self.peer != None)
-
-    # for config.ini, print peer's name (not ours)
-    def ini_str(self):
-        return str(self.peer)
-
-    # for config.json
-    def get_config_as_dict(self):
-        return {'role' : self.role, 'peer' : str(self.peer),
-                'is_source' : str(self.is_source)}
-
-    def __getattr__(self, attr):
-        if attr == 'peerObj':
-            # shorthand for proxies
-            return self.peer.simobj
-        raise AttributeError("'%s' object has no attribute '%s'" % \
-              (self.__class__.__name__, attr))
-
-    # Full connection is symmetric (both ways).  Called via
-    # SimObject.__setattr__ as a result of a port assignment, e.g.,
-    # "obj1.portA = obj2.portB", or via VectorPortElementRef.__setitem__,
-    # e.g., "obj1.portA[3] = obj2.portB".
-    def connect(self, other):
-        if isinstance(other, VectorPortRef):
-            # reference to plain VectorPort is implicit append
-            other = other._get_next()
-        if self.peer and not proxy.isproxy(self.peer):
-            fatal("Port %s is already connected to %s, cannot connect %s\n",
-                  self, self.peer, other);
-        self.peer = other
-
-        if proxy.isproxy(other):
-            other.set_param_desc(PortParamDesc())
-            return
-        elif not isinstance(other, PortRef):
-            raise TypeError("assigning non-port reference '%s' to port '%s'" \
-                  % (other, self))
-
-        if not Port.is_compat(self, other):
-            fatal("Ports %s and %s with roles '%s' and '%s' "
-                    "are not compatible", self, other, self.role, other.role)
-
-        if other.peer is not self:
-            other.connect(self)
-
-    # Allow a compatible port pair to be spliced between a port and its
-    # connected peer. Useful operation for connecting instrumentation
-    # structures into a system when it is necessary to connect the
-    # instrumentation after the full system has been constructed.
-    def splice(self, new_1, new_2):
-        if not self.peer or proxy.isproxy(self.peer):
-            fatal("Port %s not connected, cannot splice in new peers\n", self)
-
-        if not isinstance(new_1, PortRef) or not isinstance(new_2, PortRef):
-            raise TypeError(
-                  "Splicing non-port references '%s','%s' to port '%s'" % \
-                  (new_1, new_2, self))
-
-        old_peer = self.peer
-
-        if Port.is_compat(old_peer, new_1) and Port.is_compat(self, new_2):
-            old_peer.peer = new_1
-            new_1.peer = old_peer
-            self.peer = new_2
-            new_2.peer = self
-        elif Port.is_compat(old_peer, new_2) and Port.is_compat(self, new_1):
-            old_peer.peer = new_2
-            new_2.peer = old_peer
-            self.peer = new_1
-            new_1.peer = self
-        else:
-            fatal("Ports %s(%s) and %s(%s) can't be compatibly spliced with "
-                    "%s(%s) and %s(%s)", self, self.role,
-                    old_peer, old_peer.role, new_1, new_1.role,
-                    new_2, new_2.role)
-
-    def clone(self, simobj, memo):
-        if self in memo:
-            return memo[self]
-        newRef = copy.copy(self)
-        memo[self] = newRef
-        newRef.simobj = simobj
-        assert(isSimObject(newRef.simobj))
-        if self.peer and not proxy.isproxy(self.peer):
-            peerObj = self.peer.simobj(_memo=memo)
-            newRef.peer = self.peer.clone(peerObj, memo)
-            assert(not isinstance(newRef.peer, VectorPortRef))
-        return newRef
-
-    def unproxy(self, simobj):
-        assert(simobj is self.simobj)
-        if proxy.isproxy(self.peer):
-            try:
-                realPeer = self.peer.unproxy(self.simobj)
-            except:
-                print("Error in unproxying port '%s' of %s" %
-                      (self.name, self.simobj.path()))
-                raise
-            self.connect(realPeer)
-
-    # Call C++ to create corresponding port connection between C++ objects
-    def ccConnect(self):
-        if self.ccConnected: # already done this
-            return
-
-        peer = self.peer
-        if not self.peer: # nothing to connect to
-            return
-
-        port = self.simobj.getPort(self.name, self.index)
-        peer_port = peer.simobj.getPort(peer.name, peer.index)
-        port.bind(peer_port)
-
-        self.ccConnected = True
-
-# A reference to an individual element of a VectorPort... much like a
-# PortRef, but has an index.
-class VectorPortElementRef(PortRef):
-    def __init__(self, simobj, name, role, is_source, index):
-        PortRef.__init__(self, simobj, name, role, is_source)
-        self.index = index
-
-    def __str__(self):
-        return '%s.%s[%d]' % (self.simobj, self.name, self.index)
-
-# A reference to a complete vector-valued port (not just a single element).
-# Can be indexed to retrieve individual VectorPortElementRef instances.
-class VectorPortRef(object):
-    def __init__(self, simobj, name, role, is_source):
-        assert(isSimObject(simobj) or isSimObjectClass(simobj))
-        self.simobj = simobj
-        self.name = name
-        self.role = role
-        self.is_source = is_source
-        self.elements = []
-
-    def __str__(self):
-        return '%s.%s[:]' % (self.simobj, self.name)
-
-    def __len__(self):
-        # Return the number of connected peers, corresponding the the
-        # length of the elements.
-        return len(self.elements)
-
-    # for config.ini, print peer's name (not ours)
-    def ini_str(self):
-        return ' '.join([el.ini_str() for el in self.elements])
-
-    # for config.json
-    def get_config_as_dict(self):
-        return {'role' : self.role,
-                'peer' : [el.ini_str() for el in self.elements],
-                'is_source' : str(self.is_source)}
-
-    def __getitem__(self, key):
-        if not isinstance(key, int):
-            raise TypeError("VectorPort index must be integer")
-        if key >= len(self.elements):
-            # need to extend list
-            ext = [VectorPortElementRef(
-                    self.simobj, self.name, self.role, self.is_source, i)
-                   for i in range(len(self.elements), key+1)]
-            self.elements.extend(ext)
-        return self.elements[key]
-
-    def _get_next(self):
-        return self[len(self.elements)]
-
-    def __setitem__(self, key, value):
-        if not isinstance(key, int):
-            raise TypeError("VectorPort index must be integer")
-        self[key].connect(value)
-
-    def connect(self, other):
-        if isinstance(other, (list, tuple)):
-            # Assign list of port refs to vector port.
-            # For now, append them... not sure if that's the right semantics
-            # or if it should replace the current vector.
-            for ref in other:
-                self._get_next().connect(ref)
-        else:
-            # scalar assignment to plain VectorPort is implicit append
-            self._get_next().connect(other)
-
-    def clone(self, simobj, memo):
-        if self in memo:
-            return memo[self]
-        newRef = copy.copy(self)
-        memo[self] = newRef
-        newRef.simobj = simobj
-        assert(isSimObject(newRef.simobj))
-        newRef.elements = [el.clone(simobj, memo) for el in self.elements]
-        return newRef
-
-    def unproxy(self, simobj):
-        [el.unproxy(simobj) for el in self.elements]
-
-    def ccConnect(self):
-        [el.ccConnect() for el in self.elements]
-
-# Port description object.  Like a ParamDesc object, this represents a
-# logical port in the SimObject class, not a particular port on a
-# SimObject instance.  The latter are represented by PortRef objects.
-class Port(object):
-    # Port("role", "description")
-
-    _compat_dict = { }
-
-    @classmethod
-    def compat(cls, role, peer):
-        cls._compat_dict.setdefault(role, set()).add(peer)
-        cls._compat_dict.setdefault(peer, set()).add(role)
-
-    @classmethod
-    def is_compat(cls, one, two):
-        for port in one, two:
-            if not port.role in Port._compat_dict:
-                fatal("Unrecognized role '%s' for port %s\n", port.role, port)
-        return one.role in Port._compat_dict[two.role]
-
-    def __init__(self, role, desc, is_source=False):
-        self.desc = desc
-        self.role = role
-        self.is_source = is_source
-
-    # Generate a PortRef for this port on the given SimObject with the
-    # given name
-    def makeRef(self, simobj):
-        return PortRef(simobj, self.name, self.role, self.is_source)
-
-    # Connect an instance of this port (on the given SimObject with
-    # the given name) with the port described by the supplied PortRef
-    def connect(self, simobj, ref):
-        self.makeRef(simobj).connect(ref)
-
-    # No need for any pre-declarations at the moment as we merely rely
-    # on an unsigned int.
-    def cxx_predecls(self, code):
-        pass
-
-    def pybind_predecls(self, code):
-        cls.cxx_predecls(self, code)
-
-    # Declare an unsigned int with the same name as the port, that
-    # will eventually hold the number of connected ports (and thus the
-    # number of elements for a VectorPort).
-    def cxx_decl(self, code):
-        code('unsigned int port_${{self.name}}_connection_count;')
-
-Port.compat('GEM5 REQUESTOR', 'GEM5 RESPONDER')
-
-class RequestPort(Port):
-    # RequestPort("description")
-    def __init__(self, desc):
-        super(RequestPort, self).__init__(
-                'GEM5 REQUESTOR', desc, is_source=True)
-
-class ResponsePort(Port):
-    # ResponsePort("description")
-    def __init__(self, desc):
-        super(ResponsePort, self).__init__('GEM5 RESPONDER', desc)
-
-# VectorPort description object.  Like Port, but represents a vector
-# of connections (e.g., as on a XBar).
-class VectorPort(Port):
-    def makeRef(self, simobj):
-        return VectorPortRef(simobj, self.name, self.role, self.is_source)
-
-class VectorRequestPort(VectorPort):
-    # VectorRequestPort("description")
-    def __init__(self, desc):
-        super(VectorRequestPort, self).__init__(
-                'GEM5 REQUESTOR', desc, is_source=True)
-
-class VectorResponsePort(VectorPort):
-    # VectorResponsePort("description")
-    def __init__(self, desc):
-        super(VectorResponsePort, self).__init__('GEM5 RESPONDER', desc)
-
-# Old names, maintained for compatibility.
-MasterPort = RequestPort
-SlavePort = ResponsePort
-VectorMasterPort = VectorRequestPort
-VectorSlavePort = VectorResponsePort
-
-# 'Fake' ParamDesc for Port references to assign to the _pdesc slot of
-# proxy objects (via set_param_desc()) so that proxy error messages
-# make sense.
-class PortParamDesc(with_metaclass(Singleton, object)):
-    ptype_str = 'Port'
-    ptype = Port
-
-class DeprecatedParam(object):
-    """A special type for deprecated parameter variable names.
-
-    There are times when we need to change the name of parameter, but this
-    breaks the external-facing python API used in configuration files. Using
-    this "type" for a parameter will warn users that they are using the old
-    name, but allow for backwards compatibility.
-
-    Usage example:
-    In the following example, the `time` parameter is changed to `delay`.
-
-    ```
-    class SomeDevice(SimObject):
-        delay = Param.Latency('1ns', 'The time to wait before something')
-        time = DeprecatedParam(delay, '`time` is now called `delay`')
-    ```
-    """
-
-    def __init__(self, new_param, message=''):
-        """new_param: the new parameter variable that users should be using
-        instead of this parameter variable.
-        message: an optional message to print when warning the user
-        """
-        self.message = message
-        self.newParam = new_param
-        # Note: We won't know the string variable names until later in the
-        # SimObject initialization process. Note: we expect that the setters
-        # will be called when the SimObject type (class) is initialized so
-        # these variables should be filled in before the instance of the
-        # SimObject with this parameter is constructed
-        self._oldName = ''
-        self._newName = ''
-
-    @property
-    def oldName(self):
-        assert(self._oldName != '') # should already be set
-        return self._oldName
-
-    @oldName.setter
-    def oldName(self, name):
-        assert(self._oldName == '') # Cannot "re-set" this value
-        self._oldName = name
-
-    @property
-    def newName(self):
-        assert(self._newName != '') # should already be set
-        return self._newName
-
-    @newName.setter
-    def newName(self, name):
-        assert(self._newName == '') # Cannot "re-set" this value
-        self._newName = name
-
-    def printWarning(self, instance_name, simobj_name):
-        """Issue a warning that this variable name should not be used.
-
-        instance_name: str, the name of the instance used in python
-        simobj_name: str, the name of the SimObject type
-        """
-        if not self.message:
-            self.message = "See {} for more information".format(simobj_name)
-        warn('{}.{} is deprecated. {}'.format(
-            instance_name, self._oldName, self.message))
-
-baseEnums = allEnums.copy()
-baseParams = allParams.copy()
-
-def clear():
-    global allEnums, allParams
-
-    allEnums = baseEnums.copy()
-    allParams = baseParams.copy()
-
-__all__ = ['Param', 'VectorParam',
-           'Enum', 'ScopedEnum', 'Bool', 'String', 'Float',
-           'Int', 'Unsigned', 'Int8', 'UInt8', 'Int16', 'UInt16',
-           'Int32', 'UInt32', 'Int64', 'UInt64',
-           'Counter', 'Addr', 'Tick', 'Percent',
-           'TcpPort', 'UdpPort', 'EthernetAddr',
-           'IpAddress', 'IpNetmask', 'IpWithPort',
-           'MemorySize', 'MemorySize32',
-           'Latency', 'Frequency', 'Clock', 'Voltage', 'Current', 'Energy',
-           'NetworkBandwidth', 'MemoryBandwidth',
-           'AddrRange',
-           'MaxAddr', 'MaxTick', 'AllMemory',
-           'Time',
-           'NextEthernetAddr', 'NULL',
-           'Port', 'RequestPort', 'ResponsePort', 'MasterPort', 'SlavePort',
-           'VectorPort', 'VectorRequestPort', 'VectorResponsePort',
-           'VectorMasterPort', 'VectorSlavePort',
-           'DeprecatedParam',
-           ]
